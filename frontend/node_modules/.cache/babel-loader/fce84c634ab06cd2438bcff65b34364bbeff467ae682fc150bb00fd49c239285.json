{"ast":null,"code":"/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport { flowParseArrow, flowParseFunctionBodyAndFinish, flowParseMaybeAssign, flowParseSubscript, flowParseSubscripts, flowParseVariance, flowStartParseAsyncArrowFromCallExpression, flowStartParseNewArguments, flowStartParseObjPropValue } from \"../plugins/flow\";\nimport { jsxParseElement } from \"../plugins/jsx/index\";\nimport { typedParseConditional, typedParseParenItem } from \"../plugins/types\";\nimport { tsParseArrow, tsParseFunctionBodyAndFinish, tsParseMaybeAssign, tsParseSubscript, tsParseType, tsParseTypeAssertion, tsStartParseAsyncArrowFromCallExpression, tsStartParseObjPropValue } from \"../plugins/typescript\";\nimport { eat, IdentifierRole, lookaheadCharCode, lookaheadType, match, next, nextTemplateToken, popTypeContext, pushTypeContext, rescan_gt, retokenizeSlashAsRegex } from \"../tokenizer/index\";\nimport { ContextualKeyword } from \"../tokenizer/keywords\";\nimport { Scope } from \"../tokenizer/state\";\nimport { TokenType, TokenType as tt } from \"../tokenizer/types\";\nimport { charCodes } from \"../util/charcodes\";\nimport { IS_IDENTIFIER_START } from \"../util/identifier\";\nimport { getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state } from \"./base\";\nimport { markPriorBindingIdentifier, parseBindingIdentifier, parseMaybeDefault, parseRest, parseSpread } from \"./lval\";\nimport { parseBlock, parseBlockBody, parseClass, parseDecorators, parseFunction, parseFunctionParams } from \"./statement\";\nimport { canInsertSemicolon, eatContextual, expect, expectContextual, hasFollowingLineBreak, hasPrecedingLineBreak, isContextual, unexpected } from \"./util\";\nexport class StopState {\n  constructor(stop) {\n    this.stop = stop;\n  }\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\nexport function parseExpression(noIn = false) {\n  parseMaybeAssign(noIn);\n  if (match(tt.comma)) {\n    while (eat(tt.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n}\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\nexport function parseMaybeAssign(noIn = false, isWithinParens = false) {\n  if (isTypeScriptEnabled) {\n    return tsParseMaybeAssign(noIn, isWithinParens);\n  } else if (isFlowEnabled) {\n    return flowParseMaybeAssign(noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\nexport function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt._yield)) {\n    parseYield();\n    return false;\n  }\n  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {\n    state.potentialArrowAt = state.start;\n  }\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (state.type & TokenType.IS_ASSIGN) {\n    next();\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n}\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\nfunction parseConditional(noIn) {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseConditional(noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\nexport function baseParseConditional(noIn) {\n  if (eat(tt.question)) {\n    parseMaybeAssign();\n    expect(tt.colon);\n    parseMaybeAssign(noIn);\n  }\n}\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (isTypeScriptEnabled && (tt._in & TokenType.PRECEDENCE_MASK) > minPrec && !hasPrecedingLineBreak() && (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))) {\n    const oldIsType = pushTypeContext(1);\n    tsParseType();\n    popTypeContext(oldIsType);\n    rescan_gt();\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n  const prec = state.type & TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !match(tt._in))) {\n    if (prec > minPrec) {\n      const op = state.type;\n      next();\n      if (op === tt.nullishCoalescing) {\n        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n      const rhsStartTokenIndex = state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === tt.nullishCoalescing) {\n        state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\nexport function parseMaybeUnary() {\n  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {\n    tsParseTypeAssertion();\n    return false;\n  }\n  if (isContextual(ContextualKeyword._module) && lookaheadCharCode() === charCodes.leftCurlyBrace && !hasFollowingLineBreak()) {\n    parseModuleExpression();\n    return false;\n  }\n  if (state.type & TokenType.IS_PREFIX) {\n    next();\n    parseMaybeUnary();\n    return false;\n  }\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (state.type === tt.preIncDec) {\n      state.type = tt.postIncDec;\n    }\n    next();\n  }\n  return false;\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\nexport function parseExprSubscripts() {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {\n    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n}\nfunction parseSubscripts(startTokenIndex, noCalls = false) {\n  if (isFlowEnabled) {\n    flowParseSubscripts(startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\nexport function baseParseSubscripts(startTokenIndex, noCalls = false) {\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !state.error);\n}\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (isTypeScriptEnabled) {\n    tsParseSubscript(startTokenIndex, noCalls, stopState);\n  } else if (isFlowEnabled) {\n    flowParseSubscript(startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\nexport function baseParseSubscript(startTokenIndex, noCalls, stopState) {\n  if (!noCalls && eat(tt.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (match(tt.questionDot)) {\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && lookaheadType() === tt.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    if (eat(tt.bracketL)) {\n      parseExpression();\n      expect(tt.bracketR);\n    } else if (eat(tt.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseMaybePrivateName();\n    }\n  } else if (eat(tt.dot)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    expect(tt.bracketR);\n  } else if (!noCalls && match(tt.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = state.snapshot();\n      const asyncStartTokenIndex = state.tokens.length;\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        state.scopeDepth++;\n        parseFunctionParams();\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (match(tt.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n}\nexport function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async && !canInsertSemicolon();\n}\nexport function parseCallExpressionArguments() {\n  let first = true;\n  while (!eat(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.parenR)) {\n        break;\n      }\n    }\n    parseExprListItem(false);\n  }\n}\nfunction shouldParseAsyncArrow() {\n  return match(tt.colon) || match(tt.arrow);\n}\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (isTypeScriptEnabled) {\n    tsStartParseAsyncArrowFromCallExpression();\n  } else if (isFlowEnabled) {\n    flowStartParseAsyncArrowFromCallExpression();\n  }\n  expect(tt.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\nexport function parseExprAtom() {\n  if (eat(tt.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n  if (match(tt.jsxText) || match(tt.jsxEmptyText)) {\n    parseLiteral();\n    return false;\n  } else if (match(tt.lessThan) && isJSXEnabled) {\n    state.type = tt.jsxTagStart;\n    jsxParseElement();\n    next();\n    return false;\n  }\n  const canBeArrow = state.potentialArrowAt === state.start;\n  switch (state.type) {\n    case tt.slash:\n    case tt.assign:\n      retokenizeSlashAsRegex();\n    // Fall through.\n\n    case tt._super:\n    case tt._this:\n    case tt.regexp:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt.string:\n    case tt._null:\n    case tt._true:\n    case tt._false:\n      next();\n      return false;\n    case tt._import:\n      next();\n      if (match(tt.dot)) {\n        // import.meta\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        next();\n        parseIdentifier();\n      }\n      return false;\n    case tt.name:\n      {\n        const startTokenIndex = state.tokens.length;\n        const functionStart = state.start;\n        const contextualKeyword = state.contextualKeyword;\n        parseIdentifier();\n        if (contextualKeyword === ContextualKeyword._await) {\n          parseAwait();\n          return false;\n        } else if (contextualKeyword === ContextualKeyword._async && match(tt._function) && !canInsertSemicolon()) {\n          next();\n          parseFunction(functionStart, false);\n          return false;\n        } else if (canBeArrow && contextualKeyword === ContextualKeyword._async && !canInsertSemicolon() && match(tt.name)) {\n          state.scopeDepth++;\n          parseBindingIdentifier(false);\n          expect(tt.arrow);\n          // let foo = async bar => {};\n          parseArrowExpression(startTokenIndex);\n          return true;\n        } else if (match(tt._do) && !canInsertSemicolon()) {\n          next();\n          parseBlock();\n          return false;\n        }\n        if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {\n          state.scopeDepth++;\n          markPriorBindingIdentifier(false);\n          expect(tt.arrow);\n          parseArrowExpression(startTokenIndex);\n          return true;\n        }\n        state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;\n        return false;\n      }\n    case tt._do:\n      {\n        next();\n        parseBlock();\n        return false;\n      }\n    case tt.parenL:\n      {\n        const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n        return wasArrow;\n      }\n    case tt.bracketL:\n      next();\n      parseExprList(tt.bracketR, true);\n      return false;\n    case tt.braceL:\n      parseObj(false, false);\n      return false;\n    case tt._function:\n      parseFunctionExpression();\n      return false;\n    case tt.at:\n      parseDecorators();\n    // Fall through.\n\n    case tt._class:\n      parseClass(false);\n      return false;\n    case tt._new:\n      parseNew();\n      return false;\n    case tt.backQuote:\n      parseTemplate();\n      return false;\n    case tt.doubleColon:\n      {\n        next();\n        parseNoCallExpr();\n        return false;\n      }\n    case tt.hash:\n      {\n        const code = lookaheadCharCode();\n        if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {\n          parseMaybePrivateName();\n        } else {\n          next();\n        }\n        // Smart pipeline topic reference.\n        return false;\n      }\n    default:\n      unexpected();\n      return false;\n  }\n}\nfunction parseMaybePrivateName() {\n  eat(tt.hash);\n  parseIdentifier();\n}\nfunction parseFunctionExpression() {\n  const functionStart = state.start;\n  parseIdentifier();\n  if (eat(tt.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  parseFunction(functionStart, false);\n}\nexport function parseLiteral() {\n  next();\n}\nexport function parseParenExpression() {\n  expect(tt.parenL);\n  parseExpression();\n  expect(tt.parenR);\n}\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = state.snapshot();\n  const startTokenIndex = state.tokens.length;\n  expect(tt.parenL);\n  let first = true;\n  while (!match(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (match(tt.parenR)) {\n        break;\n      }\n    }\n    if (match(tt.ellipsis)) {\n      parseRest(false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n  expect(tt.parenR);\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      state.restoreFromSnapshot(snapshot);\n      state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      parseFunctionParams();\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      if (state.error) {\n        // Nevermind! This must have been something that looks very much like an\n        // arrow function but where its \"parameter list\" isn't actually a valid\n        // parameter list. Force non-arrow parsing.\n        // See https://github.com/alangpierce/sucrase/issues/666 for an example.\n        state.restoreFromSnapshot(snapshot);\n        parseParenAndDistinguishExpression(false);\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\nfunction shouldParseArrow() {\n  return match(tt.colon) || !canInsertSemicolon();\n}\n\n// Returns whether there was an arrow token.\nexport function parseArrow() {\n  if (isTypeScriptEnabled) {\n    return tsParseArrow();\n  } else if (isFlowEnabled) {\n    return flowParseArrow();\n  } else {\n    return eat(tt.arrow);\n  }\n}\nfunction parseParenItem() {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseParenItem();\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  expect(tt._new);\n  if (eat(tt.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNewCallee();\n  if (isFlowEnabled) {\n    flowStartParseNewArguments();\n  }\n  if (eat(tt.parenL)) {\n    parseExprList(tt.parenR);\n  }\n}\nfunction parseNewCallee() {\n  parseNoCallExpr();\n  eat(tt.questionDot);\n}\nexport function parseTemplate() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\n// Parse an object literal or binding pattern.\nexport function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = getNextContextId();\n  let first = true;\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    let isGenerator = false;\n    if (match(tt.ellipsis)) {\n      const previousIndex = state.tokens.length;\n      parseSpread();\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (state.tokens.length === previousIndex + 2) {\n          markPriorBindingIdentifier(isBlockScope);\n        }\n        if (eat(tt.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n    if (!isPattern) {\n      isGenerator = eat(tt.star);\n    }\n    if (!isPattern && isContextual(ContextualKeyword._async)) {\n      if (isGenerator) unexpected();\n      parseIdentifier();\n      if (match(tt.colon) || match(tt.parenL) || match(tt.braceR) || match(tt.eq) || match(tt.comma)) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (match(tt.star)) {\n          next();\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n}\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return !isPattern && (match(tt.string) ||\n  // get \"string\"() {}\n  match(tt.num) ||\n  // get 1() {}\n  match(tt.bracketL) ||\n  // get [\"string\"]() {}\n  match(tt.name) ||\n  // get foo() {}\n  !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}\n  ;\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = state.start;\n  if (match(tt.parenL)) {\n    if (isPattern) unexpected();\n    parseMethod(functionStart, /* isConstructor */false);\n    return true;\n  }\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */false);\n    return true;\n  }\n  return false;\n}\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (eat(tt.colon)) {\n    if (isPattern) {\n      parseMaybeDefault(isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  let identifierRole;\n  if (isPattern) {\n    if (state.scopeDepth === 0) {\n      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;\n    } else if (isBlockScope) {\n      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n    } else {\n      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n    }\n  } else {\n    identifierRole = IdentifierRole.ObjectShorthand;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  parseMaybeDefault(isBlockScope, true);\n}\nfunction parseObjPropValue(isPattern, isBlockScope, objectContextId) {\n  if (isTypeScriptEnabled) {\n    tsStartParseObjPropValue();\n  } else if (isFlowEnabled) {\n    flowStartParseObjPropValue();\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\nexport function parsePropertyName(objectContextId) {\n  if (isFlowEnabled) {\n    flowParseVariance();\n  }\n  if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    expect(tt.bracketR);\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (match(tt.num) || match(tt.string) || match(tt.bigint) || match(tt.decimal)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  }\n}\n\n// Parse object or class method.\nexport function parseMethod(functionStart, isConstructor) {\n  const funcContextId = getNextContextId();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  parseFunctionParams(allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\nexport function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\nexport function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsParseFunctionBodyAndFinish(functionStart, funcContextId);\n  } else if (isFlowEnabled) {\n    flowParseFunctionBodyAndFinish(funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n}\nexport function parseFunctionBody(allowExpression, funcContextId = 0) {\n  const isExpression = allowExpression && !match(tt.braceL);\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    parseBlock(true /* isFunctionScope */, funcContextId);\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close, allowEmpty = false) {\n  let first = true;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && match(tt.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (match(tt.ellipsis)) {\n    parseSpread();\n    parseParenItem();\n  } else if (match(tt.question)) {\n    // Partial function application proposal.\n    next();\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\nexport function parseIdentifier() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt.name;\n}\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  next();\n  if (!match(tt.semi) && !canInsertSemicolon()) {\n    eat(tt.star);\n    parseMaybeAssign();\n  }\n}\n\n// https://github.com/tc39/proposal-js-module-blocks\nfunction parseModuleExpression() {\n  expectContextual(ContextualKeyword._module);\n  expect(tt.braceL);\n  // For now, just call parseBlockBody to parse the block. In the future when we\n  // implement full support, we'll want to emit scopes and possibly other\n  // information.\n  parseBlockBody(tt.braceR);\n}","map":{"version":3,"names":["flowParseArrow","flowParseFunctionBodyAndFinish","flowParseMaybeAssign","flowParseSubscript","flowParseSubscripts","flowParseVariance","flowStartParseAsyncArrowFromCallExpression","flowStartParseNewArguments","flowStartParseObjPropValue","jsxParseElement","typedParseConditional","typedParseParenItem","tsParseArrow","tsParseFunctionBodyAndFinish","tsParseMaybeAssign","tsParseSubscript","tsParseType","tsParseTypeAssertion","tsStartParseAsyncArrowFromCallExpression","tsStartParseObjPropValue","eat","IdentifierRole","lookaheadCharCode","lookaheadType","match","next","nextTemplateToken","popTypeContext","pushTypeContext","rescan_gt","retokenizeSlashAsRegex","ContextualKeyword","Scope","TokenType","tt","charCodes","IS_IDENTIFIER_START","getNextContextId","isFlowEnabled","isJSXEnabled","isTypeScriptEnabled","state","markPriorBindingIdentifier","parseBindingIdentifier","parseMaybeDefault","parseRest","parseSpread","parseBlock","parseBlockBody","parseClass","parseDecorators","parseFunction","parseFunctionParams","canInsertSemicolon","eatContextual","expect","expectContextual","hasFollowingLineBreak","hasPrecedingLineBreak","isContextual","unexpected","StopState","constructor","stop","parseExpression","noIn","parseMaybeAssign","comma","isWithinParens","baseParseMaybeAssign","_yield","parseYield","parenL","name","potentialArrowAt","start","wasArrow","parseMaybeConditional","parseParenItem","type","IS_ASSIGN","parseExprOps","parseConditional","baseParseConditional","question","colon","startTokenIndex","tokens","length","parseMaybeUnary","parseExprOp","minPrec","_in","PRECEDENCE_MASK","_as","_satisfies","oldIsType","prec","op","nullishCoalescing","nullishStartIndex","rhsStartTokenIndex","IS_RIGHT_ASSOCIATIVE","numNullishCoalesceStarts","numNullishCoalesceEnds","lessThan","_module","leftCurlyBrace","parseModuleExpression","IS_PREFIX","parseExprSubscripts","IS_POSTFIX","preIncDec","postIncDec","parseExprAtom","parseSubscripts","isOptionalChainStart","isOptionalChainEnd","noCalls","baseParseSubscripts","stopState","parseSubscript","error","baseParseSubscript","doubleColon","parseNoCallExpr","questionDot","subscriptStartIndex","bracketL","bracketR","parseCallExpressionArguments","parseMaybePrivateName","dot","atPossibleAsync","snapshot","asyncStartTokenIndex","callContextId","contextId","shouldParseAsyncArrow","restoreFromSnapshot","scopeDepth","parseAsyncArrowFromCallExpression","backQuote","parseTemplate","contextualKeyword","_async","first","parenR","parseExprListItem","arrow","parseArrowExpression","modulo","parseIdentifier","jsxText","jsxEmptyText","parseLiteral","jsxTagStart","canBeArrow","slash","assign","_super","_this","regexp","num","bigint","decimal","string","_null","_true","_false","_import","functionStart","_await","parseAwait","_function","_do","identifierRole","Access","parseParenAndDistinguishExpression","parseExprList","braceL","parseObj","parseFunctionExpression","at","_class","_new","parseNew","hash","code","backslash","parseParenExpression","ellipsis","shouldParseArrow","parseArrow","parseNewCallee","dollarBraceL","isPattern","isBlockScope","braceR","isGenerator","previousIndex","star","eq","parsePropertyName","parseObjPropValue","isGetterOrSetterMethod","IS_KEYWORD","parseObjectMethod","objectContextId","parseMethod","parseObjectProperty","ObjectShorthandTopLevelDeclaration","ObjectShorthandBlockScopedDeclaration","ObjectShorthandFunctionScopedDeclaration","ObjectShorthand","wasMethod","ObjectKey","isConstructor","funcContextId","allowModifiers","parseFunctionBodyAndFinish","endTokenIndex","scopes","push","parseFunctionBody","allowExpression","isExpression","close","allowEmpty","semi"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/traverser/expression.js"],"sourcesContent":["/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  flowParseArrow,\n  flowParseFunctionBodyAndFinish,\n  flowParseMaybeAssign,\n  flowParseSubscript,\n  flowParseSubscripts,\n  flowParseVariance,\n  flowStartParseAsyncArrowFromCallExpression,\n  flowStartParseNewArguments,\n  flowStartParseObjPropValue,\n} from \"../plugins/flow\";\nimport {jsxParseElement} from \"../plugins/jsx/index\";\nimport {typedParseConditional, typedParseParenItem} from \"../plugins/types\";\nimport {\n  tsParseArrow,\n  tsParseFunctionBodyAndFinish,\n  tsParseMaybeAssign,\n  tsParseSubscript,\n  tsParseType,\n  tsParseTypeAssertion,\n  tsStartParseAsyncArrowFromCallExpression,\n  tsStartParseObjPropValue,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  lookaheadCharCode,\n  lookaheadType,\n  match,\n  next,\n  nextTemplateToken,\n  popTypeContext,\n  pushTypeContext,\n  rescan_gt,\n  retokenizeSlashAsRegex,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_START} from \"../util/identifier\";\nimport {getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  markPriorBindingIdentifier,\n  parseBindingIdentifier,\n  parseMaybeDefault,\n  parseRest,\n  parseSpread,\n} from \"./lval\";\nimport {\n  parseBlock,\n  parseBlockBody,\n  parseClass,\n  parseDecorators,\n  parseFunction,\n  parseFunctionParams,\n} from \"./statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasFollowingLineBreak,\n  hasPrecedingLineBreak,\n  isContextual,\n  unexpected,\n} from \"./util\";\n\nexport class StopState {\n  \n  constructor(stop) {\n    this.stop = stop;\n  }\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\nexport function parseExpression(noIn = false) {\n  parseMaybeAssign(noIn);\n  if (match(tt.comma)) {\n    while (eat(tt.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n}\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\nexport function parseMaybeAssign(noIn = false, isWithinParens = false) {\n  if (isTypeScriptEnabled) {\n    return tsParseMaybeAssign(noIn, isWithinParens);\n  } else if (isFlowEnabled) {\n    return flowParseMaybeAssign(noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\nexport function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt._yield)) {\n    parseYield();\n    return false;\n  }\n\n  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {\n    state.potentialArrowAt = state.start;\n  }\n\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (state.type & TokenType.IS_ASSIGN) {\n    next();\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n}\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\n\nfunction parseConditional(noIn) {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseConditional(noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\n\nexport function baseParseConditional(noIn) {\n  if (eat(tt.question)) {\n    parseMaybeAssign();\n    expect(tt.colon);\n    parseMaybeAssign(noIn);\n  }\n}\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (\n    isTypeScriptEnabled &&\n    (tt._in & TokenType.PRECEDENCE_MASK) > minPrec &&\n    !hasPrecedingLineBreak() &&\n    (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))\n  ) {\n    const oldIsType = pushTypeContext(1);\n    tsParseType();\n    popTypeContext(oldIsType);\n    rescan_gt();\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n\n  const prec = state.type & TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !match(tt._in))) {\n    if (prec > minPrec) {\n      const op = state.type;\n      next();\n      if (op === tt.nullishCoalescing) {\n        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n\n      const rhsStartTokenIndex = state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === tt.nullishCoalescing) {\n        state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\nexport function parseMaybeUnary() {\n  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {\n    tsParseTypeAssertion();\n    return false;\n  }\n  if (\n    isContextual(ContextualKeyword._module) &&\n    lookaheadCharCode() === charCodes.leftCurlyBrace &&\n    !hasFollowingLineBreak()\n  ) {\n    parseModuleExpression();\n    return false;\n  }\n  if (state.type & TokenType.IS_PREFIX) {\n    next();\n    parseMaybeUnary();\n    return false;\n  }\n\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (state.type === tt.preIncDec) {\n      state.type = tt.postIncDec;\n    }\n    next();\n  }\n  return false;\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\nexport function parseExprSubscripts() {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {\n    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n}\n\nfunction parseSubscripts(startTokenIndex, noCalls = false) {\n  if (isFlowEnabled) {\n    flowParseSubscripts(startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\n\nexport function baseParseSubscripts(startTokenIndex, noCalls = false) {\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !state.error);\n}\n\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (isTypeScriptEnabled) {\n    tsParseSubscript(startTokenIndex, noCalls, stopState);\n  } else if (isFlowEnabled) {\n    flowParseSubscript(startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\nexport function baseParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!noCalls && eat(tt.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (match(tt.questionDot)) {\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && lookaheadType() === tt.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    if (eat(tt.bracketL)) {\n      parseExpression();\n      expect(tt.bracketR);\n    } else if (eat(tt.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseMaybePrivateName();\n    }\n  } else if (eat(tt.dot)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    expect(tt.bracketR);\n  } else if (!noCalls && match(tt.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = state.snapshot();\n      const asyncStartTokenIndex = state.tokens.length;\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n      const callContextId = getNextContextId();\n\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        state.scopeDepth++;\n\n        parseFunctionParams();\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (match(tt.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n}\n\nexport function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    !canInsertSemicolon()\n  );\n}\n\nexport function parseCallExpressionArguments() {\n  let first = true;\n  while (!eat(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.parenR)) {\n        break;\n      }\n    }\n\n    parseExprListItem(false);\n  }\n}\n\nfunction shouldParseAsyncArrow() {\n  return match(tt.colon) || match(tt.arrow);\n}\n\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (isTypeScriptEnabled) {\n    tsStartParseAsyncArrowFromCallExpression();\n  } else if (isFlowEnabled) {\n    flowStartParseAsyncArrowFromCallExpression();\n  }\n  expect(tt.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\nexport function parseExprAtom() {\n  if (eat(tt.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n\n  if (match(tt.jsxText) || match(tt.jsxEmptyText)) {\n    parseLiteral();\n    return false;\n  } else if (match(tt.lessThan) && isJSXEnabled) {\n    state.type = tt.jsxTagStart;\n    jsxParseElement();\n    next();\n    return false;\n  }\n\n  const canBeArrow = state.potentialArrowAt === state.start;\n  switch (state.type) {\n    case tt.slash:\n    case tt.assign:\n      retokenizeSlashAsRegex();\n    // Fall through.\n\n    case tt._super:\n    case tt._this:\n    case tt.regexp:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt.string:\n    case tt._null:\n    case tt._true:\n    case tt._false:\n      next();\n      return false;\n\n    case tt._import:\n      next();\n      if (match(tt.dot)) {\n        // import.meta\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        next();\n        parseIdentifier();\n      }\n      return false;\n\n    case tt.name: {\n      const startTokenIndex = state.tokens.length;\n      const functionStart = state.start;\n      const contextualKeyword = state.contextualKeyword;\n      parseIdentifier();\n      if (contextualKeyword === ContextualKeyword._await) {\n        parseAwait();\n        return false;\n      } else if (\n        contextualKeyword === ContextualKeyword._async &&\n        match(tt._function) &&\n        !canInsertSemicolon()\n      ) {\n        next();\n        parseFunction(functionStart, false);\n        return false;\n      } else if (\n        canBeArrow &&\n        contextualKeyword === ContextualKeyword._async &&\n        !canInsertSemicolon() &&\n        match(tt.name)\n      ) {\n        state.scopeDepth++;\n        parseBindingIdentifier(false);\n        expect(tt.arrow);\n        // let foo = async bar => {};\n        parseArrowExpression(startTokenIndex);\n        return true;\n      } else if (match(tt._do) && !canInsertSemicolon()) {\n        next();\n        parseBlock();\n        return false;\n      }\n\n      if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {\n        state.scopeDepth++;\n        markPriorBindingIdentifier(false);\n        expect(tt.arrow);\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;\n      return false;\n    }\n\n    case tt._do: {\n      next();\n      parseBlock();\n      return false;\n    }\n\n    case tt.parenL: {\n      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n      return wasArrow;\n    }\n\n    case tt.bracketL:\n      next();\n      parseExprList(tt.bracketR, true);\n      return false;\n\n    case tt.braceL:\n      parseObj(false, false);\n      return false;\n\n    case tt._function:\n      parseFunctionExpression();\n      return false;\n\n    case tt.at:\n      parseDecorators();\n    // Fall through.\n\n    case tt._class:\n      parseClass(false);\n      return false;\n\n    case tt._new:\n      parseNew();\n      return false;\n\n    case tt.backQuote:\n      parseTemplate();\n      return false;\n\n    case tt.doubleColon: {\n      next();\n      parseNoCallExpr();\n      return false;\n    }\n\n    case tt.hash: {\n      const code = lookaheadCharCode();\n      if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {\n        parseMaybePrivateName();\n      } else {\n        next();\n      }\n      // Smart pipeline topic reference.\n      return false;\n    }\n\n    default:\n      unexpected();\n      return false;\n  }\n}\n\nfunction parseMaybePrivateName() {\n  eat(tt.hash);\n  parseIdentifier();\n}\n\nfunction parseFunctionExpression() {\n  const functionStart = state.start;\n  parseIdentifier();\n  if (eat(tt.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  parseFunction(functionStart, false);\n}\n\nexport function parseLiteral() {\n  next();\n}\n\nexport function parseParenExpression() {\n  expect(tt.parenL);\n  parseExpression();\n  expect(tt.parenR);\n}\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = state.snapshot();\n\n  const startTokenIndex = state.tokens.length;\n  expect(tt.parenL);\n\n  let first = true;\n\n  while (!match(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (match(tt.parenR)) {\n        break;\n      }\n    }\n\n    if (match(tt.ellipsis)) {\n      parseRest(false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n\n  expect(tt.parenR);\n\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      state.restoreFromSnapshot(snapshot);\n      state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      parseFunctionParams();\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      if (state.error) {\n        // Nevermind! This must have been something that looks very much like an\n        // arrow function but where its \"parameter list\" isn't actually a valid\n        // parameter list. Force non-arrow parsing.\n        // See https://github.com/alangpierce/sucrase/issues/666 for an example.\n        state.restoreFromSnapshot(snapshot);\n        parseParenAndDistinguishExpression(false);\n        return false;\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldParseArrow() {\n  return match(tt.colon) || !canInsertSemicolon();\n}\n\n// Returns whether there was an arrow token.\nexport function parseArrow() {\n  if (isTypeScriptEnabled) {\n    return tsParseArrow();\n  } else if (isFlowEnabled) {\n    return flowParseArrow();\n  } else {\n    return eat(tt.arrow);\n  }\n}\n\nfunction parseParenItem() {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseParenItem();\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  expect(tt._new);\n  if (eat(tt.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNewCallee();\n  if (isFlowEnabled) {\n    flowStartParseNewArguments();\n  }\n  if (eat(tt.parenL)) {\n    parseExprList(tt.parenR);\n  }\n}\n\nfunction parseNewCallee() {\n  parseNoCallExpr();\n  eat(tt.questionDot);\n}\n\nexport function parseTemplate() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\n// Parse an object literal or binding pattern.\nexport function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = getNextContextId();\n  let first = true;\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    let isGenerator = false;\n    if (match(tt.ellipsis)) {\n      const previousIndex = state.tokens.length;\n      parseSpread();\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (state.tokens.length === previousIndex + 2) {\n          markPriorBindingIdentifier(isBlockScope);\n        }\n        if (eat(tt.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n\n    if (!isPattern) {\n      isGenerator = eat(tt.star);\n    }\n\n    if (!isPattern && isContextual(ContextualKeyword._async)) {\n      if (isGenerator) unexpected();\n\n      parseIdentifier();\n      if (\n        match(tt.colon) ||\n        match(tt.parenL) ||\n        match(tt.braceR) ||\n        match(tt.eq) ||\n        match(tt.comma)\n      ) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (match(tt.star)) {\n          next();\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n}\n\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return (\n    !isPattern &&\n    (match(tt.string) || // get \"string\"() {}\n      match(tt.num) || // get 1() {}\n      match(tt.bracketL) || // get [\"string\"]() {}\n      match(tt.name) || // get foo() {}\n      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}\n  );\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = state.start;\n  if (match(tt.parenL)) {\n    if (isPattern) unexpected();\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n  return false;\n}\n\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (eat(tt.colon)) {\n    if (isPattern) {\n      parseMaybeDefault(isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  let identifierRole;\n  if (isPattern) {\n    if (state.scopeDepth === 0) {\n      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;\n    } else if (isBlockScope) {\n      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n    } else {\n      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n    }\n  } else {\n    identifierRole = IdentifierRole.ObjectShorthand;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  parseMaybeDefault(isBlockScope, true);\n}\n\nfunction parseObjPropValue(\n  isPattern,\n  isBlockScope,\n  objectContextId,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseObjPropValue();\n  } else if (isFlowEnabled) {\n    flowStartParseObjPropValue();\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\n\nexport function parsePropertyName(objectContextId) {\n  if (isFlowEnabled) {\n    flowParseVariance();\n  }\n  if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    expect(tt.bracketR);\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (match(tt.num) || match(tt.string) || match(tt.bigint) || match(tt.decimal)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  }\n}\n\n// Parse object or class method.\nexport function parseMethod(functionStart, isConstructor) {\n  const funcContextId = getNextContextId();\n\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  parseFunctionParams(allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\nexport function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\nexport function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsParseFunctionBodyAndFinish(functionStart, funcContextId);\n  } else if (isFlowEnabled) {\n    flowParseFunctionBodyAndFinish(funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n}\n\nexport function parseFunctionBody(allowExpression, funcContextId = 0) {\n  const isExpression = allowExpression && !match(tt.braceL);\n\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    parseBlock(true /* isFunctionScope */, funcContextId);\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close, allowEmpty = false) {\n  let first = true;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\n\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && match(tt.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (match(tt.ellipsis)) {\n    parseSpread();\n    parseParenItem();\n  } else if (match(tt.question)) {\n    // Partial function application proposal.\n    next();\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\nexport function parseIdentifier() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt.name;\n}\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  next();\n  if (!match(tt.semi) && !canInsertSemicolon()) {\n    eat(tt.star);\n    parseMaybeAssign();\n  }\n}\n\n// https://github.com/tc39/proposal-js-module-blocks\nfunction parseModuleExpression() {\n  expectContextual(ContextualKeyword._module);\n  expect(tt.braceL);\n  // For now, just call parseBlockBody to parse the block. In the future when we\n  // implement full support, we'll want to emit scopes and possibly other\n  // information.\n  parseBlockBody(tt.braceR);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}