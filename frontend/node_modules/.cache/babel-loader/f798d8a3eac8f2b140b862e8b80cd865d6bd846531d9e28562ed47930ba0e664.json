{"ast":null,"code":"import { eat, finishToken, getTokenFromCode, IdentifierRole, JSXRole, match, next, skipSpace, Token } from \"../../tokenizer/index\";\nimport { TokenType as tt } from \"../../tokenizer/types\";\nimport { input, isTypeScriptEnabled, state } from \"../../traverser/base\";\nimport { parseExpression, parseMaybeAssign } from \"../../traverser/expression\";\nimport { expect, unexpected } from \"../../traverser/util\";\nimport { charCodes } from \"../../util/charcodes\";\nimport { IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START } from \"../../util/identifier\";\nimport { tsTryParseJSXTypeArgument } from \"../typescript\";\n\n/**\n * Read token with JSX contents.\n *\n * In addition to detecting jsxTagStart and also regular tokens that might be\n * part of an expression, this code detects the start and end of text ranges\n * within JSX children. In order to properly count the number of children, we\n * distinguish jsxText from jsxEmptyText, which is a text range that simplifies\n * to the empty string after JSX whitespace trimming.\n *\n * It turns out that a JSX text range will simplify to the empty string if and\n * only if both of these conditions hold:\n * - The range consists entirely of whitespace characters (only counting space,\n *   tab, \\r, and \\n).\n * - The range has at least one newline.\n * This can be proven by analyzing any implementation of whitespace trimming,\n * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.\n */\nfunction jsxReadToken() {\n  let sawNewline = false;\n  let sawNonWhitespace = false;\n  while (true) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated JSX contents\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.lessThan || ch === charCodes.leftCurlyBrace) {\n      if (state.pos === state.start) {\n        if (ch === charCodes.lessThan) {\n          state.pos++;\n          finishToken(tt.jsxTagStart);\n          return;\n        }\n        getTokenFromCode(ch);\n        return;\n      }\n      if (sawNewline && !sawNonWhitespace) {\n        finishToken(tt.jsxEmptyText);\n      } else {\n        finishToken(tt.jsxText);\n      }\n      return;\n    }\n\n    // This is part of JSX text.\n    if (ch === charCodes.lineFeed) {\n      sawNewline = true;\n    } else if (ch !== charCodes.space && ch !== charCodes.carriageReturn && ch !== charCodes.tab) {\n      sawNonWhitespace = true;\n    }\n    state.pos++;\n  }\n}\nfunction jsxReadString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === quote) {\n      state.pos++;\n      break;\n    }\n    state.pos++;\n  }\n  finishToken(tt.string);\n}\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can't contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\nfunction jsxReadWord() {\n  let ch;\n  do {\n    if (state.pos > input.length) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n      return;\n    }\n    ch = input.charCodeAt(++state.pos);\n  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);\n  finishToken(tt.jsxName);\n}\n\n// Parse next token as JSX identifier\nfunction jsxParseIdentifier() {\n  nextJSXTagToken();\n}\n\n// Parse namespaced identifier.\nfunction jsxParseNamespacedName(identifierRole) {\n  jsxParseIdentifier();\n  if (!eat(tt.colon)) {\n    // Plain identifier, so this is an access.\n    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n    return;\n  }\n  // Process the second half of the namespaced name.\n  jsxParseIdentifier();\n}\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\nfunction jsxParseElementName() {\n  const firstTokenIndex = state.tokens.length;\n  jsxParseNamespacedName(IdentifierRole.Access);\n  let hadDot = false;\n  while (match(tt.dot)) {\n    hadDot = true;\n    nextJSXTagToken();\n    jsxParseIdentifier();\n  }\n  // For tags like <div> with a lowercase letter and no dots, the name is\n  // actually *not* an identifier access, since it's referring to a built-in\n  // tag name. Remove the identifier role in this case so that it's not\n  // accidentally transformed by the imports transform when preserving JSX.\n  if (!hadDot) {\n    const firstToken = state.tokens[firstTokenIndex];\n    const firstChar = input.charCodeAt(firstToken.start);\n    if (firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ) {\n      firstToken.identifierRole = null;\n    }\n  }\n}\n\n// Parses any type of JSX attribute value.\nfunction jsxParseAttributeValue() {\n  switch (state.type) {\n    case tt.braceL:\n      next();\n      parseExpression();\n      nextJSXTagToken();\n      return;\n    case tt.jsxTagStart:\n      jsxParseElement();\n      nextJSXTagToken();\n      return;\n    case tt.string:\n      nextJSXTagToken();\n      return;\n    default:\n      unexpected(\"JSX value should be either an expression or a quoted JSX text\");\n  }\n}\n\n// Parse JSX spread child, after already processing the {\n// Does not parse the closing }\nfunction jsxParseSpreadChild() {\n  expect(tt.ellipsis);\n  parseExpression();\n}\n\n// Parses JSX opening tag starting after \"<\".\n// Returns true if the tag was self-closing.\n// Does not parse the last token.\nfunction jsxParseOpeningElement(initialTokenIndex) {\n  if (match(tt.jsxTagEnd)) {\n    // This is an open-fragment.\n    return false;\n  }\n  jsxParseElementName();\n  if (isTypeScriptEnabled) {\n    tsTryParseJSXTypeArgument();\n  }\n  let hasSeenPropSpread = false;\n  while (!match(tt.slash) && !match(tt.jsxTagEnd) && !state.error) {\n    if (eat(tt.braceL)) {\n      hasSeenPropSpread = true;\n      expect(tt.ellipsis);\n      parseMaybeAssign();\n      // }\n      nextJSXTagToken();\n      continue;\n    }\n    if (hasSeenPropSpread && state.end - state.start === 3 && input.charCodeAt(state.start) === charCodes.lowercaseK && input.charCodeAt(state.start + 1) === charCodes.lowercaseE && input.charCodeAt(state.start + 2) === charCodes.lowercaseY) {\n      state.tokens[initialTokenIndex].jsxRole = JSXRole.KeyAfterPropSpread;\n    }\n    jsxParseNamespacedName(IdentifierRole.ObjectKey);\n    if (match(tt.eq)) {\n      nextJSXTagToken();\n      jsxParseAttributeValue();\n    }\n  }\n  const isSelfClosing = match(tt.slash);\n  if (isSelfClosing) {\n    // /\n    nextJSXTagToken();\n  }\n  return isSelfClosing;\n}\n\n// Parses JSX closing tag starting after \"</\".\n// Does not parse the last token.\nfunction jsxParseClosingElement() {\n  if (match(tt.jsxTagEnd)) {\n    // Fragment syntax, so we immediately have a tag end.\n    return;\n  }\n  jsxParseElementName();\n}\n\n// Parses entire JSX element, including its opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n// Does not parse the last token.\nfunction jsxParseElementAt() {\n  const initialTokenIndex = state.tokens.length - 1;\n  state.tokens[initialTokenIndex].jsxRole = JSXRole.NoChildren;\n  let numExplicitChildren = 0;\n  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);\n  if (!isSelfClosing) {\n    nextJSXExprToken();\n    while (true) {\n      switch (state.type) {\n        case tt.jsxTagStart:\n          nextJSXTagToken();\n          if (match(tt.slash)) {\n            nextJSXTagToken();\n            jsxParseClosingElement();\n            // Key after prop spread takes precedence over number of children,\n            // since it means we switch to createElement, which doesn't care\n            // about number of children.\n            if (state.tokens[initialTokenIndex].jsxRole !== JSXRole.KeyAfterPropSpread) {\n              if (numExplicitChildren === 1) {\n                state.tokens[initialTokenIndex].jsxRole = JSXRole.OneChild;\n              } else if (numExplicitChildren > 1) {\n                state.tokens[initialTokenIndex].jsxRole = JSXRole.StaticChildren;\n              }\n            }\n            return;\n          }\n          numExplicitChildren++;\n          jsxParseElementAt();\n          nextJSXExprToken();\n          break;\n        case tt.jsxText:\n          numExplicitChildren++;\n          nextJSXExprToken();\n          break;\n        case tt.jsxEmptyText:\n          nextJSXExprToken();\n          break;\n        case tt.braceL:\n          next();\n          if (match(tt.ellipsis)) {\n            jsxParseSpreadChild();\n            nextJSXExprToken();\n            // Spread children are a mechanism to explicitly mark children as\n            // static, so count it as 2 children to satisfy the \"more than one\n            // child\" condition.\n            numExplicitChildren += 2;\n          } else {\n            // If we see {}, this is an empty pseudo-expression that doesn't\n            // count as a child.\n            if (!match(tt.braceR)) {\n              numExplicitChildren++;\n              parseExpression();\n            }\n            nextJSXExprToken();\n          }\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          unexpected();\n          return;\n      }\n    }\n  }\n}\n\n// Parses entire JSX element from current position.\n// Does not parse the last token.\nexport function jsxParseElement() {\n  nextJSXTagToken();\n  jsxParseElementAt();\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function nextJSXTagToken() {\n  state.tokens.push(new Token());\n  skipSpace();\n  state.start = state.pos;\n  const code = input.charCodeAt(state.pos);\n  if (IS_IDENTIFIER_START[code]) {\n    jsxReadWord();\n  } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {\n    jsxReadString(code);\n  } else {\n    // The following tokens are just one character each.\n    ++state.pos;\n    switch (code) {\n      case charCodes.greaterThan:\n        finishToken(tt.jsxTagEnd);\n        break;\n      case charCodes.lessThan:\n        finishToken(tt.jsxTagStart);\n        break;\n      case charCodes.slash:\n        finishToken(tt.slash);\n        break;\n      case charCodes.equalsTo:\n        finishToken(tt.eq);\n        break;\n      case charCodes.leftCurlyBrace:\n        finishToken(tt.braceL);\n        break;\n      case charCodes.dot:\n        finishToken(tt.dot);\n        break;\n      case charCodes.colon:\n        finishToken(tt.colon);\n        break;\n      default:\n        unexpected();\n    }\n  }\n}\nfunction nextJSXExprToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  jsxReadToken();\n}","map":{"version":3,"names":["eat","finishToken","getTokenFromCode","IdentifierRole","JSXRole","match","next","skipSpace","Token","TokenType","tt","input","isTypeScriptEnabled","state","parseExpression","parseMaybeAssign","expect","unexpected","charCodes","IS_IDENTIFIER_CHAR","IS_IDENTIFIER_START","tsTryParseJSXTypeArgument","jsxReadToken","sawNewline","sawNonWhitespace","pos","length","ch","charCodeAt","lessThan","leftCurlyBrace","start","jsxTagStart","jsxEmptyText","jsxText","lineFeed","space","carriageReturn","tab","jsxReadString","quote","string","jsxReadWord","dash","jsxName","jsxParseIdentifier","nextJSXTagToken","jsxParseNamespacedName","identifierRole","colon","tokens","jsxParseElementName","firstTokenIndex","Access","hadDot","dot","firstToken","firstChar","lowercaseA","lowercaseZ","jsxParseAttributeValue","type","braceL","jsxParseElement","jsxParseSpreadChild","ellipsis","jsxParseOpeningElement","initialTokenIndex","jsxTagEnd","hasSeenPropSpread","slash","error","end","lowercaseK","lowercaseE","lowercaseY","jsxRole","KeyAfterPropSpread","ObjectKey","eq","isSelfClosing","jsxParseClosingElement","jsxParseElementAt","NoChildren","numExplicitChildren","nextJSXExprToken","OneChild","StaticChildren","braceR","push","code","quotationMark","apostrophe","greaterThan","equalsTo"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/plugins/jsx/index.js"],"sourcesContent":["import {\n  eat,\n  finishToken,\n  getTokenFromCode,\n  IdentifierRole,\n  JSXRole,\n  match,\n  next,\n  skipSpace,\n  Token,\n} from \"../../tokenizer/index\";\nimport {TokenType as tt} from \"../../tokenizer/types\";\nimport {input, isTypeScriptEnabled, state} from \"../../traverser/base\";\nimport {parseExpression, parseMaybeAssign} from \"../../traverser/expression\";\nimport {expect, unexpected} from \"../../traverser/util\";\nimport {charCodes} from \"../../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../../util/identifier\";\nimport {tsTryParseJSXTypeArgument} from \"../typescript\";\n\n/**\n * Read token with JSX contents.\n *\n * In addition to detecting jsxTagStart and also regular tokens that might be\n * part of an expression, this code detects the start and end of text ranges\n * within JSX children. In order to properly count the number of children, we\n * distinguish jsxText from jsxEmptyText, which is a text range that simplifies\n * to the empty string after JSX whitespace trimming.\n *\n * It turns out that a JSX text range will simplify to the empty string if and\n * only if both of these conditions hold:\n * - The range consists entirely of whitespace characters (only counting space,\n *   tab, \\r, and \\n).\n * - The range has at least one newline.\n * This can be proven by analyzing any implementation of whitespace trimming,\n * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.\n */\nfunction jsxReadToken() {\n  let sawNewline = false;\n  let sawNonWhitespace = false;\n  while (true) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated JSX contents\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.lessThan || ch === charCodes.leftCurlyBrace) {\n      if (state.pos === state.start) {\n        if (ch === charCodes.lessThan) {\n          state.pos++;\n          finishToken(tt.jsxTagStart);\n          return;\n        }\n        getTokenFromCode(ch);\n        return;\n      }\n      if (sawNewline && !sawNonWhitespace) {\n        finishToken(tt.jsxEmptyText);\n      } else {\n        finishToken(tt.jsxText);\n      }\n      return;\n    }\n\n    // This is part of JSX text.\n    if (ch === charCodes.lineFeed) {\n      sawNewline = true;\n    } else if (ch !== charCodes.space && ch !== charCodes.carriageReturn && ch !== charCodes.tab) {\n      sawNonWhitespace = true;\n    }\n    state.pos++;\n  }\n}\n\nfunction jsxReadString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n    if (ch === quote) {\n      state.pos++;\n      break;\n    }\n    state.pos++;\n  }\n  finishToken(tt.string);\n}\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can't contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\nfunction jsxReadWord() {\n  let ch;\n  do {\n    if (state.pos > input.length) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n      return;\n    }\n    ch = input.charCodeAt(++state.pos);\n  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);\n  finishToken(tt.jsxName);\n}\n\n// Parse next token as JSX identifier\nfunction jsxParseIdentifier() {\n  nextJSXTagToken();\n}\n\n// Parse namespaced identifier.\nfunction jsxParseNamespacedName(identifierRole) {\n  jsxParseIdentifier();\n  if (!eat(tt.colon)) {\n    // Plain identifier, so this is an access.\n    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n    return;\n  }\n  // Process the second half of the namespaced name.\n  jsxParseIdentifier();\n}\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\nfunction jsxParseElementName() {\n  const firstTokenIndex = state.tokens.length;\n  jsxParseNamespacedName(IdentifierRole.Access);\n  let hadDot = false;\n  while (match(tt.dot)) {\n    hadDot = true;\n    nextJSXTagToken();\n    jsxParseIdentifier();\n  }\n  // For tags like <div> with a lowercase letter and no dots, the name is\n  // actually *not* an identifier access, since it's referring to a built-in\n  // tag name. Remove the identifier role in this case so that it's not\n  // accidentally transformed by the imports transform when preserving JSX.\n  if (!hadDot) {\n    const firstToken = state.tokens[firstTokenIndex];\n    const firstChar = input.charCodeAt(firstToken.start);\n    if (firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ) {\n      firstToken.identifierRole = null;\n    }\n  }\n}\n\n// Parses any type of JSX attribute value.\nfunction jsxParseAttributeValue() {\n  switch (state.type) {\n    case tt.braceL:\n      next();\n      parseExpression();\n      nextJSXTagToken();\n      return;\n\n    case tt.jsxTagStart:\n      jsxParseElement();\n      nextJSXTagToken();\n      return;\n\n    case tt.string:\n      nextJSXTagToken();\n      return;\n\n    default:\n      unexpected(\"JSX value should be either an expression or a quoted JSX text\");\n  }\n}\n\n// Parse JSX spread child, after already processing the {\n// Does not parse the closing }\nfunction jsxParseSpreadChild() {\n  expect(tt.ellipsis);\n  parseExpression();\n}\n\n// Parses JSX opening tag starting after \"<\".\n// Returns true if the tag was self-closing.\n// Does not parse the last token.\nfunction jsxParseOpeningElement(initialTokenIndex) {\n  if (match(tt.jsxTagEnd)) {\n    // This is an open-fragment.\n    return false;\n  }\n  jsxParseElementName();\n  if (isTypeScriptEnabled) {\n    tsTryParseJSXTypeArgument();\n  }\n  let hasSeenPropSpread = false;\n  while (!match(tt.slash) && !match(tt.jsxTagEnd) && !state.error) {\n    if (eat(tt.braceL)) {\n      hasSeenPropSpread = true;\n      expect(tt.ellipsis);\n      parseMaybeAssign();\n      // }\n      nextJSXTagToken();\n      continue;\n    }\n    if (\n      hasSeenPropSpread &&\n      state.end - state.start === 3 &&\n      input.charCodeAt(state.start) === charCodes.lowercaseK &&\n      input.charCodeAt(state.start + 1) === charCodes.lowercaseE &&\n      input.charCodeAt(state.start + 2) === charCodes.lowercaseY\n    ) {\n      state.tokens[initialTokenIndex].jsxRole = JSXRole.KeyAfterPropSpread;\n    }\n    jsxParseNamespacedName(IdentifierRole.ObjectKey);\n    if (match(tt.eq)) {\n      nextJSXTagToken();\n      jsxParseAttributeValue();\n    }\n  }\n  const isSelfClosing = match(tt.slash);\n  if (isSelfClosing) {\n    // /\n    nextJSXTagToken();\n  }\n  return isSelfClosing;\n}\n\n// Parses JSX closing tag starting after \"</\".\n// Does not parse the last token.\nfunction jsxParseClosingElement() {\n  if (match(tt.jsxTagEnd)) {\n    // Fragment syntax, so we immediately have a tag end.\n    return;\n  }\n  jsxParseElementName();\n}\n\n// Parses entire JSX element, including its opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n// Does not parse the last token.\nfunction jsxParseElementAt() {\n  const initialTokenIndex = state.tokens.length - 1;\n  state.tokens[initialTokenIndex].jsxRole = JSXRole.NoChildren;\n  let numExplicitChildren = 0;\n  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);\n  if (!isSelfClosing) {\n    nextJSXExprToken();\n    while (true) {\n      switch (state.type) {\n        case tt.jsxTagStart:\n          nextJSXTagToken();\n          if (match(tt.slash)) {\n            nextJSXTagToken();\n            jsxParseClosingElement();\n            // Key after prop spread takes precedence over number of children,\n            // since it means we switch to createElement, which doesn't care\n            // about number of children.\n            if (state.tokens[initialTokenIndex].jsxRole !== JSXRole.KeyAfterPropSpread) {\n              if (numExplicitChildren === 1) {\n                state.tokens[initialTokenIndex].jsxRole = JSXRole.OneChild;\n              } else if (numExplicitChildren > 1) {\n                state.tokens[initialTokenIndex].jsxRole = JSXRole.StaticChildren;\n              }\n            }\n            return;\n          }\n          numExplicitChildren++;\n          jsxParseElementAt();\n          nextJSXExprToken();\n          break;\n\n        case tt.jsxText:\n          numExplicitChildren++;\n          nextJSXExprToken();\n          break;\n\n        case tt.jsxEmptyText:\n          nextJSXExprToken();\n          break;\n\n        case tt.braceL:\n          next();\n          if (match(tt.ellipsis)) {\n            jsxParseSpreadChild();\n            nextJSXExprToken();\n            // Spread children are a mechanism to explicitly mark children as\n            // static, so count it as 2 children to satisfy the \"more than one\n            // child\" condition.\n            numExplicitChildren += 2;\n          } else {\n            // If we see {}, this is an empty pseudo-expression that doesn't\n            // count as a child.\n            if (!match(tt.braceR)) {\n              numExplicitChildren++;\n              parseExpression();\n            }\n            nextJSXExprToken();\n          }\n\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          unexpected();\n          return;\n      }\n    }\n  }\n}\n\n// Parses entire JSX element from current position.\n// Does not parse the last token.\nexport function jsxParseElement() {\n  nextJSXTagToken();\n  jsxParseElementAt();\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function nextJSXTagToken() {\n  state.tokens.push(new Token());\n  skipSpace();\n  state.start = state.pos;\n  const code = input.charCodeAt(state.pos);\n\n  if (IS_IDENTIFIER_START[code]) {\n    jsxReadWord();\n  } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {\n    jsxReadString(code);\n  } else {\n    // The following tokens are just one character each.\n    ++state.pos;\n    switch (code) {\n      case charCodes.greaterThan:\n        finishToken(tt.jsxTagEnd);\n        break;\n      case charCodes.lessThan:\n        finishToken(tt.jsxTagStart);\n        break;\n      case charCodes.slash:\n        finishToken(tt.slash);\n        break;\n      case charCodes.equalsTo:\n        finishToken(tt.eq);\n        break;\n      case charCodes.leftCurlyBrace:\n        finishToken(tt.braceL);\n        break;\n      case charCodes.dot:\n        finishToken(tt.dot);\n        break;\n      case charCodes.colon:\n        finishToken(tt.colon);\n        break;\n      default:\n        unexpected();\n    }\n  }\n}\n\nfunction nextJSXExprToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  jsxReadToken();\n}\n"],"mappings":"AAAA,SACEA,GAAG,EACHC,WAAW,EACXC,gBAAgB,EAChBC,cAAc,EACdC,OAAO,EACPC,KAAK,EACLC,IAAI,EACJC,SAAS,EACTC,KAAK,QACA,uBAAuB;AAC9B,SAAQC,SAAS,IAAIC,EAAE,QAAO,uBAAuB;AACrD,SAAQC,KAAK,EAAEC,mBAAmB,EAAEC,KAAK,QAAO,sBAAsB;AACtE,SAAQC,eAAe,EAAEC,gBAAgB,QAAO,4BAA4B;AAC5E,SAAQC,MAAM,EAAEC,UAAU,QAAO,sBAAsB;AACvD,SAAQC,SAAS,QAAO,sBAAsB;AAC9C,SAAQC,kBAAkB,EAAEC,mBAAmB,QAAO,uBAAuB;AAC7E,SAAQC,yBAAyB,QAAO,eAAe;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAAA,EAAG;EACtB,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,gBAAgB,GAAG,KAAK;EAC5B,OAAO,IAAI,EAAE;IACX,IAAIX,KAAK,CAACY,GAAG,IAAId,KAAK,CAACe,MAAM,EAAE;MAC7BT,UAAU,CAAC,2BAA2B,CAAC;MACvC;IACF;IAEA,MAAMU,EAAE,GAAGhB,KAAK,CAACiB,UAAU,CAACf,KAAK,CAACY,GAAG,CAAC;IACtC,IAAIE,EAAE,KAAKT,SAAS,CAACW,QAAQ,IAAIF,EAAE,KAAKT,SAAS,CAACY,cAAc,EAAE;MAChE,IAAIjB,KAAK,CAACY,GAAG,KAAKZ,KAAK,CAACkB,KAAK,EAAE;QAC7B,IAAIJ,EAAE,KAAKT,SAAS,CAACW,QAAQ,EAAE;UAC7BhB,KAAK,CAACY,GAAG,EAAE;UACXxB,WAAW,CAACS,EAAE,CAACsB,WAAW,CAAC;UAC3B;QACF;QACA9B,gBAAgB,CAACyB,EAAE,CAAC;QACpB;MACF;MACA,IAAIJ,UAAU,IAAI,CAACC,gBAAgB,EAAE;QACnCvB,WAAW,CAACS,EAAE,CAACuB,YAAY,CAAC;MAC9B,CAAC,MAAM;QACLhC,WAAW,CAACS,EAAE,CAACwB,OAAO,CAAC;MACzB;MACA;IACF;;IAEA;IACA,IAAIP,EAAE,KAAKT,SAAS,CAACiB,QAAQ,EAAE;MAC7BZ,UAAU,GAAG,IAAI;IACnB,CAAC,MAAM,IAAII,EAAE,KAAKT,SAAS,CAACkB,KAAK,IAAIT,EAAE,KAAKT,SAAS,CAACmB,cAAc,IAAIV,EAAE,KAAKT,SAAS,CAACoB,GAAG,EAAE;MAC5Fd,gBAAgB,GAAG,IAAI;IACzB;IACAX,KAAK,CAACY,GAAG,EAAE;EACb;AACF;AAEA,SAASc,aAAaA,CAACC,KAAK,EAAE;EAC5B3B,KAAK,CAACY,GAAG,EAAE;EACX,SAAS;IACP,IAAIZ,KAAK,CAACY,GAAG,IAAId,KAAK,CAACe,MAAM,EAAE;MAC7BT,UAAU,CAAC,8BAA8B,CAAC;MAC1C;IACF;IAEA,MAAMU,EAAE,GAAGhB,KAAK,CAACiB,UAAU,CAACf,KAAK,CAACY,GAAG,CAAC;IACtC,IAAIE,EAAE,KAAKa,KAAK,EAAE;MAChB3B,KAAK,CAACY,GAAG,EAAE;MACX;IACF;IACAZ,KAAK,CAACY,GAAG,EAAE;EACb;EACAxB,WAAW,CAACS,EAAE,CAAC+B,MAAM,CAAC;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,WAAWA,CAAA,EAAG;EACrB,IAAIf,EAAE;EACN,GAAG;IACD,IAAId,KAAK,CAACY,GAAG,GAAGd,KAAK,CAACe,MAAM,EAAE;MAC5BT,UAAU,CAAC,wCAAwC,CAAC;MACpD;IACF;IACAU,EAAE,GAAGhB,KAAK,CAACiB,UAAU,CAAC,EAAEf,KAAK,CAACY,GAAG,CAAC;EACpC,CAAC,QAAQN,kBAAkB,CAACQ,EAAE,CAAC,IAAIA,EAAE,KAAKT,SAAS,CAACyB,IAAI;EACxD1C,WAAW,CAACS,EAAE,CAACkC,OAAO,CAAC;AACzB;;AAEA;AACA,SAASC,kBAAkBA,CAAA,EAAG;EAC5BC,eAAe,CAAC,CAAC;AACnB;;AAEA;AACA,SAASC,sBAAsBA,CAACC,cAAc,EAAE;EAC9CH,kBAAkB,CAAC,CAAC;EACpB,IAAI,CAAC7C,GAAG,CAACU,EAAE,CAACuC,KAAK,CAAC,EAAE;IAClB;IACApC,KAAK,CAACqC,MAAM,CAACrC,KAAK,CAACqC,MAAM,CAACxB,MAAM,GAAG,CAAC,CAAC,CAACsB,cAAc,GAAGA,cAAc;IACrE;EACF;EACA;EACAH,kBAAkB,CAAC,CAAC;AACtB;;AAEA;AACA;AACA,SAASM,mBAAmBA,CAAA,EAAG;EAC7B,MAAMC,eAAe,GAAGvC,KAAK,CAACqC,MAAM,CAACxB,MAAM;EAC3CqB,sBAAsB,CAAC5C,cAAc,CAACkD,MAAM,CAAC;EAC7C,IAAIC,MAAM,GAAG,KAAK;EAClB,OAAOjD,KAAK,CAACK,EAAE,CAAC6C,GAAG,CAAC,EAAE;IACpBD,MAAM,GAAG,IAAI;IACbR,eAAe,CAAC,CAAC;IACjBD,kBAAkB,CAAC,CAAC;EACtB;EACA;EACA;EACA;EACA;EACA,IAAI,CAACS,MAAM,EAAE;IACX,MAAME,UAAU,GAAG3C,KAAK,CAACqC,MAAM,CAACE,eAAe,CAAC;IAChD,MAAMK,SAAS,GAAG9C,KAAK,CAACiB,UAAU,CAAC4B,UAAU,CAACzB,KAAK,CAAC;IACpD,IAAI0B,SAAS,IAAIvC,SAAS,CAACwC,UAAU,IAAID,SAAS,IAAIvC,SAAS,CAACyC,UAAU,EAAE;MAC1EH,UAAU,CAACR,cAAc,GAAG,IAAI;IAClC;EACF;AACF;;AAEA;AACA,SAASY,sBAAsBA,CAAA,EAAG;EAChC,QAAQ/C,KAAK,CAACgD,IAAI;IAChB,KAAKnD,EAAE,CAACoD,MAAM;MACZxD,IAAI,CAAC,CAAC;MACNQ,eAAe,CAAC,CAAC;MACjBgC,eAAe,CAAC,CAAC;MACjB;IAEF,KAAKpC,EAAE,CAACsB,WAAW;MACjB+B,eAAe,CAAC,CAAC;MACjBjB,eAAe,CAAC,CAAC;MACjB;IAEF,KAAKpC,EAAE,CAAC+B,MAAM;MACZK,eAAe,CAAC,CAAC;MACjB;IAEF;MACE7B,UAAU,CAAC,+DAA+D,CAAC;EAC/E;AACF;;AAEA;AACA;AACA,SAAS+C,mBAAmBA,CAAA,EAAG;EAC7BhD,MAAM,CAACN,EAAE,CAACuD,QAAQ,CAAC;EACnBnD,eAAe,CAAC,CAAC;AACnB;;AAEA;AACA;AACA;AACA,SAASoD,sBAAsBA,CAACC,iBAAiB,EAAE;EACjD,IAAI9D,KAAK,CAACK,EAAE,CAAC0D,SAAS,CAAC,EAAE;IACvB;IACA,OAAO,KAAK;EACd;EACAjB,mBAAmB,CAAC,CAAC;EACrB,IAAIvC,mBAAmB,EAAE;IACvBS,yBAAyB,CAAC,CAAC;EAC7B;EACA,IAAIgD,iBAAiB,GAAG,KAAK;EAC7B,OAAO,CAAChE,KAAK,CAACK,EAAE,CAAC4D,KAAK,CAAC,IAAI,CAACjE,KAAK,CAACK,EAAE,CAAC0D,SAAS,CAAC,IAAI,CAACvD,KAAK,CAAC0D,KAAK,EAAE;IAC/D,IAAIvE,GAAG,CAACU,EAAE,CAACoD,MAAM,CAAC,EAAE;MAClBO,iBAAiB,GAAG,IAAI;MACxBrD,MAAM,CAACN,EAAE,CAACuD,QAAQ,CAAC;MACnBlD,gBAAgB,CAAC,CAAC;MAClB;MACA+B,eAAe,CAAC,CAAC;MACjB;IACF;IACA,IACEuB,iBAAiB,IACjBxD,KAAK,CAAC2D,GAAG,GAAG3D,KAAK,CAACkB,KAAK,KAAK,CAAC,IAC7BpB,KAAK,CAACiB,UAAU,CAACf,KAAK,CAACkB,KAAK,CAAC,KAAKb,SAAS,CAACuD,UAAU,IACtD9D,KAAK,CAACiB,UAAU,CAACf,KAAK,CAACkB,KAAK,GAAG,CAAC,CAAC,KAAKb,SAAS,CAACwD,UAAU,IAC1D/D,KAAK,CAACiB,UAAU,CAACf,KAAK,CAACkB,KAAK,GAAG,CAAC,CAAC,KAAKb,SAAS,CAACyD,UAAU,EAC1D;MACA9D,KAAK,CAACqC,MAAM,CAACiB,iBAAiB,CAAC,CAACS,OAAO,GAAGxE,OAAO,CAACyE,kBAAkB;IACtE;IACA9B,sBAAsB,CAAC5C,cAAc,CAAC2E,SAAS,CAAC;IAChD,IAAIzE,KAAK,CAACK,EAAE,CAACqE,EAAE,CAAC,EAAE;MAChBjC,eAAe,CAAC,CAAC;MACjBc,sBAAsB,CAAC,CAAC;IAC1B;EACF;EACA,MAAMoB,aAAa,GAAG3E,KAAK,CAACK,EAAE,CAAC4D,KAAK,CAAC;EACrC,IAAIU,aAAa,EAAE;IACjB;IACAlC,eAAe,CAAC,CAAC;EACnB;EACA,OAAOkC,aAAa;AACtB;;AAEA;AACA;AACA,SAASC,sBAAsBA,CAAA,EAAG;EAChC,IAAI5E,KAAK,CAACK,EAAE,CAAC0D,SAAS,CAAC,EAAE;IACvB;IACA;EACF;EACAjB,mBAAmB,CAAC,CAAC;AACvB;;AAEA;AACA;AACA;AACA,SAAS+B,iBAAiBA,CAAA,EAAG;EAC3B,MAAMf,iBAAiB,GAAGtD,KAAK,CAACqC,MAAM,CAACxB,MAAM,GAAG,CAAC;EACjDb,KAAK,CAACqC,MAAM,CAACiB,iBAAiB,CAAC,CAACS,OAAO,GAAGxE,OAAO,CAAC+E,UAAU;EAC5D,IAAIC,mBAAmB,GAAG,CAAC;EAC3B,MAAMJ,aAAa,GAAGd,sBAAsB,CAACC,iBAAiB,CAAC;EAC/D,IAAI,CAACa,aAAa,EAAE;IAClBK,gBAAgB,CAAC,CAAC;IAClB,OAAO,IAAI,EAAE;MACX,QAAQxE,KAAK,CAACgD,IAAI;QAChB,KAAKnD,EAAE,CAACsB,WAAW;UACjBc,eAAe,CAAC,CAAC;UACjB,IAAIzC,KAAK,CAACK,EAAE,CAAC4D,KAAK,CAAC,EAAE;YACnBxB,eAAe,CAAC,CAAC;YACjBmC,sBAAsB,CAAC,CAAC;YACxB;YACA;YACA;YACA,IAAIpE,KAAK,CAACqC,MAAM,CAACiB,iBAAiB,CAAC,CAACS,OAAO,KAAKxE,OAAO,CAACyE,kBAAkB,EAAE;cAC1E,IAAIO,mBAAmB,KAAK,CAAC,EAAE;gBAC7BvE,KAAK,CAACqC,MAAM,CAACiB,iBAAiB,CAAC,CAACS,OAAO,GAAGxE,OAAO,CAACkF,QAAQ;cAC5D,CAAC,MAAM,IAAIF,mBAAmB,GAAG,CAAC,EAAE;gBAClCvE,KAAK,CAACqC,MAAM,CAACiB,iBAAiB,CAAC,CAACS,OAAO,GAAGxE,OAAO,CAACmF,cAAc;cAClE;YACF;YACA;UACF;UACAH,mBAAmB,EAAE;UACrBF,iBAAiB,CAAC,CAAC;UACnBG,gBAAgB,CAAC,CAAC;UAClB;QAEF,KAAK3E,EAAE,CAACwB,OAAO;UACbkD,mBAAmB,EAAE;UACrBC,gBAAgB,CAAC,CAAC;UAClB;QAEF,KAAK3E,EAAE,CAACuB,YAAY;UAClBoD,gBAAgB,CAAC,CAAC;UAClB;QAEF,KAAK3E,EAAE,CAACoD,MAAM;UACZxD,IAAI,CAAC,CAAC;UACN,IAAID,KAAK,CAACK,EAAE,CAACuD,QAAQ,CAAC,EAAE;YACtBD,mBAAmB,CAAC,CAAC;YACrBqB,gBAAgB,CAAC,CAAC;YAClB;YACA;YACA;YACAD,mBAAmB,IAAI,CAAC;UAC1B,CAAC,MAAM;YACL;YACA;YACA,IAAI,CAAC/E,KAAK,CAACK,EAAE,CAAC8E,MAAM,CAAC,EAAE;cACrBJ,mBAAmB,EAAE;cACrBtE,eAAe,CAAC,CAAC;YACnB;YACAuE,gBAAgB,CAAC,CAAC;UACpB;UAEA;;QAEF;QACA;UACEpE,UAAU,CAAC,CAAC;UACZ;MACJ;IACF;EACF;AACF;;AAEA;AACA;AACA,OAAO,SAAS8C,eAAeA,CAAA,EAAG;EAChCjB,eAAe,CAAC,CAAC;EACjBoC,iBAAiB,CAAC,CAAC;AACrB;;AAEA;AACA;AACA;;AAEA,OAAO,SAASpC,eAAeA,CAAA,EAAG;EAChCjC,KAAK,CAACqC,MAAM,CAACuC,IAAI,CAAC,IAAIjF,KAAK,CAAC,CAAC,CAAC;EAC9BD,SAAS,CAAC,CAAC;EACXM,KAAK,CAACkB,KAAK,GAAGlB,KAAK,CAACY,GAAG;EACvB,MAAMiE,IAAI,GAAG/E,KAAK,CAACiB,UAAU,CAACf,KAAK,CAACY,GAAG,CAAC;EAExC,IAAIL,mBAAmB,CAACsE,IAAI,CAAC,EAAE;IAC7BhD,WAAW,CAAC,CAAC;EACf,CAAC,MAAM,IAAIgD,IAAI,KAAKxE,SAAS,CAACyE,aAAa,IAAID,IAAI,KAAKxE,SAAS,CAAC0E,UAAU,EAAE;IAC5ErD,aAAa,CAACmD,IAAI,CAAC;EACrB,CAAC,MAAM;IACL;IACA,EAAE7E,KAAK,CAACY,GAAG;IACX,QAAQiE,IAAI;MACV,KAAKxE,SAAS,CAAC2E,WAAW;QACxB5F,WAAW,CAACS,EAAE,CAAC0D,SAAS,CAAC;QACzB;MACF,KAAKlD,SAAS,CAACW,QAAQ;QACrB5B,WAAW,CAACS,EAAE,CAACsB,WAAW,CAAC;QAC3B;MACF,KAAKd,SAAS,CAACoD,KAAK;QAClBrE,WAAW,CAACS,EAAE,CAAC4D,KAAK,CAAC;QACrB;MACF,KAAKpD,SAAS,CAAC4E,QAAQ;QACrB7F,WAAW,CAACS,EAAE,CAACqE,EAAE,CAAC;QAClB;MACF,KAAK7D,SAAS,CAACY,cAAc;QAC3B7B,WAAW,CAACS,EAAE,CAACoD,MAAM,CAAC;QACtB;MACF,KAAK5C,SAAS,CAACqC,GAAG;QAChBtD,WAAW,CAACS,EAAE,CAAC6C,GAAG,CAAC;QACnB;MACF,KAAKrC,SAAS,CAAC+B,KAAK;QAClBhD,WAAW,CAACS,EAAE,CAACuC,KAAK,CAAC;QACrB;MACF;QACEhC,UAAU,CAAC,CAAC;IAChB;EACF;AACF;AAEA,SAASoE,gBAAgBA,CAAA,EAAG;EAC1BxE,KAAK,CAACqC,MAAM,CAACuC,IAAI,CAAC,IAAIjF,KAAK,CAAC,CAAC,CAAC;EAC9BK,KAAK,CAACkB,KAAK,GAAGlB,KAAK,CAACY,GAAG;EACvBH,YAAY,CAAC,CAAC;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}