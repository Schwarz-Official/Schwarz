{"ast":null,"code":"import { TokenType as tt } from \"../parser/tokenizer/types\";\nimport isIdentifier from \"../util/isIdentifier\";\nimport Transformer from \"./Transformer\";\nexport default class TypeScriptTransformer extends Transformer {\n  constructor(rootTransformer, tokens, isImportsTransformEnabled) {\n    super();\n    this.rootTransformer = rootTransformer;\n    this.tokens = tokens;\n    this.isImportsTransformEnabled = isImportsTransformEnabled;\n    ;\n  }\n  process() {\n    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {\n      return true;\n    }\n    if (this.tokens.matches1(tt._public) || this.tokens.matches1(tt._protected) || this.tokens.matches1(tt._private) || this.tokens.matches1(tt._abstract) || this.tokens.matches1(tt._readonly) || this.tokens.matches1(tt._override) || this.tokens.matches1(tt.nonNullAssertion)) {\n      this.tokens.removeInitialToken();\n      return true;\n    }\n    if (this.tokens.matches1(tt._enum) || this.tokens.matches2(tt._const, tt._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt._enum) || this.tokens.matches3(tt._export, tt._const, tt._enum)) {\n      this.processEnum(true);\n      return true;\n    }\n    return false;\n  }\n  processEnum(isExport = false) {\n    // We might have \"export const enum\", so just remove all relevant tokens.\n    this.tokens.removeInitialToken();\n    while (this.tokens.matches1(tt._const) || this.tokens.matches1(tt._enum)) {\n      this.tokens.removeToken();\n    }\n    const enumName = this.tokens.identifierName();\n    this.tokens.removeToken();\n    if (isExport && !this.isImportsTransformEnabled) {\n      this.tokens.appendCode(\"export \");\n    }\n    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.processEnumBody(enumName);\n    this.tokens.copyExpectedToken(tt.braceR);\n    if (isExport && this.isImportsTransformEnabled) {\n      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);\n    } else {\n      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);\n    }\n  }\n\n  /**\n   * Transform an enum into equivalent JS. This has complexity in a few places:\n   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.\n   * - Enum keys are allowed to be referenced in later enum values.\n   * - Enum keys are allowed to be strings.\n   * - When enum values are omitted, they should follow an auto-increment behavior.\n   */\n  processEnumBody(enumName) {\n    // Code that can be used to reference the previous enum member, or null if this is the first\n    // enum member.\n    let previousValueCode = null;\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        break;\n      }\n      const {\n        nameStringCode,\n        variableName\n      } = this.extractEnumKeyInfo(this.tokens.currentToken());\n      this.tokens.removeInitialToken();\n      if (this.tokens.matches3(tt.eq, tt.string, tt.comma) || this.tokens.matches3(tt.eq, tt.string, tt.braceR)) {\n        this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);\n      } else if (this.tokens.matches1(tt.eq)) {\n        this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);\n      } else {\n        this.processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode);\n      }\n      if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      }\n      if (variableName != null) {\n        previousValueCode = variableName;\n      } else {\n        previousValueCode = `${enumName}[${nameStringCode}]`;\n      }\n    }\n  }\n\n  /**\n   * Detect name information about this enum key, which will be used to determine which code to emit\n   * and whether we should declare a variable as part of this declaration.\n   *\n   * Some cases to keep in mind:\n   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement\n   *   this by declaring a variable `X` so that later expressions can use it.\n   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,\n   *   e.g. `\"hello world\" = 3,`. Template literal syntax is NOT allowed.\n   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier\n   *   later, e.g. `\"X\" = 1, Y = X`. That means that we need to detect whether or not a string\n   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an\n   *   identifier.\n   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later\n   *   and would be a syntax error if we emitted a variable, so we need to skip the variable\n   *   declaration in those cases.\n   *\n   * The variableName return value captures these nuances: if non-null, we can and must emit a\n   * variable declaration, and if null, we can't and shouldn't.\n   */\n  extractEnumKeyInfo(nameToken) {\n    if (nameToken.type === tt.name) {\n      const name = this.tokens.identifierNameForToken(nameToken);\n      return {\n        nameStringCode: `\"${name}\"`,\n        variableName: isIdentifier(name) ? name : null\n      };\n    } else if (nameToken.type === tt.string) {\n      const name = this.tokens.stringValueForToken(nameToken);\n      return {\n        nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),\n        variableName: isIdentifier(name) ? name : null\n      };\n    } else {\n      throw new Error(\"Expected name or string at beginning of enum element.\");\n    }\n  }\n\n  /**\n   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and\n   * not a complex expression). This is the typical form for TS string enums, and in this case, we\n   * do *not* create a reverse mapping.\n   *\n   * This is called after deleting the key token, when the token processor is at the equals sign.\n   *\n   * Example 1:\n   * someKey = \"some value\"\n   * ->\n   * const someKey = \"some value\"; MyEnum[\"someKey\"] = someKey;\n   *\n   * Example 2:\n   * \"some key\" = \"some value\"\n   * ->\n   * MyEnum[\"some key\"] = \"some value\";\n   */\n  processStringLiteralEnumMember(enumName, nameStringCode, variableName) {\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName}`);\n      // =\n      this.tokens.copyToken();\n      // value string\n      this.tokens.copyToken();\n      this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);\n    } else {\n      this.tokens.appendCode(`${enumName}[${nameStringCode}]`);\n      // =\n      this.tokens.copyToken();\n      // value string\n      this.tokens.copyToken();\n      this.tokens.appendCode(\";\");\n    }\n  }\n\n  /**\n   * Handle an enum member initialized with an expression on the right-hand side (other than a\n   * string literal). In these cases, we should transform the expression and emit code that sets up\n   * a reverse mapping.\n   *\n   * The TypeScript implementation of this operation distinguishes between expressions that can be\n   * \"constant folded\" at compile time (i.e. consist of number literals and simple math operations\n   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved\n   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at\n   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the\n   * expression as-is, and will later emit something like `MyEnum[\"previousKey\"] + 1` to implement\n   * auto-incrementing.\n   *\n   * This is called after deleting the key token, when the token processor is at the equals sign.\n   *\n   * Example 1:\n   * someKey = 1 + 1\n   * ->\n   * const someKey = 1 + 1; MyEnum[MyEnum[\"someKey\"] = someKey] = \"someKey\";\n   *\n   * Example 2:\n   * \"some key\" = 1 + 1\n   * ->\n   * MyEnum[MyEnum[\"some key\"] = 1 + 1] = \"some key\";\n   */\n  processExplicitValueEnumMember(enumName, nameStringCode, variableName) {\n    const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;\n    if (rhsEndIndex == null) {\n      throw new Error(\"Expected rhsEndIndex on enum assign.\");\n    }\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName}`);\n      this.tokens.copyToken();\n      while (this.tokens.currentIndex() < rhsEndIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(`; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`);\n    } else {\n      this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);\n      this.tokens.copyToken();\n      while (this.tokens.currentIndex() < rhsEndIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(`] = ${nameStringCode};`);\n    }\n  }\n\n  /**\n   * Handle an enum member with no right-hand side expression. In this case, the value is the\n   * previous value plus 1, or 0 if there was no previous value. We should also always emit a\n   * reverse mapping.\n   *\n   * Example 1:\n   * someKey2\n   * ->\n   * const someKey2 = someKey1 + 1; MyEnum[MyEnum[\"someKey2\"] = someKey2] = \"someKey2\";\n   *\n   * Example 2:\n   * \"some key 2\"\n   * ->\n   * MyEnum[MyEnum[\"some key 2\"] = someKey1 + 1] = \"some key 2\";\n   */\n  processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode) {\n    let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : \"0\";\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);\n      valueCode = variableName;\n    }\n    this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`);\n  }\n}","map":{"version":3,"names":["TokenType","tt","isIdentifier","Transformer","TypeScriptTransformer","constructor","rootTransformer","tokens","isImportsTransformEnabled","process","processPossibleArrowParamEnd","processPossibleAsyncArrowWithTypeParams","processPossibleTypeRange","matches1","_public","_protected","_private","_abstract","_readonly","_override","nonNullAssertion","removeInitialToken","_enum","matches2","_const","processEnum","_export","matches3","isExport","removeToken","enumName","identifierName","appendCode","copyExpectedToken","braceL","processEnumBody","braceR","previousValueCode","nameStringCode","variableName","extractEnumKeyInfo","currentToken","eq","string","comma","processStringLiteralEnumMember","processExplicitValueEnumMember","processImplicitValueEnumMember","nameToken","type","name","identifierNameForToken","stringValueForToken","code","slice","start","end","Error","copyToken","rhsEndIndex","currentIndex","processToken","valueCode"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/TypeScriptTransformer.js"],"sourcesContent":["\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport isIdentifier from \"../util/isIdentifier\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class TypeScriptTransformer extends Transformer {\n  constructor(\n     rootTransformer,\n     tokens,\n     isImportsTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;\n  }\n\n  process() {\n    if (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    ) {\n      return true;\n    }\n    if (\n      this.tokens.matches1(tt._public) ||\n      this.tokens.matches1(tt._protected) ||\n      this.tokens.matches1(tt._private) ||\n      this.tokens.matches1(tt._abstract) ||\n      this.tokens.matches1(tt._readonly) ||\n      this.tokens.matches1(tt._override) ||\n      this.tokens.matches1(tt.nonNullAssertion)\n    ) {\n      this.tokens.removeInitialToken();\n      return true;\n    }\n    if (this.tokens.matches1(tt._enum) || this.tokens.matches2(tt._const, tt._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (\n      this.tokens.matches2(tt._export, tt._enum) ||\n      this.tokens.matches3(tt._export, tt._const, tt._enum)\n    ) {\n      this.processEnum(true);\n      return true;\n    }\n    return false;\n  }\n\n  processEnum(isExport = false) {\n    // We might have \"export const enum\", so just remove all relevant tokens.\n    this.tokens.removeInitialToken();\n    while (this.tokens.matches1(tt._const) || this.tokens.matches1(tt._enum)) {\n      this.tokens.removeToken();\n    }\n    const enumName = this.tokens.identifierName();\n    this.tokens.removeToken();\n    if (isExport && !this.isImportsTransformEnabled) {\n      this.tokens.appendCode(\"export \");\n    }\n    this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.processEnumBody(enumName);\n    this.tokens.copyExpectedToken(tt.braceR);\n    if (isExport && this.isImportsTransformEnabled) {\n      this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);\n    } else {\n      this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);\n    }\n  }\n\n  /**\n   * Transform an enum into equivalent JS. This has complexity in a few places:\n   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.\n   * - Enum keys are allowed to be referenced in later enum values.\n   * - Enum keys are allowed to be strings.\n   * - When enum values are omitted, they should follow an auto-increment behavior.\n   */\n  processEnumBody(enumName) {\n    // Code that can be used to reference the previous enum member, or null if this is the first\n    // enum member.\n    let previousValueCode = null;\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        break;\n      }\n      const {nameStringCode, variableName} = this.extractEnumKeyInfo(this.tokens.currentToken());\n      this.tokens.removeInitialToken();\n\n      if (\n        this.tokens.matches3(tt.eq, tt.string, tt.comma) ||\n        this.tokens.matches3(tt.eq, tt.string, tt.braceR)\n      ) {\n        this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);\n      } else if (this.tokens.matches1(tt.eq)) {\n        this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);\n      } else {\n        this.processImplicitValueEnumMember(\n          enumName,\n          nameStringCode,\n          variableName,\n          previousValueCode,\n        );\n      }\n      if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      }\n\n      if (variableName != null) {\n        previousValueCode = variableName;\n      } else {\n        previousValueCode = `${enumName}[${nameStringCode}]`;\n      }\n    }\n  }\n\n  /**\n   * Detect name information about this enum key, which will be used to determine which code to emit\n   * and whether we should declare a variable as part of this declaration.\n   *\n   * Some cases to keep in mind:\n   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement\n   *   this by declaring a variable `X` so that later expressions can use it.\n   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,\n   *   e.g. `\"hello world\" = 3,`. Template literal syntax is NOT allowed.\n   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier\n   *   later, e.g. `\"X\" = 1, Y = X`. That means that we need to detect whether or not a string\n   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an\n   *   identifier.\n   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later\n   *   and would be a syntax error if we emitted a variable, so we need to skip the variable\n   *   declaration in those cases.\n   *\n   * The variableName return value captures these nuances: if non-null, we can and must emit a\n   * variable declaration, and if null, we can't and shouldn't.\n   */\n  extractEnumKeyInfo(nameToken) {\n    if (nameToken.type === tt.name) {\n      const name = this.tokens.identifierNameForToken(nameToken);\n      return {\n        nameStringCode: `\"${name}\"`,\n        variableName: isIdentifier(name) ? name : null,\n      };\n    } else if (nameToken.type === tt.string) {\n      const name = this.tokens.stringValueForToken(nameToken);\n      return {\n        nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),\n        variableName: isIdentifier(name) ? name : null,\n      };\n    } else {\n      throw new Error(\"Expected name or string at beginning of enum element.\");\n    }\n  }\n\n  /**\n   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and\n   * not a complex expression). This is the typical form for TS string enums, and in this case, we\n   * do *not* create a reverse mapping.\n   *\n   * This is called after deleting the key token, when the token processor is at the equals sign.\n   *\n   * Example 1:\n   * someKey = \"some value\"\n   * ->\n   * const someKey = \"some value\"; MyEnum[\"someKey\"] = someKey;\n   *\n   * Example 2:\n   * \"some key\" = \"some value\"\n   * ->\n   * MyEnum[\"some key\"] = \"some value\";\n   */\n  processStringLiteralEnumMember(\n    enumName,\n    nameStringCode,\n    variableName,\n  ) {\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName}`);\n      // =\n      this.tokens.copyToken();\n      // value string\n      this.tokens.copyToken();\n      this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);\n    } else {\n      this.tokens.appendCode(`${enumName}[${nameStringCode}]`);\n      // =\n      this.tokens.copyToken();\n      // value string\n      this.tokens.copyToken();\n      this.tokens.appendCode(\";\");\n    }\n  }\n\n  /**\n   * Handle an enum member initialized with an expression on the right-hand side (other than a\n   * string literal). In these cases, we should transform the expression and emit code that sets up\n   * a reverse mapping.\n   *\n   * The TypeScript implementation of this operation distinguishes between expressions that can be\n   * \"constant folded\" at compile time (i.e. consist of number literals and simple math operations\n   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved\n   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at\n   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the\n   * expression as-is, and will later emit something like `MyEnum[\"previousKey\"] + 1` to implement\n   * auto-incrementing.\n   *\n   * This is called after deleting the key token, when the token processor is at the equals sign.\n   *\n   * Example 1:\n   * someKey = 1 + 1\n   * ->\n   * const someKey = 1 + 1; MyEnum[MyEnum[\"someKey\"] = someKey] = \"someKey\";\n   *\n   * Example 2:\n   * \"some key\" = 1 + 1\n   * ->\n   * MyEnum[MyEnum[\"some key\"] = 1 + 1] = \"some key\";\n   */\n  processExplicitValueEnumMember(\n    enumName,\n    nameStringCode,\n    variableName,\n  ) {\n    const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;\n    if (rhsEndIndex == null) {\n      throw new Error(\"Expected rhsEndIndex on enum assign.\");\n    }\n\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName}`);\n      this.tokens.copyToken();\n      while (this.tokens.currentIndex() < rhsEndIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\n        `; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`,\n      );\n    } else {\n      this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);\n      this.tokens.copyToken();\n      while (this.tokens.currentIndex() < rhsEndIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(`] = ${nameStringCode};`);\n    }\n  }\n\n  /**\n   * Handle an enum member with no right-hand side expression. In this case, the value is the\n   * previous value plus 1, or 0 if there was no previous value. We should also always emit a\n   * reverse mapping.\n   *\n   * Example 1:\n   * someKey2\n   * ->\n   * const someKey2 = someKey1 + 1; MyEnum[MyEnum[\"someKey2\"] = someKey2] = \"someKey2\";\n   *\n   * Example 2:\n   * \"some key 2\"\n   * ->\n   * MyEnum[MyEnum[\"some key 2\"] = someKey1 + 1] = \"some key 2\";\n   */\n  processImplicitValueEnumMember(\n    enumName,\n    nameStringCode,\n    variableName,\n    previousValueCode,\n  ) {\n    let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : \"0\";\n    if (variableName != null) {\n      this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);\n      valueCode = variableName;\n    }\n    this.tokens.appendCode(\n      `${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`,\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}