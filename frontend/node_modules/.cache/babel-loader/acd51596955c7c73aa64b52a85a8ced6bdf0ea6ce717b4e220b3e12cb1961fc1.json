{"ast":null,"code":"import { TokenType as tt } from \"../parser/tokenizer/types\";\nimport Transformer from \"./Transformer\";\n\n/**\n * Transformer supporting the optional chaining and nullish coalescing operators.\n *\n * Tech plan here:\n * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan\n *\n * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles\n * the operators themselves.\n */\nexport default class OptionalChainingNullishTransformer extends Transformer {\n  constructor(tokens, nameManager) {\n    super();\n    this.tokens = tokens;\n    this.nameManager = nameManager;\n    ;\n  }\n  process() {\n    if (this.tokens.matches1(tt.nullishCoalescing)) {\n      const token = this.tokens.currentToken();\n      if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", async () => (\");\n      } else {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", () => (\");\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._delete)) {\n      const nextToken = this.tokens.tokenAtRelativeIndex(1);\n      if (nextToken.isOptionalChainStart) {\n        this.tokens.removeInitialToken();\n        return true;\n      }\n    }\n    const token = this.tokens.currentToken();\n    const chainStart = token.subscriptStartIndex;\n    if (chainStart != null && this.tokens.tokens[chainStart].isOptionalChainStart &&\n    // Super subscripts can't be optional (since super is never null/undefined), and the syntax\n    // relies on the subscript being intact, so leave this token alone.\n    this.tokens.tokenAtRelativeIndex(-1).type !== tt._super) {\n      const param = this.nameManager.claimFreeName(\"_\");\n      let arrowStartSnippet;\n      if (chainStart > 0 && this.tokens.matches1AtIndex(chainStart - 1, tt._delete) && this.isLastSubscriptInChain()) {\n        // Delete operations are special: we already removed the delete keyword, and to still\n        // perform a delete, we need to insert a delete in the very last part of the chain, which\n        // in correct code will always be a property access.\n        arrowStartSnippet = `${param} => delete ${param}`;\n      } else {\n        arrowStartSnippet = `${param} => ${param}`;\n      }\n      if (this.tokens.tokens[chainStart].isAsyncOperation) {\n        arrowStartSnippet = `async ${arrowStartSnippet}`;\n      }\n      if (this.tokens.matches2(tt.questionDot, tt.parenL) || this.tokens.matches2(tt.questionDot, tt.lessThan)) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches2(tt.questionDot, tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches1(tt.questionDot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.dot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);\n      } else if (this.tokens.matches1(tt.parenL)) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);\n      } else {\n        throw new Error(\"Unexpected subscript operator in optional chain.\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determine if the current token is the last of its chain, so that we know whether it's eligible\n   * to have a delete op inserted.\n   *\n   * We can do this by walking forward until we determine one way or another. Each\n   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in\n   * a nesting way, so we can track depth and walk to the end of the chain (the point where the\n   * depth goes negative) and see if any other subscript token is after us in the chain.\n   */\n  isLastSubscriptInChain() {\n    let depth = 0;\n    for (let i = this.tokens.currentIndex() + 1;; i++) {\n      if (i >= this.tokens.tokens.length) {\n        throw new Error(\"Reached the end of the code while finding the end of the access chain.\");\n      }\n      if (this.tokens.tokens[i].isOptionalChainStart) {\n        depth++;\n      } else if (this.tokens.tokens[i].isOptionalChainEnd) {\n        depth--;\n      }\n      if (depth < 0) {\n        return true;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Determine if we are the open-paren in an expression like super.a()?.b.\n   *\n   * We can do this by walking backward to find the previous subscript. If that subscript was\n   * preceded by a super, then we must be the subscript after it, so if this is a call expression,\n   * we'll need to attach the right context.\n   */\n  justSkippedSuper() {\n    let depth = 0;\n    let index = this.tokens.currentIndex() - 1;\n    while (true) {\n      if (index < 0) {\n        throw new Error(\"Reached the start of the code while finding the start of the access chain.\");\n      }\n      if (this.tokens.tokens[index].isOptionalChainStart) {\n        depth--;\n      } else if (this.tokens.tokens[index].isOptionalChainEnd) {\n        depth++;\n      }\n      if (depth < 0) {\n        return false;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {\n        return this.tokens.tokens[index - 1].type === tt._super;\n      }\n      index--;\n    }\n  }\n}","map":{"version":3,"names":["TokenType","tt","Transformer","OptionalChainingNullishTransformer","constructor","tokens","nameManager","process","matches1","nullishCoalescing","token","currentToken","nullishStartIndex","isAsyncOperation","replaceTokenTrimmingLeftWhitespace","_delete","nextToken","tokenAtRelativeIndex","isOptionalChainStart","removeInitialToken","chainStart","subscriptStartIndex","type","_super","param","claimFreeName","arrowStartSnippet","matches1AtIndex","isLastSubscriptInChain","matches2","questionDot","parenL","lessThan","justSkippedSuper","appendCode","bracketL","dot","Error","depth","i","currentIndex","length","isOptionalChainEnd","index"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/OptionalChainingNullishTransformer.js"],"sourcesContent":["\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Transformer supporting the optional chaining and nullish coalescing operators.\n *\n * Tech plan here:\n * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan\n *\n * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles\n * the operators themselves.\n */\nexport default class OptionalChainingNullishTransformer extends Transformer {\n  constructor( tokens,  nameManager) {\n    super();this.tokens = tokens;this.nameManager = nameManager;;\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.nullishCoalescing)) {\n      const token = this.tokens.currentToken();\n      if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", async () => (\");\n      } else {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\", () => (\");\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._delete)) {\n      const nextToken = this.tokens.tokenAtRelativeIndex(1);\n      if (nextToken.isOptionalChainStart) {\n        this.tokens.removeInitialToken();\n        return true;\n      }\n    }\n    const token = this.tokens.currentToken();\n    const chainStart = token.subscriptStartIndex;\n    if (\n      chainStart != null &&\n      this.tokens.tokens[chainStart].isOptionalChainStart &&\n      // Super subscripts can't be optional (since super is never null/undefined), and the syntax\n      // relies on the subscript being intact, so leave this token alone.\n      this.tokens.tokenAtRelativeIndex(-1).type !== tt._super\n    ) {\n      const param = this.nameManager.claimFreeName(\"_\");\n      let arrowStartSnippet;\n      if (\n        chainStart > 0 &&\n        this.tokens.matches1AtIndex(chainStart - 1, tt._delete) &&\n        this.isLastSubscriptInChain()\n      ) {\n        // Delete operations are special: we already removed the delete keyword, and to still\n        // perform a delete, we need to insert a delete in the very last part of the chain, which\n        // in correct code will always be a property access.\n        arrowStartSnippet = `${param} => delete ${param}`;\n      } else {\n        arrowStartSnippet = `${param} => ${param}`;\n      }\n      if (this.tokens.tokens[chainStart].isAsyncOperation) {\n        arrowStartSnippet = `async ${arrowStartSnippet}`;\n      }\n      if (\n        this.tokens.matches2(tt.questionDot, tt.parenL) ||\n        this.tokens.matches2(tt.questionDot, tt.lessThan)\n      ) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches2(tt.questionDot, tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);\n      } else if (this.tokens.matches1(tt.questionDot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.dot)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);\n      } else if (this.tokens.matches1(tt.bracketL)) {\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);\n      } else if (this.tokens.matches1(tt.parenL)) {\n        if (this.justSkippedSuper()) {\n          this.tokens.appendCode(\".bind(this)\");\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);\n      } else {\n        throw new Error(\"Unexpected subscript operator in optional chain.\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determine if the current token is the last of its chain, so that we know whether it's eligible\n   * to have a delete op inserted.\n   *\n   * We can do this by walking forward until we determine one way or another. Each\n   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in\n   * a nesting way, so we can track depth and walk to the end of the chain (the point where the\n   * depth goes negative) and see if any other subscript token is after us in the chain.\n   */\n  isLastSubscriptInChain() {\n    let depth = 0;\n    for (let i = this.tokens.currentIndex() + 1; ; i++) {\n      if (i >= this.tokens.tokens.length) {\n        throw new Error(\"Reached the end of the code while finding the end of the access chain.\");\n      }\n      if (this.tokens.tokens[i].isOptionalChainStart) {\n        depth++;\n      } else if (this.tokens.tokens[i].isOptionalChainEnd) {\n        depth--;\n      }\n      if (depth < 0) {\n        return true;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Determine if we are the open-paren in an expression like super.a()?.b.\n   *\n   * We can do this by walking backward to find the previous subscript. If that subscript was\n   * preceded by a super, then we must be the subscript after it, so if this is a call expression,\n   * we'll need to attach the right context.\n   */\n  justSkippedSuper() {\n    let depth = 0;\n    let index = this.tokens.currentIndex() - 1;\n    while (true) {\n      if (index < 0) {\n        throw new Error(\n          \"Reached the start of the code while finding the start of the access chain.\",\n        );\n      }\n      if (this.tokens.tokens[index].isOptionalChainStart) {\n        depth--;\n      } else if (this.tokens.tokens[index].isOptionalChainEnd) {\n        depth++;\n      }\n      if (depth < 0) {\n        return false;\n      }\n\n      // This subscript token is a later one in the same chain.\n      if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) {\n        return this.tokens.tokens[index - 1].type === tt._super;\n      }\n      index--;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}