{"ast":null,"code":"import { IdentifierRole } from \"../parser/tokenizer\";\nimport { TokenType, TokenType as tt } from \"../parser/tokenizer/types\";\nimport { startsWithLowerCase } from \"../transformers/JSXTransformer\";\nimport getJSXPragmaInfo from \"./getJSXPragmaInfo\";\nexport function getNonTypeIdentifiers(tokens, options) {\n  const jsxPragmaInfo = getJSXPragmaInfo(options);\n  const nonTypeIdentifiers = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (token.type === tt.name && !token.isType && (token.identifierRole === IdentifierRole.Access || token.identifierRole === IdentifierRole.ObjectShorthand || token.identifierRole === IdentifierRole.ExportAccess) && !token.shadowsGlobal) {\n      nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n    }\n    if (token.type === tt.jsxTagStart) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n    }\n    if (token.type === tt.jsxTagStart && i + 1 < tokens.tokens.length && tokens.tokens[i + 1].type === tt.jsxTagEnd) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);\n    }\n    if (token.type === tt.jsxName && token.identifierRole === IdentifierRole.Access) {\n      const identifierName = tokens.identifierNameForToken(token);\n      // Lower-case single-component tag names like \"div\" don't count.\n      if (!startsWithLowerCase(identifierName) || tokens.tokens[i + 1].type === TokenType.dot) {\n        nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return nonTypeIdentifiers;\n}","map":{"version":3,"names":["IdentifierRole","TokenType","tt","startsWithLowerCase","getJSXPragmaInfo","getNonTypeIdentifiers","tokens","options","jsxPragmaInfo","nonTypeIdentifiers","Set","i","length","token","type","name","isType","identifierRole","Access","ObjectShorthand","ExportAccess","shadowsGlobal","add","identifierNameForToken","jsxTagStart","base","jsxTagEnd","fragmentBase","jsxName","identifierName","dot"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/util/getNonTypeIdentifiers.js"],"sourcesContent":["\nimport {IdentifierRole} from \"../parser/tokenizer\";\nimport {TokenType, TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport {startsWithLowerCase} from \"../transformers/JSXTransformer\";\nimport getJSXPragmaInfo from \"./getJSXPragmaInfo\";\n\nexport function getNonTypeIdentifiers(tokens, options) {\n  const jsxPragmaInfo = getJSXPragmaInfo(options);\n  const nonTypeIdentifiers = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    const token = tokens.tokens[i];\n    if (\n      token.type === tt.name &&\n      !token.isType &&\n      (token.identifierRole === IdentifierRole.Access ||\n        token.identifierRole === IdentifierRole.ObjectShorthand ||\n        token.identifierRole === IdentifierRole.ExportAccess) &&\n      !token.shadowsGlobal\n    ) {\n      nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n    }\n    if (token.type === tt.jsxTagStart) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n    }\n    if (\n      token.type === tt.jsxTagStart &&\n      i + 1 < tokens.tokens.length &&\n      tokens.tokens[i + 1].type === tt.jsxTagEnd\n    ) {\n      nonTypeIdentifiers.add(jsxPragmaInfo.base);\n      nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);\n    }\n    if (token.type === tt.jsxName && token.identifierRole === IdentifierRole.Access) {\n      const identifierName = tokens.identifierNameForToken(token);\n      // Lower-case single-component tag names like \"div\" don't count.\n      if (!startsWithLowerCase(identifierName) || tokens.tokens[i + 1].type === TokenType.dot) {\n        nonTypeIdentifiers.add(tokens.identifierNameForToken(token));\n      }\n    }\n  }\n  return nonTypeIdentifiers;\n}\n"],"mappings":"AACA,SAAQA,cAAc,QAAO,qBAAqB;AAClD,SAAQC,SAAS,EAAEA,SAAS,IAAIC,EAAE,QAAO,2BAA2B;AAEpE,SAAQC,mBAAmB,QAAO,gCAAgC;AAClE,OAAOC,gBAAgB,MAAM,oBAAoB;AAEjD,OAAO,SAASC,qBAAqBA,CAACC,MAAM,EAAEC,OAAO,EAAE;EACrD,MAAMC,aAAa,GAAGJ,gBAAgB,CAACG,OAAO,CAAC;EAC/C,MAAME,kBAAkB,GAAG,IAAIC,GAAG,CAAC,CAAC;EACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,CAACA,MAAM,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IAC7C,MAAME,KAAK,GAAGP,MAAM,CAACA,MAAM,CAACK,CAAC,CAAC;IAC9B,IACEE,KAAK,CAACC,IAAI,KAAKZ,EAAE,CAACa,IAAI,IACtB,CAACF,KAAK,CAACG,MAAM,KACZH,KAAK,CAACI,cAAc,KAAKjB,cAAc,CAACkB,MAAM,IAC7CL,KAAK,CAACI,cAAc,KAAKjB,cAAc,CAACmB,eAAe,IACvDN,KAAK,CAACI,cAAc,KAAKjB,cAAc,CAACoB,YAAY,CAAC,IACvD,CAACP,KAAK,CAACQ,aAAa,EACpB;MACAZ,kBAAkB,CAACa,GAAG,CAAChB,MAAM,CAACiB,sBAAsB,CAACV,KAAK,CAAC,CAAC;IAC9D;IACA,IAAIA,KAAK,CAACC,IAAI,KAAKZ,EAAE,CAACsB,WAAW,EAAE;MACjCf,kBAAkB,CAACa,GAAG,CAACd,aAAa,CAACiB,IAAI,CAAC;IAC5C;IACA,IACEZ,KAAK,CAACC,IAAI,KAAKZ,EAAE,CAACsB,WAAW,IAC7Bb,CAAC,GAAG,CAAC,GAAGL,MAAM,CAACA,MAAM,CAACM,MAAM,IAC5BN,MAAM,CAACA,MAAM,CAACK,CAAC,GAAG,CAAC,CAAC,CAACG,IAAI,KAAKZ,EAAE,CAACwB,SAAS,EAC1C;MACAjB,kBAAkB,CAACa,GAAG,CAACd,aAAa,CAACiB,IAAI,CAAC;MAC1ChB,kBAAkB,CAACa,GAAG,CAACd,aAAa,CAACmB,YAAY,CAAC;IACpD;IACA,IAAId,KAAK,CAACC,IAAI,KAAKZ,EAAE,CAAC0B,OAAO,IAAIf,KAAK,CAACI,cAAc,KAAKjB,cAAc,CAACkB,MAAM,EAAE;MAC/E,MAAMW,cAAc,GAAGvB,MAAM,CAACiB,sBAAsB,CAACV,KAAK,CAAC;MAC3D;MACA,IAAI,CAACV,mBAAmB,CAAC0B,cAAc,CAAC,IAAIvB,MAAM,CAACA,MAAM,CAACK,CAAC,GAAG,CAAC,CAAC,CAACG,IAAI,KAAKb,SAAS,CAAC6B,GAAG,EAAE;QACvFrB,kBAAkB,CAACa,GAAG,CAAChB,MAAM,CAACiB,sBAAsB,CAACV,KAAK,CAAC,CAAC;MAC9D;IACF;EACF;EACA,OAAOJ,kBAAkB;AAC3B"},"metadata":{},"sourceType":"module","externalDependencies":[]}