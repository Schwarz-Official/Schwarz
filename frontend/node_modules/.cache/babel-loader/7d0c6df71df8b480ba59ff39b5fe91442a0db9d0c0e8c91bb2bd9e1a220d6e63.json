{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return collapseAdjacentRules;\n  }\n});\nlet comparisonMap = {\n  atrule: [\"name\", \"params\"],\n  rule: [\"selector\"]\n};\nlet types = new Set(Object.keys(comparisonMap));\nfunction collapseAdjacentRules() {\n  function collapseRulesIn(root) {\n    let currentRule = null;\n    root.each(node => {\n      if (!types.has(node.type)) {\n        currentRule = null;\n        return;\n      }\n      if (currentRule === null) {\n        currentRule = node;\n        return;\n      }\n      let properties = comparisonMap[node.type];\n      var _node_property, _currentRule_property;\n      if (node.type === \"atrule\" && node.name === \"font-face\") {\n        currentRule = node;\n      } else if (properties.every(property => ((_node_property = node[property]) !== null && _node_property !== void 0 ? _node_property : \"\").replace(/\\s+/g, \" \") === ((_currentRule_property = currentRule[property]) !== null && _currentRule_property !== void 0 ? _currentRule_property : \"\").replace(/\\s+/g, \" \"))) {\n        // An AtRule may not have children (for example if we encounter duplicate @import url(…) rules)\n        if (node.nodes) {\n          currentRule.append(node.nodes);\n        }\n        node.remove();\n      } else {\n        currentRule = node;\n      }\n    });\n    // After we've collapsed adjacent rules & at-rules, we need to collapse\n    // adjacent rules & at-rules that are children of at-rules.\n    // We do not care about nesting rules because Tailwind CSS\n    // explicitly does not handle rule nesting on its own as\n    // the user is expected to use a nesting plugin\n    root.each(node => {\n      if (node.type === \"atrule\") {\n        collapseRulesIn(node);\n      }\n    });\n  }\n  return root => {\n    collapseRulesIn(root);\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","collapseAdjacentRules","comparisonMap","atrule","rule","types","Set","keys","collapseRulesIn","root","currentRule","each","node","has","type","properties","_node_property","_currentRule_property","name","every","property","replace","nodes","append","remove"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return collapseAdjacentRules;\n    }\n});\nlet comparisonMap = {\n    atrule: [\n        \"name\",\n        \"params\"\n    ],\n    rule: [\n        \"selector\"\n    ]\n};\nlet types = new Set(Object.keys(comparisonMap));\nfunction collapseAdjacentRules() {\n    function collapseRulesIn(root) {\n        let currentRule = null;\n        root.each((node)=>{\n            if (!types.has(node.type)) {\n                currentRule = null;\n                return;\n            }\n            if (currentRule === null) {\n                currentRule = node;\n                return;\n            }\n            let properties = comparisonMap[node.type];\n            var _node_property, _currentRule_property;\n            if (node.type === \"atrule\" && node.name === \"font-face\") {\n                currentRule = node;\n            } else if (properties.every((property)=>((_node_property = node[property]) !== null && _node_property !== void 0 ? _node_property : \"\").replace(/\\s+/g, \" \") === ((_currentRule_property = currentRule[property]) !== null && _currentRule_property !== void 0 ? _currentRule_property : \"\").replace(/\\s+/g, \" \"))) {\n                // An AtRule may not have children (for example if we encounter duplicate @import url(…) rules)\n                if (node.nodes) {\n                    currentRule.append(node.nodes);\n                }\n                node.remove();\n            } else {\n                currentRule = node;\n            }\n        });\n        // After we've collapsed adjacent rules & at-rules, we need to collapse\n        // adjacent rules & at-rules that are children of at-rules.\n        // We do not care about nesting rules because Tailwind CSS\n        // explicitly does not handle rule nesting on its own as\n        // the user is expected to use a nesting plugin\n        root.each((node)=>{\n            if (node.type === \"atrule\") {\n                collapseRulesIn(node);\n            }\n        });\n    }\n    return (root)=>{\n        collapseRulesIn(root);\n    };\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,SAAS,EAAE;EACtCE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,OAAOC,qBAAqB;EAChC;AACJ,CAAC,CAAC;AACF,IAAIC,aAAa,GAAG;EAChBC,MAAM,EAAE,CACJ,MAAM,EACN,QAAQ,CACX;EACDC,IAAI,EAAE,CACF,UAAU;AAElB,CAAC;AACD,IAAIC,KAAK,GAAG,IAAIC,GAAG,CAACX,MAAM,CAACY,IAAI,CAACL,aAAa,CAAC,CAAC;AAC/C,SAASD,qBAAqBA,CAAA,EAAG;EAC7B,SAASO,eAAeA,CAACC,IAAI,EAAE;IAC3B,IAAIC,WAAW,GAAG,IAAI;IACtBD,IAAI,CAACE,IAAI,CAAEC,IAAI,IAAG;MACd,IAAI,CAACP,KAAK,CAACQ,GAAG,CAACD,IAAI,CAACE,IAAI,CAAC,EAAE;QACvBJ,WAAW,GAAG,IAAI;QAClB;MACJ;MACA,IAAIA,WAAW,KAAK,IAAI,EAAE;QACtBA,WAAW,GAAGE,IAAI;QAClB;MACJ;MACA,IAAIG,UAAU,GAAGb,aAAa,CAACU,IAAI,CAACE,IAAI,CAAC;MACzC,IAAIE,cAAc,EAAEC,qBAAqB;MACzC,IAAIL,IAAI,CAACE,IAAI,KAAK,QAAQ,IAAIF,IAAI,CAACM,IAAI,KAAK,WAAW,EAAE;QACrDR,WAAW,GAAGE,IAAI;MACtB,CAAC,MAAM,IAAIG,UAAU,CAACI,KAAK,CAAEC,QAAQ,IAAG,CAAC,CAACJ,cAAc,GAAGJ,IAAI,CAACQ,QAAQ,CAAC,MAAM,IAAI,IAAIJ,cAAc,KAAK,KAAK,CAAC,GAAGA,cAAc,GAAG,EAAE,EAAEK,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,CAAC,CAACJ,qBAAqB,GAAGP,WAAW,CAACU,QAAQ,CAAC,MAAM,IAAI,IAAIH,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,EAAE,EAAEI,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,EAAE;QAChT;QACA,IAAIT,IAAI,CAACU,KAAK,EAAE;UACZZ,WAAW,CAACa,MAAM,CAACX,IAAI,CAACU,KAAK,CAAC;QAClC;QACAV,IAAI,CAACY,MAAM,CAAC,CAAC;MACjB,CAAC,MAAM;QACHd,WAAW,GAAGE,IAAI;MACtB;IACJ,CAAC,CAAC;IACF;IACA;IACA;IACA;IACA;IACAH,IAAI,CAACE,IAAI,CAAEC,IAAI,IAAG;MACd,IAAIA,IAAI,CAACE,IAAI,KAAK,QAAQ,EAAE;QACxBN,eAAe,CAACI,IAAI,CAAC;MACzB;IACJ,CAAC,CAAC;EACN;EACA,OAAQH,IAAI,IAAG;IACXD,eAAe,CAACC,IAAI,CAAC;EACzB,CAAC;AACL"},"metadata":{},"sourceType":"script","externalDependencies":[]}