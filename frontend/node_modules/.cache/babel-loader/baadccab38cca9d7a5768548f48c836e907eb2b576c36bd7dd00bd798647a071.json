{"ast":null,"code":"import LinesAndColumns from \"lines-and-columns\";\nimport { formatTokenType } from \"../parser/tokenizer/types\";\nexport default function formatTokens(code, tokens) {\n  if (tokens.length === 0) {\n    return \"\";\n  }\n  const tokenKeys = Object.keys(tokens[0]).filter(k => k !== \"type\" && k !== \"value\" && k !== \"start\" && k !== \"end\" && k !== \"loc\");\n  const typeKeys = Object.keys(tokens[0].type).filter(k => k !== \"label\" && k !== \"keyword\");\n  const headings = [\"Location\", \"Label\", \"Raw\", ...tokenKeys, ...typeKeys];\n  const lines = new LinesAndColumns(code);\n  const rows = [headings, ...tokens.map(getTokenComponents)];\n  const padding = headings.map(() => 0);\n  for (const components of rows) {\n    for (let i = 0; i < components.length; i++) {\n      padding[i] = Math.max(padding[i], components[i].length);\n    }\n  }\n  return rows.map(components => components.map((component, i) => component.padEnd(padding[i])).join(\" \")).join(\"\\n\");\n  function getTokenComponents(token) {\n    const raw = code.slice(token.start, token.end);\n    return [formatRange(token.start, token.end), formatTokenType(token.type), truncate(String(raw), 14),\n    // @ts-ignore: Intentional dynamic access by key.\n    ...tokenKeys.map(key => formatValue(token[key], key)),\n    // @ts-ignore: Intentional dynamic access by key.\n    ...typeKeys.map(key => formatValue(token.type[key], key))];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function formatValue(value, key) {\n    if (value === true) {\n      return key;\n    } else if (value === false || value === null) {\n      return \"\";\n    } else {\n      return String(value);\n    }\n  }\n  function formatRange(start, end) {\n    return `${formatPos(start)}-${formatPos(end)}`;\n  }\n  function formatPos(pos) {\n    const location = lines.locationForIndex(pos);\n    if (!location) {\n      return \"Unknown\";\n    } else {\n      return `${location.line + 1}:${location.column + 1}`;\n    }\n  }\n}\nfunction truncate(s, length) {\n  if (s.length > length) {\n    return `${s.slice(0, length - 3)}...`;\n  } else {\n    return s;\n  }\n}","map":{"version":3,"names":["LinesAndColumns","formatTokenType","formatTokens","code","tokens","length","tokenKeys","Object","keys","filter","k","typeKeys","type","headings","lines","rows","map","getTokenComponents","padding","components","i","Math","max","component","padEnd","join","token","raw","slice","start","end","formatRange","truncate","String","key","formatValue","value","formatPos","pos","location","locationForIndex","line","column","s"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/util/formatTokens.js"],"sourcesContent":["import LinesAndColumns from \"lines-and-columns\";\n\n\nimport {formatTokenType} from \"../parser/tokenizer/types\";\n\nexport default function formatTokens(code, tokens) {\n  if (tokens.length === 0) {\n    return \"\";\n  }\n\n  const tokenKeys = Object.keys(tokens[0]).filter(\n    (k) => k !== \"type\" && k !== \"value\" && k !== \"start\" && k !== \"end\" && k !== \"loc\",\n  );\n  const typeKeys = Object.keys(tokens[0].type).filter((k) => k !== \"label\" && k !== \"keyword\");\n\n  const headings = [\"Location\", \"Label\", \"Raw\", ...tokenKeys, ...typeKeys];\n\n  const lines = new LinesAndColumns(code);\n  const rows = [headings, ...tokens.map(getTokenComponents)];\n  const padding = headings.map(() => 0);\n  for (const components of rows) {\n    for (let i = 0; i < components.length; i++) {\n      padding[i] = Math.max(padding[i], components[i].length);\n    }\n  }\n  return rows\n    .map((components) => components.map((component, i) => component.padEnd(padding[i])).join(\" \"))\n    .join(\"\\n\");\n\n  function getTokenComponents(token) {\n    const raw = code.slice(token.start, token.end);\n    return [\n      formatRange(token.start, token.end),\n      formatTokenType(token.type),\n      truncate(String(raw), 14),\n      // @ts-ignore: Intentional dynamic access by key.\n      ...tokenKeys.map((key) => formatValue(token[key], key)),\n      // @ts-ignore: Intentional dynamic access by key.\n      ...typeKeys.map((key) => formatValue(token.type[key], key)),\n    ];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function formatValue(value, key) {\n    if (value === true) {\n      return key;\n    } else if (value === false || value === null) {\n      return \"\";\n    } else {\n      return String(value);\n    }\n  }\n\n  function formatRange(start, end) {\n    return `${formatPos(start)}-${formatPos(end)}`;\n  }\n\n  function formatPos(pos) {\n    const location = lines.locationForIndex(pos);\n    if (!location) {\n      return \"Unknown\";\n    } else {\n      return `${location.line + 1}:${location.column + 1}`;\n    }\n  }\n}\n\nfunction truncate(s, length) {\n  if (s.length > length) {\n    return `${s.slice(0, length - 3)}...`;\n  } else {\n    return s;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}