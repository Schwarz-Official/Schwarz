{"ast":null,"code":"/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ // There are some pseudo-elements that may or may not be:\n// **Actionable**\n// Zero or more user-action pseudo-classes may be attached to the pseudo-element itself\n// structural-pseudo-classes are NOT allowed but we don't make\n// The spec is not clear on whether this is allowed or not — but in practice it is.\n// **Terminal**\n// It MUST be placed at the end of a selector\n//\n// This is the required in the spec. However, some pseudo elements are not \"terminal\" because\n// they represent a \"boundary piercing\" that is compiled out by a build step.\n// **Jumpable**\n// Any terminal element may \"jump\" over combinators when moving to the end of the selector\n//\n// This is a backwards-compat quirk of pseudo element variants from earlier versions of Tailwind CSS.\n/** @typedef {'terminal' | 'actionable' | 'jumpable'} PseudoProperty */ /** @type {Record<string, PseudoProperty[]>} */\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"movePseudos\", {\n  enumerable: true,\n  get: function () {\n    return movePseudos;\n  }\n});\nlet elementProperties = {\n  // Pseudo elements from the spec\n  \"::after\": [\"terminal\", \"jumpable\"],\n  \"::backdrop\": [\"terminal\", \"jumpable\"],\n  \"::before\": [\"terminal\", \"jumpable\"],\n  \"::cue\": [\"terminal\"],\n  \"::cue-region\": [\"terminal\"],\n  \"::first-letter\": [\"terminal\", \"jumpable\"],\n  \"::first-line\": [\"terminal\", \"jumpable\"],\n  \"::grammar-error\": [\"terminal\"],\n  \"::marker\": [\"terminal\", \"jumpable\"],\n  \"::part\": [\"terminal\", \"actionable\"],\n  \"::placeholder\": [\"terminal\", \"jumpable\"],\n  \"::selection\": [\"terminal\", \"jumpable\"],\n  \"::slotted\": [\"terminal\"],\n  \"::spelling-error\": [\"terminal\"],\n  \"::target-text\": [\"terminal\"],\n  // Pseudo elements from the spec with special rules\n  \"::file-selector-button\": [\"terminal\", \"actionable\"],\n  // Library-specific pseudo elements used by component libraries\n  // These are Shadow DOM-like\n  \"::deep\": [\"actionable\"],\n  \"::v-deep\": [\"actionable\"],\n  \"::ng-deep\": [\"actionable\"],\n  // Note: As a rule, double colons (::) should be used instead of a single colon\n  // (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n  // this distinction was not present in older versions of the W3C spec, most\n  // browsers support both syntaxes for the original pseudo-elements.\n  \":after\": [\"terminal\", \"jumpable\"],\n  \":before\": [\"terminal\", \"jumpable\"],\n  \":first-letter\": [\"terminal\", \"jumpable\"],\n  \":first-line\": [\"terminal\", \"jumpable\"],\n  // The default value is used when the pseudo-element is not recognized\n  // Because it's not recognized, we don't know if it's terminal or not\n  // So we assume it can be moved AND can have user-action pseudo classes attached to it\n  __default__: [\"terminal\", \"actionable\"]\n};\nfunction movePseudos(sel) {\n  let [pseudos] = movablePseudos(sel);\n  // Remove all pseudo elements from their respective selectors\n  pseudos.forEach(([sel, pseudo]) => sel.removeChild(pseudo));\n  // Re-add them to the end of the selector in the correct order.\n  // This moves terminal pseudo elements to the end of the\n  // selector otherwise the selector will not be valid.\n  //\n  // Examples:\n  //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n  //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n  //\n  // The selector `::before:hover` does not work but we\n  // can make it work for you by flipping the order.\n  sel.nodes.push(...pseudos.map(([, pseudo]) => pseudo));\n  return sel;\n}\n/** @typedef {[sel: Selector, pseudo: Pseudo, attachedTo: Pseudo | null]} MovablePseudo */ /** @typedef {[pseudos: MovablePseudo[], lastSeenElement: Pseudo | null]} MovablePseudosResult */ /**\n                                                                                                                                                                                             * @param {Selector} sel\n                                                                                                                                                                                             * @returns {MovablePseudosResult}\n                                                                                                                                                                                             */\nfunction movablePseudos(sel) {\n  /** @type {MovablePseudo[]} */let buffer = [];\n  /** @type {Pseudo | null} */\n  let lastSeenElement = null;\n  for (let node of sel.nodes) {\n    if (node.type === \"combinator\") {\n      buffer = buffer.filter(([, node]) => propertiesForPseudo(node).includes(\"jumpable\"));\n      lastSeenElement = null;\n    } else if (node.type === \"pseudo\") {\n      if (isMovablePseudoElement(node)) {\n        lastSeenElement = node;\n        buffer.push([sel, node, null]);\n      } else if (lastSeenElement && isAttachablePseudoClass(node, lastSeenElement)) {\n        buffer.push([sel, node, lastSeenElement]);\n      } else {\n        lastSeenElement = null;\n      }\n      var _node_nodes;\n      for (let sub of (_node_nodes = node.nodes) !== null && _node_nodes !== void 0 ? _node_nodes : []) {\n        let [movable, lastSeenElementInSub] = movablePseudos(sub);\n        lastSeenElement = lastSeenElementInSub || lastSeenElement;\n        buffer.push(...movable);\n      }\n    }\n  }\n  return [buffer, lastSeenElement];\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isPseudoElement(node) {\n  return node.value.startsWith(\"::\") || elementProperties[node.value] !== undefined;\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isMovablePseudoElement(node) {\n  return isPseudoElement(node) && propertiesForPseudo(node).includes(\"terminal\");\n}\n/**\n * @param {Node} node\n * @param {Pseudo} pseudo\n * @returns {boolean}\n */\nfunction isAttachablePseudoClass(node, pseudo) {\n  if (node.type !== \"pseudo\") return false;\n  if (isPseudoElement(node)) return false;\n  return propertiesForPseudo(pseudo).includes(\"actionable\");\n}\n/**\n * @param {Pseudo} pseudo\n * @returns {PseudoProperty[]}\n */\nfunction propertiesForPseudo(pseudo) {\n  var _elementProperties_pseudo_value;\n  return (_elementProperties_pseudo_value = elementProperties[pseudo.value]) !== null && _elementProperties_pseudo_value !== void 0 ? _elementProperties_pseudo_value : elementProperties.__default__;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","movePseudos","elementProperties","__default__","sel","pseudos","movablePseudos","forEach","pseudo","removeChild","nodes","push","map","buffer","lastSeenElement","node","type","filter","propertiesForPseudo","includes","isMovablePseudoElement","isAttachablePseudoClass","_node_nodes","sub","movable","lastSeenElementInSub","isPseudoElement","startsWith","undefined","_elementProperties_pseudo_value"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/util/pseudoElements.js"],"sourcesContent":["/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ // There are some pseudo-elements that may or may not be:\n// **Actionable**\n// Zero or more user-action pseudo-classes may be attached to the pseudo-element itself\n// structural-pseudo-classes are NOT allowed but we don't make\n// The spec is not clear on whether this is allowed or not — but in practice it is.\n// **Terminal**\n// It MUST be placed at the end of a selector\n//\n// This is the required in the spec. However, some pseudo elements are not \"terminal\" because\n// they represent a \"boundary piercing\" that is compiled out by a build step.\n// **Jumpable**\n// Any terminal element may \"jump\" over combinators when moving to the end of the selector\n//\n// This is a backwards-compat quirk of pseudo element variants from earlier versions of Tailwind CSS.\n/** @typedef {'terminal' | 'actionable' | 'jumpable'} PseudoProperty */ /** @type {Record<string, PseudoProperty[]>} */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"movePseudos\", {\n    enumerable: true,\n    get: function() {\n        return movePseudos;\n    }\n});\nlet elementProperties = {\n    // Pseudo elements from the spec\n    \"::after\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::backdrop\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::before\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::cue\": [\n        \"terminal\"\n    ],\n    \"::cue-region\": [\n        \"terminal\"\n    ],\n    \"::first-letter\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::first-line\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::grammar-error\": [\n        \"terminal\"\n    ],\n    \"::marker\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::part\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    \"::placeholder\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::selection\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \"::slotted\": [\n        \"terminal\"\n    ],\n    \"::spelling-error\": [\n        \"terminal\"\n    ],\n    \"::target-text\": [\n        \"terminal\"\n    ],\n    // Pseudo elements from the spec with special rules\n    \"::file-selector-button\": [\n        \"terminal\",\n        \"actionable\"\n    ],\n    // Library-specific pseudo elements used by component libraries\n    // These are Shadow DOM-like\n    \"::deep\": [\n        \"actionable\"\n    ],\n    \"::v-deep\": [\n        \"actionable\"\n    ],\n    \"::ng-deep\": [\n        \"actionable\"\n    ],\n    // Note: As a rule, double colons (::) should be used instead of a single colon\n    // (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n    // this distinction was not present in older versions of the W3C spec, most\n    // browsers support both syntaxes for the original pseudo-elements.\n    \":after\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \":before\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \":first-letter\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    \":first-line\": [\n        \"terminal\",\n        \"jumpable\"\n    ],\n    // The default value is used when the pseudo-element is not recognized\n    // Because it's not recognized, we don't know if it's terminal or not\n    // So we assume it can be moved AND can have user-action pseudo classes attached to it\n    __default__: [\n        \"terminal\",\n        \"actionable\"\n    ]\n};\nfunction movePseudos(sel) {\n    let [pseudos] = movablePseudos(sel);\n    // Remove all pseudo elements from their respective selectors\n    pseudos.forEach(([sel, pseudo])=>sel.removeChild(pseudo));\n    // Re-add them to the end of the selector in the correct order.\n    // This moves terminal pseudo elements to the end of the\n    // selector otherwise the selector will not be valid.\n    //\n    // Examples:\n    //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n    //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n    //\n    // The selector `::before:hover` does not work but we\n    // can make it work for you by flipping the order.\n    sel.nodes.push(...pseudos.map(([, pseudo])=>pseudo));\n    return sel;\n}\n/** @typedef {[sel: Selector, pseudo: Pseudo, attachedTo: Pseudo | null]} MovablePseudo */ /** @typedef {[pseudos: MovablePseudo[], lastSeenElement: Pseudo | null]} MovablePseudosResult */ /**\n * @param {Selector} sel\n * @returns {MovablePseudosResult}\n */ function movablePseudos(sel) {\n    /** @type {MovablePseudo[]} */ let buffer = [];\n    /** @type {Pseudo | null} */ let lastSeenElement = null;\n    for (let node of sel.nodes){\n        if (node.type === \"combinator\") {\n            buffer = buffer.filter(([, node])=>propertiesForPseudo(node).includes(\"jumpable\"));\n            lastSeenElement = null;\n        } else if (node.type === \"pseudo\") {\n            if (isMovablePseudoElement(node)) {\n                lastSeenElement = node;\n                buffer.push([\n                    sel,\n                    node,\n                    null\n                ]);\n            } else if (lastSeenElement && isAttachablePseudoClass(node, lastSeenElement)) {\n                buffer.push([\n                    sel,\n                    node,\n                    lastSeenElement\n                ]);\n            } else {\n                lastSeenElement = null;\n            }\n            var _node_nodes;\n            for (let sub of (_node_nodes = node.nodes) !== null && _node_nodes !== void 0 ? _node_nodes : []){\n                let [movable, lastSeenElementInSub] = movablePseudos(sub);\n                lastSeenElement = lastSeenElementInSub || lastSeenElement;\n                buffer.push(...movable);\n            }\n        }\n    }\n    return [\n        buffer,\n        lastSeenElement\n    ];\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */ function isPseudoElement(node) {\n    return node.value.startsWith(\"::\") || elementProperties[node.value] !== undefined;\n}\n/**\n * @param {Node} node\n * @returns {boolean}\n */ function isMovablePseudoElement(node) {\n    return isPseudoElement(node) && propertiesForPseudo(node).includes(\"terminal\");\n}\n/**\n * @param {Node} node\n * @param {Pseudo} pseudo\n * @returns {boolean}\n */ function isAttachablePseudoClass(node, pseudo) {\n    if (node.type !== \"pseudo\") return false;\n    if (isPseudoElement(node)) return false;\n    return propertiesForPseudo(pseudo).includes(\"actionable\");\n}\n/**\n * @param {Pseudo} pseudo\n * @returns {PseudoProperty[]}\n */ function propertiesForPseudo(pseudo) {\n    var _elementProperties_pseudo_value;\n    return (_elementProperties_pseudo_value = elementProperties[pseudo.value]) !== null && _elementProperties_pseudo_value !== void 0 ? _elementProperties_pseudo_value : elementProperties.__default__;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}