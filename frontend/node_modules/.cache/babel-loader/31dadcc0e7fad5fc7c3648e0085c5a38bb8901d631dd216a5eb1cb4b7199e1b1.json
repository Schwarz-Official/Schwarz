{"ast":null,"code":"import { ContextualKeyword } from \"./keywords\";\nimport { TokenType as tt } from \"./types\";\nexport class Scope {\n  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {\n    this.startTokenIndex = startTokenIndex;\n    this.endTokenIndex = endTokenIndex;\n    this.isFunctionScope = isFunctionScope;\n  }\n}\nexport class StateSnapshot {\n  constructor(potentialArrowAt, noAnonFunctionType, inDisallowConditionalTypesContext, tokensLength, scopesLength, pos, type, contextualKeyword, start, end, isType, scopeDepth, error) {\n    ;\n    this.potentialArrowAt = potentialArrowAt;\n    this.noAnonFunctionType = noAnonFunctionType;\n    this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;\n    this.tokensLength = tokensLength;\n    this.scopesLength = scopesLength;\n    this.pos = pos;\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n    this.start = start;\n    this.end = end;\n    this.isType = isType;\n    this.scopeDepth = scopeDepth;\n    this.error = error;\n  }\n}\nexport default class State {\n  constructor() {\n    State.prototype.__init.call(this);\n    State.prototype.__init2.call(this);\n    State.prototype.__init3.call(this);\n    State.prototype.__init4.call(this);\n    State.prototype.__init5.call(this);\n    State.prototype.__init6.call(this);\n    State.prototype.__init7.call(this);\n    State.prototype.__init8.call(this);\n    State.prototype.__init9.call(this);\n    State.prototype.__init10.call(this);\n    State.prototype.__init11.call(this);\n    State.prototype.__init12.call(this);\n    State.prototype.__init13.call(this);\n  }\n  // Used to signify the start of a potential arrow function\n  __init() {\n    this.potentialArrowAt = -1;\n  }\n\n  // Used by Flow to handle an edge case involving function type parsing.\n  __init2() {\n    this.noAnonFunctionType = false;\n  }\n\n  // Used by TypeScript to handle ambiguities when parsing conditional types.\n  __init3() {\n    this.inDisallowConditionalTypesContext = false;\n  }\n\n  // Token store.\n  __init4() {\n    this.tokens = [];\n  }\n\n  // Array of all observed scopes, ordered by their ending position.\n  __init5() {\n    this.scopes = [];\n  }\n\n  // The current position of the tokenizer in the input.\n  __init6() {\n    this.pos = 0;\n  }\n\n  // Information about the current token.\n  __init7() {\n    this.type = tt.eof;\n  }\n  __init8() {\n    this.contextualKeyword = ContextualKeyword.NONE;\n  }\n  __init9() {\n    this.start = 0;\n  }\n  __init10() {\n    this.end = 0;\n  }\n  __init11() {\n    this.isType = false;\n  }\n  __init12() {\n    this.scopeDepth = 0;\n  }\n\n  /**\n   * If the parser is in an error state, then the token is always tt.eof and all functions can\n   * keep executing but should be written so they don't get into an infinite loop in this situation.\n   *\n   * This approach, combined with the ability to snapshot and restore state, allows us to implement\n   * backtracking without exceptions and without needing to explicitly propagate error states\n   * everywhere.\n   */\n  __init13() {\n    this.error = null;\n  }\n  snapshot() {\n    return new StateSnapshot(this.potentialArrowAt, this.noAnonFunctionType, this.inDisallowConditionalTypesContext, this.tokens.length, this.scopes.length, this.pos, this.type, this.contextualKeyword, this.start, this.end, this.isType, this.scopeDepth, this.error);\n  }\n  restoreFromSnapshot(snapshot) {\n    this.potentialArrowAt = snapshot.potentialArrowAt;\n    this.noAnonFunctionType = snapshot.noAnonFunctionType;\n    this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;\n    this.tokens.length = snapshot.tokensLength;\n    this.scopes.length = snapshot.scopesLength;\n    this.pos = snapshot.pos;\n    this.type = snapshot.type;\n    this.contextualKeyword = snapshot.contextualKeyword;\n    this.start = snapshot.start;\n    this.end = snapshot.end;\n    this.isType = snapshot.isType;\n    this.scopeDepth = snapshot.scopeDepth;\n    this.error = snapshot.error;\n  }\n}","map":{"version":3,"names":["ContextualKeyword","TokenType","tt","Scope","constructor","startTokenIndex","endTokenIndex","isFunctionScope","StateSnapshot","potentialArrowAt","noAnonFunctionType","inDisallowConditionalTypesContext","tokensLength","scopesLength","pos","type","contextualKeyword","start","end","isType","scopeDepth","error","State","prototype","__init","call","__init2","__init3","__init4","__init5","__init6","__init7","__init8","__init9","__init10","__init11","__init12","__init13","tokens","scopes","eof","NONE","snapshot","length","restoreFromSnapshot"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/tokenizer/state.js"],"sourcesContent":["\nimport {ContextualKeyword} from \"./keywords\";\nimport { TokenType as tt} from \"./types\";\n\nexport class Scope {\n  \n  \n  \n\n  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {\n    this.startTokenIndex = startTokenIndex;\n    this.endTokenIndex = endTokenIndex;\n    this.isFunctionScope = isFunctionScope;\n  }\n}\n\nexport class StateSnapshot {\n  constructor(\n     potentialArrowAt,\n     noAnonFunctionType,\n     inDisallowConditionalTypesContext,\n     tokensLength,\n     scopesLength,\n     pos,\n     type,\n     contextualKeyword,\n     start,\n     end,\n     isType,\n     scopeDepth,\n     error,\n  ) {;this.potentialArrowAt = potentialArrowAt;this.noAnonFunctionType = noAnonFunctionType;this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;this.tokensLength = tokensLength;this.scopesLength = scopesLength;this.pos = pos;this.type = type;this.contextualKeyword = contextualKeyword;this.start = start;this.end = end;this.isType = isType;this.scopeDepth = scopeDepth;this.error = error;}\n}\n\nexport default class State {constructor() { State.prototype.__init.call(this);State.prototype.__init2.call(this);State.prototype.__init3.call(this);State.prototype.__init4.call(this);State.prototype.__init5.call(this);State.prototype.__init6.call(this);State.prototype.__init7.call(this);State.prototype.__init8.call(this);State.prototype.__init9.call(this);State.prototype.__init10.call(this);State.prototype.__init11.call(this);State.prototype.__init12.call(this);State.prototype.__init13.call(this); }\n  // Used to signify the start of a potential arrow function\n  __init() {this.potentialArrowAt = -1}\n\n  // Used by Flow to handle an edge case involving function type parsing.\n  __init2() {this.noAnonFunctionType = false}\n\n  // Used by TypeScript to handle ambiguities when parsing conditional types.\n  __init3() {this.inDisallowConditionalTypesContext = false}\n\n  // Token store.\n  __init4() {this.tokens = []}\n\n  // Array of all observed scopes, ordered by their ending position.\n  __init5() {this.scopes = []}\n\n  // The current position of the tokenizer in the input.\n  __init6() {this.pos = 0}\n\n  // Information about the current token.\n  __init7() {this.type = tt.eof}\n  __init8() {this.contextualKeyword = ContextualKeyword.NONE}\n  __init9() {this.start = 0}\n  __init10() {this.end = 0}\n\n  __init11() {this.isType = false}\n  __init12() {this.scopeDepth = 0}\n\n  /**\n   * If the parser is in an error state, then the token is always tt.eof and all functions can\n   * keep executing but should be written so they don't get into an infinite loop in this situation.\n   *\n   * This approach, combined with the ability to snapshot and restore state, allows us to implement\n   * backtracking without exceptions and without needing to explicitly propagate error states\n   * everywhere.\n   */\n  __init13() {this.error = null}\n\n  snapshot() {\n    return new StateSnapshot(\n      this.potentialArrowAt,\n      this.noAnonFunctionType,\n      this.inDisallowConditionalTypesContext,\n      this.tokens.length,\n      this.scopes.length,\n      this.pos,\n      this.type,\n      this.contextualKeyword,\n      this.start,\n      this.end,\n      this.isType,\n      this.scopeDepth,\n      this.error,\n    );\n  }\n\n  restoreFromSnapshot(snapshot) {\n    this.potentialArrowAt = snapshot.potentialArrowAt;\n    this.noAnonFunctionType = snapshot.noAnonFunctionType;\n    this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;\n    this.tokens.length = snapshot.tokensLength;\n    this.scopes.length = snapshot.scopesLength;\n    this.pos = snapshot.pos;\n    this.type = snapshot.type;\n    this.contextualKeyword = snapshot.contextualKeyword;\n    this.start = snapshot.start;\n    this.end = snapshot.end;\n    this.isType = snapshot.isType;\n    this.scopeDepth = snapshot.scopeDepth;\n    this.error = snapshot.error;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}