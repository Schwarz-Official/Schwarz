{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  elementSelectorParser: function () {\n    return elementSelectorParser;\n  },\n  default: function () {\n    return resolveDefaultsAtRules;\n  }\n});\nconst _postcss = /*#__PURE__*/_interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _featureFlags = require(\"../featureFlags\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nlet getNode = {\n  id(node) {\n    return _postcssselectorparser.default.attribute({\n      attribute: \"id\",\n      operator: \"=\",\n      value: node.value,\n      quoteMark: '\"'\n    });\n  }\n};\nfunction minimumImpactSelector(nodes) {\n  let rest = nodes.filter(node => {\n    // Keep non-pseudo nodes\n    if (node.type !== \"pseudo\") return true;\n    // Keep pseudo nodes that have subnodes\n    // E.g.: `:not()` contains subnodes inside the parentheses\n    if (node.nodes.length > 0) return true;\n    // Keep pseudo `elements`\n    // This implicitly means that we ignore pseudo `classes`\n    return node.value.startsWith(\"::\") || [\":before\", \":after\", \":first-line\", \":first-letter\"].includes(node.value);\n  }).reverse();\n  let searchFor = new Set([\"tag\", \"class\", \"id\", \"attribute\"]);\n  let splitPointIdx = rest.findIndex(n => searchFor.has(n.type));\n  if (splitPointIdx === -1) return rest.reverse().join(\"\").trim();\n  let node = rest[splitPointIdx];\n  let bestNode = getNode[node.type] ? getNode[node.type](node) : node;\n  rest = rest.slice(0, splitPointIdx);\n  let combinatorIdx = rest.findIndex(n => n.type === \"combinator\" && n.value === \">\");\n  if (combinatorIdx !== -1) {\n    rest.splice(0, combinatorIdx);\n    rest.unshift(_postcssselectorparser.default.universal());\n  }\n  return [bestNode, ...rest.reverse()].join(\"\").trim();\n}\nlet elementSelectorParser = (0, _postcssselectorparser.default)(selectors => {\n  return selectors.map(s => {\n    let nodes = s.split(n => n.type === \"combinator\" && n.value === \" \").pop();\n    return minimumImpactSelector(nodes);\n  });\n});\nlet cache = new Map();\nfunction extractElementSelector(selector) {\n  if (!cache.has(selector)) {\n    cache.set(selector, elementSelectorParser.transformSync(selector));\n  }\n  return cache.get(selector);\n}\nfunction resolveDefaultsAtRules({\n  tailwindConfig\n}) {\n  return root => {\n    let variableNodeMap = new Map();\n    /** @type {Set<import('postcss').AtRule>} */\n    let universals = new Set();\n    root.walkAtRules(\"defaults\", rule => {\n      if (rule.nodes && rule.nodes.length > 0) {\n        universals.add(rule);\n        return;\n      }\n      let variable = rule.params;\n      if (!variableNodeMap.has(variable)) {\n        variableNodeMap.set(variable, new Set());\n      }\n      variableNodeMap.get(variable).add(rule.parent);\n      rule.remove();\n    });\n    if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n      for (let universal of universals) {\n        /** @type {Map<string, Set<string>>} */let selectorGroups = new Map();\n        var _variableNodeMap_get;\n        let rules = (_variableNodeMap_get = variableNodeMap.get(universal.params)) !== null && _variableNodeMap_get !== void 0 ? _variableNodeMap_get : [];\n        for (let rule of rules) {\n          for (let selector of extractElementSelector(rule.selector)) {\n            // If selector contains a vendor prefix after a pseudo element or class,\n            // we consider them separately because merging the declarations into\n            // a single rule will cause browsers that do not understand the\n            // vendor prefix to throw out the whole rule\n            let selectorGroupName = selector.includes(\":-\") || selector.includes(\"::-\") ? selector : \"__DEFAULT__\";\n            var _selectorGroups_get;\n            let selectors = (_selectorGroups_get = selectorGroups.get(selectorGroupName)) !== null && _selectorGroups_get !== void 0 ? _selectorGroups_get : new Set();\n            selectorGroups.set(selectorGroupName, selectors);\n            selectors.add(selector);\n          }\n        }\n        if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n          if (selectorGroups.size === 0) {\n            universal.remove();\n            continue;\n          }\n          for (let [, selectors] of selectorGroups) {\n            let universalRule = _postcss.default.rule({\n              source: universal.source\n            });\n            universalRule.selectors = [...selectors];\n            universalRule.append(universal.nodes.map(node => node.clone()));\n            universal.before(universalRule);\n          }\n        }\n        universal.remove();\n      }\n    } else if (universals.size) {\n      let universalRule = _postcss.default.rule({\n        selectors: [\"*\", \"::before\", \"::after\"]\n      });\n      for (let universal of universals) {\n        universalRule.append(universal.nodes);\n        if (!universalRule.parent) {\n          universal.before(universalRule);\n        }\n        if (!universalRule.source) {\n          universalRule.source = universal.source;\n        }\n        universal.remove();\n      }\n      let backdropRule = universalRule.clone({\n        selectors: [\"::backdrop\"]\n      });\n      universalRule.after(backdropRule);\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","elementSelectorParser","default","resolveDefaultsAtRules","_postcss","_interop_require_default","require","_postcssselectorparser","_featureFlags","obj","__esModule","getNode","id","node","attribute","operator","quoteMark","minimumImpactSelector","nodes","rest","filter","type","length","startsWith","includes","reverse","searchFor","Set","splitPointIdx","findIndex","n","has","join","trim","bestNode","slice","combinatorIdx","splice","unshift","universal","selectors","map","s","split","pop","cache","Map","extractElementSelector","selector","set","transformSync","tailwindConfig","root","variableNodeMap","universals","walkAtRules","rule","add","variable","params","parent","remove","flagEnabled","selectorGroups","_variableNodeMap_get","rules","selectorGroupName","_selectorGroups_get","size","universalRule","source","append","clone","before","backdropRule","after"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    elementSelectorParser: function() {\n        return elementSelectorParser;\n    },\n    default: function() {\n        return resolveDefaultsAtRules;\n    }\n});\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _featureFlags = require(\"../featureFlags\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet getNode = {\n    id (node) {\n        return _postcssselectorparser.default.attribute({\n            attribute: \"id\",\n            operator: \"=\",\n            value: node.value,\n            quoteMark: '\"'\n        });\n    }\n};\nfunction minimumImpactSelector(nodes) {\n    let rest = nodes.filter((node)=>{\n        // Keep non-pseudo nodes\n        if (node.type !== \"pseudo\") return true;\n        // Keep pseudo nodes that have subnodes\n        // E.g.: `:not()` contains subnodes inside the parentheses\n        if (node.nodes.length > 0) return true;\n        // Keep pseudo `elements`\n        // This implicitly means that we ignore pseudo `classes`\n        return node.value.startsWith(\"::\") || [\n            \":before\",\n            \":after\",\n            \":first-line\",\n            \":first-letter\"\n        ].includes(node.value);\n    }).reverse();\n    let searchFor = new Set([\n        \"tag\",\n        \"class\",\n        \"id\",\n        \"attribute\"\n    ]);\n    let splitPointIdx = rest.findIndex((n)=>searchFor.has(n.type));\n    if (splitPointIdx === -1) return rest.reverse().join(\"\").trim();\n    let node = rest[splitPointIdx];\n    let bestNode = getNode[node.type] ? getNode[node.type](node) : node;\n    rest = rest.slice(0, splitPointIdx);\n    let combinatorIdx = rest.findIndex((n)=>n.type === \"combinator\" && n.value === \">\");\n    if (combinatorIdx !== -1) {\n        rest.splice(0, combinatorIdx);\n        rest.unshift(_postcssselectorparser.default.universal());\n    }\n    return [\n        bestNode,\n        ...rest.reverse()\n    ].join(\"\").trim();\n}\nlet elementSelectorParser = (0, _postcssselectorparser.default)((selectors)=>{\n    return selectors.map((s)=>{\n        let nodes = s.split((n)=>n.type === \"combinator\" && n.value === \" \").pop();\n        return minimumImpactSelector(nodes);\n    });\n});\nlet cache = new Map();\nfunction extractElementSelector(selector) {\n    if (!cache.has(selector)) {\n        cache.set(selector, elementSelectorParser.transformSync(selector));\n    }\n    return cache.get(selector);\n}\nfunction resolveDefaultsAtRules({ tailwindConfig  }) {\n    return (root)=>{\n        let variableNodeMap = new Map();\n        /** @type {Set<import('postcss').AtRule>} */ let universals = new Set();\n        root.walkAtRules(\"defaults\", (rule)=>{\n            if (rule.nodes && rule.nodes.length > 0) {\n                universals.add(rule);\n                return;\n            }\n            let variable = rule.params;\n            if (!variableNodeMap.has(variable)) {\n                variableNodeMap.set(variable, new Set());\n            }\n            variableNodeMap.get(variable).add(rule.parent);\n            rule.remove();\n        });\n        if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n            for (let universal of universals){\n                /** @type {Map<string, Set<string>>} */ let selectorGroups = new Map();\n                var _variableNodeMap_get;\n                let rules = (_variableNodeMap_get = variableNodeMap.get(universal.params)) !== null && _variableNodeMap_get !== void 0 ? _variableNodeMap_get : [];\n                for (let rule of rules){\n                    for (let selector of extractElementSelector(rule.selector)){\n                        // If selector contains a vendor prefix after a pseudo element or class,\n                        // we consider them separately because merging the declarations into\n                        // a single rule will cause browsers that do not understand the\n                        // vendor prefix to throw out the whole rule\n                        let selectorGroupName = selector.includes(\":-\") || selector.includes(\"::-\") ? selector : \"__DEFAULT__\";\n                        var _selectorGroups_get;\n                        let selectors = (_selectorGroups_get = selectorGroups.get(selectorGroupName)) !== null && _selectorGroups_get !== void 0 ? _selectorGroups_get : new Set();\n                        selectorGroups.set(selectorGroupName, selectors);\n                        selectors.add(selector);\n                    }\n                }\n                if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n                    if (selectorGroups.size === 0) {\n                        universal.remove();\n                        continue;\n                    }\n                    for (let [, selectors] of selectorGroups){\n                        let universalRule = _postcss.default.rule({\n                            source: universal.source\n                        });\n                        universalRule.selectors = [\n                            ...selectors\n                        ];\n                        universalRule.append(universal.nodes.map((node)=>node.clone()));\n                        universal.before(universalRule);\n                    }\n                }\n                universal.remove();\n            }\n        } else if (universals.size) {\n            let universalRule = _postcss.default.rule({\n                selectors: [\n                    \"*\",\n                    \"::before\",\n                    \"::after\"\n                ]\n            });\n            for (let universal of universals){\n                universalRule.append(universal.nodes);\n                if (!universalRule.parent) {\n                    universal.before(universalRule);\n                }\n                if (!universalRule.source) {\n                    universalRule.source = universal.source;\n                }\n                universal.remove();\n            }\n            let backdropRule = universalRule.clone({\n                selectors: [\n                    \"::backdrop\"\n                ]\n            });\n            universalRule.after(backdropRule);\n        }\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}