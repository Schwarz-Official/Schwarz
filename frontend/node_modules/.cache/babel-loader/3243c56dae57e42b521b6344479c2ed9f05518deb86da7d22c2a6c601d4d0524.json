{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, function () {\n  'use strict';\n\n  // Matches the scheme of a URL, eg \"http://\"\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   * 6. Query, including \"?\", optional.\n   * 7. Hash, including \"#\", optional.\n   */\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may include \"/\", guaranteed.\n   * 3. Query, including \"?\", optional.\n   * 4. Hash, including \"#\", optional.\n   */\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n  var UrlType;\n  (function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n  })(UrlType || (UrlType = {}));\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n  function isRelative(input) {\n    return /^[.?#]/.test(input);\n  }\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n  }\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n  }\n  function makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      query,\n      hash,\n      type: UrlType.Absolute\n    };\n  }\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      url.type = UrlType.SchemeRelative;\n      return url;\n    }\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      url.type = UrlType.AbsolutePath;\n      return url;\n    }\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n    return url;\n  }\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n  function mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    }\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n  function normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i];\n      // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      }\n      // If we encounter a real directory, then we don't need to append anymore.\n      addTrailingSlash = false;\n      // A current directory, which we can always drop.\n      if (piece === '.') continue;\n      // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (rel) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n        continue;\n      }\n      // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n      pieces[pointer++] = piece;\n      positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n  function resolve(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n      const baseUrl = parseUrl(base);\n      const baseType = baseUrl.type;\n      switch (inputType) {\n        case UrlType.Empty:\n          url.hash = baseUrl.hash;\n        // fall through\n        case UrlType.Hash:\n          url.query = baseUrl.query;\n        // fall through\n        case UrlType.Query:\n        case UrlType.RelativePath:\n          mergePaths(url, baseUrl);\n        // fall through\n        case UrlType.AbsolutePath:\n          // The host, user, and port are joined, you can't copy one without the others.\n          url.user = baseUrl.user;\n          url.host = baseUrl.host;\n          url.port = baseUrl.port;\n        // fall through\n        case UrlType.SchemeRelative:\n          // The input doesn't have a schema at least, so we need to copy at least that over.\n          url.scheme = baseUrl.scheme;\n      }\n      if (baseType > inputType) inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n      // This is impossible, because of the empty checks at the start of the function.\n      // case UrlType.Empty:\n      case UrlType.Hash:\n      case UrlType.Query:\n        return queryHash;\n      case UrlType.RelativePath:\n        {\n          // The first char is always a \"/\", and we need it to be relative.\n          const path = url.path.slice(1);\n          if (!path) return queryHash || '.';\n          if (isRelative(base || input) && !isRelative(path)) {\n            // If base started with a leading \".\", or there is no base and input started with a \".\",\n            // then we need to ensure that the relative path starts with a \".\". We don't know if\n            // relative starts with a \"..\", though, so check before prepending.\n            return './' + path + queryHash;\n          }\n          return path + queryHash;\n        }\n      case UrlType.AbsolutePath:\n        return url.path + queryHash;\n      default:\n        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n  }\n  return resolve;\n});","map":{"version":3,"names":["schemeRegex","urlRegex","fileRegex","UrlType","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","type","Absolute","parseUrl","url","SchemeRelative","AbsolutePath","Query","Hash","RelativePath","Empty","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","resolve","inputType","baseUrl","baseType","queryHash"],"sources":["D:\\WEB-PROJECT\\Schwarz\\frontend\\node_modules\\@jridgewell\\resolve-uri\\src\\resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nenum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}