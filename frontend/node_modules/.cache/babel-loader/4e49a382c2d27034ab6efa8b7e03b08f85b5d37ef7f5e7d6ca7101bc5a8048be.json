{"ast":null,"code":"/* eslint max-len: 0 */\n\nimport { File } from \"../index\";\nimport { flowAfterParseClassSuper, flowAfterParseVarHead, flowParseExportDeclaration, flowParseExportStar, flowParseIdentifierStatement, flowParseImportSpecifier, flowParseTypeAnnotation, flowParseTypeParameterDeclaration, flowShouldDisallowExportDefaultSpecifier, flowShouldParseExportDeclaration, flowShouldParseExportStar, flowStartParseFunctionParams, flowStartParseImportSpecifiers, flowTryParseExportDefaultExpression, flowTryParseStatement } from \"../plugins/flow\";\nimport { tsAfterParseClassSuper, tsAfterParseVarHead, tsIsDeclarationStart, tsParseExportDeclaration, tsParseExportSpecifier, tsParseIdentifierStatement, tsParseImportEqualsDeclaration, tsParseImportSpecifier, tsParseMaybeDecoratorArguments, tsParseModifiers, tsStartParseFunctionParams, tsTryParseClassMemberWithIsStatic, tsTryParseExport, tsTryParseExportDefaultExpression, tsTryParseStatementContent, tsTryParseTypeAnnotation, tsTryParseTypeParameters } from \"../plugins/typescript\";\nimport { eat, eatTypeToken, IdentifierRole, lookaheadType, lookaheadTypeAndKeyword, match, next, nextTokenStart, nextTokenStartSince, popTypeContext, pushTypeContext } from \"../tokenizer\";\nimport { ContextualKeyword } from \"../tokenizer/keywords\";\nimport { Scope } from \"../tokenizer/state\";\nimport { TokenType as tt } from \"../tokenizer/types\";\nimport { charCodes } from \"../util/charcodes\";\nimport { getNextContextId, input, isFlowEnabled, isTypeScriptEnabled, state } from \"./base\";\nimport { parseCallExpressionArguments, parseExprAtom, parseExpression, parseExprSubscripts, parseFunctionBodyAndFinish, parseIdentifier, parseMaybeAssign, parseMethod, parseObj, parseParenExpression, parsePropertyName } from \"./expression\";\nimport { parseBindingAtom, parseBindingIdentifier, parseBindingList, parseImportedIdentifier } from \"./lval\";\nimport { canInsertSemicolon, eatContextual, expect, expectContextual, hasFollowingLineBreak, hasPrecedingLineBreak, isContextual, isLineTerminator, isLookaheadContextual, semicolon, unexpected } from \"./util\";\nexport function parseTopLevel() {\n  parseBlockBody(tt.eof);\n  state.scopes.push(new Scope(0, state.tokens.length, true));\n  if (state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);\n  }\n  return new File(state.tokens, state.scopes);\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\nexport function parseStatement(declaration) {\n  if (isFlowEnabled) {\n    if (flowTryParseStatement()) {\n      return;\n    }\n  }\n  if (match(tt.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n}\nfunction parseStatementContent(declaration) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseStatementContent()) {\n      return;\n    }\n  }\n  const starttype = state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case tt._break:\n    case tt._continue:\n      parseBreakContinueStatement();\n      return;\n    case tt._debugger:\n      parseDebuggerStatement();\n      return;\n    case tt._do:\n      parseDoStatement();\n      return;\n    case tt._for:\n      parseForStatement();\n      return;\n    case tt._function:\n      if (lookaheadType() === tt.dot) break;\n      if (!declaration) unexpected();\n      parseFunctionStatement();\n      return;\n    case tt._class:\n      if (!declaration) unexpected();\n      parseClass(true);\n      return;\n    case tt._if:\n      parseIfStatement();\n      return;\n    case tt._return:\n      parseReturnStatement();\n      return;\n    case tt._switch:\n      parseSwitchStatement();\n      return;\n    case tt._throw:\n      parseThrowStatement();\n      return;\n    case tt._try:\n      parseTryStatement();\n      return;\n    case tt._let:\n    case tt._const:\n      if (!declaration) unexpected();\n    // NOTE: falls through to _var\n\n    case tt._var:\n      parseVarStatement(starttype !== tt._var);\n      return;\n    case tt._while:\n      parseWhileStatement();\n      return;\n    case tt.braceL:\n      parseBlock();\n      return;\n    case tt.semi:\n      parseEmptyStatement();\n      return;\n    case tt._export:\n    case tt._import:\n      {\n        const nextType = lookaheadType();\n        if (nextType === tt.parenL || nextType === tt.dot) {\n          break;\n        }\n        next();\n        if (starttype === tt._import) {\n          parseImport();\n        } else {\n          parseExport();\n        }\n        return;\n      }\n    case tt.name:\n      if (state.contextualKeyword === ContextualKeyword._async) {\n        const functionStart = state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = state.snapshot();\n        next();\n        if (match(tt._function) && !canInsertSemicolon()) {\n          expect(tt._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          state.restoreFromSnapshot(snapshot);\n        }\n      } else if (state.contextualKeyword === ContextualKeyword._using && !hasFollowingLineBreak() &&\n      // Statements like `using[0]` and `using in foo` aren't actual using\n      // declarations.\n      lookaheadType() === tt.name) {\n        parseVarStatement(true);\n        return;\n      } else if (startsAwaitUsing()) {\n        expectContextual(ContextualKeyword._await);\n        parseVarStatement(true);\n        return;\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = state.tokens.length;\n  parseExpression();\n  let simpleName = null;\n  if (state.tokens.length === initialTokensLength + 1) {\n    const token = state.tokens[state.tokens.length - 1];\n    if (token.type === tt.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    semicolon();\n    return;\n  }\n  if (eat(tt.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\n\n/**\n * Determine if we're positioned at an `await using` declaration.\n *\n * Note that this can happen either in place of a regular variable declaration\n * or in a loop body, and in both places, there are similar-looking cases where\n * we need to return false.\n *\n * Examples returning true:\n * await using foo = bar();\n * for (await using a of b) {}\n *\n * Examples returning false:\n * await using\n * await using + 1\n * await using instanceof T\n * for (await using;;) {}\n *\n * For now, we early return if we don't see `await`, then do a simple\n * backtracking-based lookahead for the `using` and identifier tokens. In the\n * future, this could be optimized with a character-based approach.\n */\nfunction startsAwaitUsing() {\n  if (!isContextual(ContextualKeyword._await)) {\n    return false;\n  }\n  const snapshot = state.snapshot();\n  // await\n  next();\n  if (!isContextual(ContextualKeyword._using) || hasPrecedingLineBreak()) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n  // using\n  next();\n  if (!match(tt.name) || hasPrecedingLineBreak()) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n  state.restoreFromSnapshot(snapshot);\n  return true;\n}\nexport function parseDecorators() {\n  while (match(tt.at)) {\n    parseDecorator();\n  }\n}\nfunction parseDecorator() {\n  next();\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  } else {\n    parseIdentifier();\n    while (eat(tt.dot)) {\n      parseIdentifier();\n    }\n    parseMaybeDecoratorArguments();\n  }\n}\nfunction parseMaybeDecoratorArguments() {\n  if (isTypeScriptEnabled) {\n    tsParseMaybeDecoratorArguments();\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\nexport function baseParseMaybeDecoratorArguments() {\n  if (eat(tt.parenL)) {\n    parseCallExpressionArguments();\n  }\n}\nfunction parseBreakContinueStatement() {\n  next();\n  if (!isLineTerminator()) {\n    parseIdentifier();\n    semicolon();\n  }\n}\nfunction parseDebuggerStatement() {\n  next();\n  semicolon();\n}\nfunction parseDoStatement() {\n  next();\n  parseStatement(false);\n  expect(tt._while);\n  parseParenExpression();\n  eat(tt.semi);\n}\nfunction parseForStatement() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\n/**\n * Determine if this token is a `using` declaration (explicit resource\n * management) as part of a loop.\n * https://github.com/tc39/proposal-explicit-resource-management\n */\nfunction isUsingInLoop() {\n  if (!isContextual(ContextualKeyword._using)) {\n    return false;\n  }\n  // This must be `for (using of`, where `using` is the name of the loop\n  // variable.\n  if (isLookaheadContextual(ContextualKeyword._of)) {\n    return false;\n  }\n  return true;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  next();\n  let forAwait = false;\n  if (isContextual(ContextualKeyword._await)) {\n    forAwait = true;\n    next();\n  }\n  expect(tt.parenL);\n  if (match(tt.semi)) {\n    if (forAwait) {\n      unexpected();\n    }\n    parseFor();\n    return;\n  }\n  const isAwaitUsing = startsAwaitUsing();\n  if (isAwaitUsing || match(tt._var) || match(tt._let) || match(tt._const) || isUsingInLoop()) {\n    if (isAwaitUsing) {\n      expectContextual(ContextualKeyword._await);\n    }\n    next();\n    parseVar(true, state.type !== tt._var);\n    if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n  parseExpression(true);\n  if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    unexpected();\n  }\n  parseFor();\n}\nfunction parseFunctionStatement() {\n  const functionStart = state.start;\n  next();\n  parseFunction(functionStart, true);\n}\nfunction parseIfStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n  if (eat(tt._else)) {\n    parseStatement(false);\n  }\n}\nfunction parseReturnStatement() {\n  next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!isLineTerminator()) {\n    parseExpression();\n    semicolon();\n  }\n}\nfunction parseSwitchStatement() {\n  next();\n  parseParenExpression();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  expect(tt.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._case) || match(tt._default)) {\n      const isCase = match(tt._case);\n      next();\n      if (isCase) {\n        parseExpression();\n      }\n      expect(tt.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  next(); // Closing brace\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\nfunction parseThrowStatement() {\n  next();\n  parseExpression();\n  semicolon();\n}\nfunction parseCatchClauseParam() {\n  parseBindingAtom(true /* isBlockScope */);\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeAnnotation();\n  }\n}\nfunction parseTryStatement() {\n  next();\n  parseBlock();\n  if (match(tt._catch)) {\n    next();\n    let catchBindingStartTokenIndex = null;\n    if (match(tt.parenL)) {\n      state.scopeDepth++;\n      catchBindingStartTokenIndex = state.tokens.length;\n      expect(tt.parenL);\n      parseCatchClauseParam();\n      expect(tt.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = state.tokens.length;\n      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));\n      state.scopeDepth--;\n    }\n  }\n  if (eat(tt._finally)) {\n    parseBlock();\n  }\n}\nexport function parseVarStatement(isBlockScope) {\n  next();\n  parseVar(false, isBlockScope);\n  semicolon();\n}\nfunction parseWhileStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n}\nfunction parseEmptyStatement() {\n  next();\n}\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (isTypeScriptEnabled) {\n    tsParseIdentifierStatement(contextualKeyword);\n  } else if (isFlowEnabled) {\n    flowParseIdentifierStatement(contextualKeyword);\n  } else {\n    semicolon();\n  }\n}\n\n// Parse a semicolon-enclosed block of statements.\nexport function parseBlock(isFunctionScope = false, contextId = 0) {\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  expect(tt.braceL);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(tt.braceR);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));\n  state.scopeDepth--;\n}\nexport function parseBlockBody(end) {\n  while (!eat(end) && !state.error) {\n    parseStatement(true);\n  }\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  expect(tt.semi);\n  if (!match(tt.semi)) {\n    parseExpression();\n  }\n  expect(tt.semi);\n  if (!match(tt.parenR)) {\n    parseExpression();\n  }\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    eatContextual(ContextualKeyword._of);\n  } else {\n    next();\n  }\n  parseExpression();\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, isBlockScope) {\n  while (true) {\n    parseVarHead(isBlockScope);\n    if (eat(tt.eq)) {\n      const eqIndex = state.tokens.length - 1;\n      parseMaybeAssign(isFor);\n      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n    }\n    if (!eat(tt.comma)) {\n      break;\n    }\n  }\n}\nfunction parseVarHead(isBlockScope) {\n  parseBindingAtom(isBlockScope);\n  if (isTypeScriptEnabled) {\n    tsAfterParseVarHead();\n  } else if (isFlowEnabled) {\n    flowAfterParseVarHead();\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseFunction(functionStart, isStatement, optionalId = false) {\n  if (match(tt.star)) {\n    next();\n  }\n  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {\n    unexpected();\n  }\n  let nameScopeStartTokenIndex = null;\n  if (match(tt.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = state.tokens.length;\n      state.scopeDepth++;\n    }\n    parseBindingIdentifier(false);\n  }\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  parseFunctionParams();\n  parseFunctionBodyAndFinish(functionStart);\n  const endTokenIndex = state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));\n    state.scopeDepth--;\n  }\n}\nexport function parseFunctionParams(allowModifiers = false, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsStartParseFunctionParams();\n  } else if (isFlowEnabled) {\n    flowStartParseFunctionParams();\n  }\n  expect(tt.parenL);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n  parseBindingList(tt.parenR, false /* isBlockScope */, false /* allowEmpty */, allowModifiers, funcContextId);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = getNextContextId();\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  state.tokens[state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = state.tokens.length;\n    state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = state.tokens.length;\n  parseClassBody(contextId);\n  if (state.error) {\n    return;\n  }\n  state.tokens[openBraceIndex].contextId = contextId;\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = state.tokens.length;\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));\n    state.scopeDepth--;\n  }\n}\nfunction isClassProperty() {\n  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);\n}\nfunction isClassMethod() {\n  return match(tt.parenL) || match(tt.lessThan);\n}\nfunction parseClassBody(classContextId) {\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (eat(tt.semi)) {\n      continue;\n    }\n    if (match(tt.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\nfunction parseClassMember(memberStart, classContextId) {\n  if (isTypeScriptEnabled) {\n    tsParseModifiers([ContextualKeyword._declare, ContextualKeyword._public, ContextualKeyword._protected, ContextualKeyword._private, ContextualKeyword._override]);\n  }\n  let isStatic = false;\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {\n    parseIdentifier(); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    state.tokens[state.tokens.length - 1].type = tt._static;\n    isStatic = true;\n    if (match(tt.braceL)) {\n      // This is a static block. Mark the word \"static\" with the class context ID for class element\n      // detection and parse as a regular block.\n      state.tokens[state.tokens.length - 1].contextId = classContextId;\n      parseBlock();\n      return;\n    }\n  }\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\nfunction parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseClassMemberWithIsStatic(isStatic)) {\n      return;\n    }\n  }\n  if (eat(tt.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = state.tokens[state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {\n    state.tokens[state.tokens.length - 1].type = tt._async;\n    // an async method\n    const isGenerator = match(tt.star);\n    if (isGenerator) {\n      next();\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if ((token.contextualKeyword === ContextualKeyword._get || token.contextualKeyword === ContextualKeyword._set) && !(isLineTerminator() && match(tt.star))) {\n    if (token.contextualKeyword === ContextualKeyword._get) {\n      state.tokens[state.tokens.length - 1].type = tt._get;\n    } else {\n      state.tokens[state.tokens.length - 1].type = tt._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */false);\n  } else if (token.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {\n    parseClassPropertyName(classContextId);\n    parseClassProperty();\n  } else if (isLineTerminator()) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    unexpected();\n  }\n}\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n  parseMethod(functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\nexport function parseClassPropertyName(classContextId) {\n  parsePropertyName(classContextId);\n}\nexport function parsePostMemberNameModifiers() {\n  if (isTypeScriptEnabled) {\n    const oldIsType = pushTypeContext(0);\n    eat(tt.question);\n    popTypeContext(oldIsType);\n  }\n}\nexport function parseClassProperty() {\n  if (isTypeScriptEnabled) {\n    eatTypeToken(tt.bang);\n    tsTryParseTypeAnnotation();\n  } else if (isFlowEnabled) {\n    if (match(tt.colon)) {\n      flowParseTypeAnnotation();\n    }\n  }\n  if (match(tt.eq)) {\n    const equalsTokenIndex = state.tokens.length;\n    next();\n    parseMaybeAssign();\n    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;\n  }\n  semicolon();\n}\nfunction parseClassId(isStatement, optionalId = false) {\n  if (isTypeScriptEnabled && (!isStatement || optionalId) && isContextual(ContextualKeyword._implements)) {\n    return;\n  }\n  if (match(tt.name)) {\n    parseBindingIdentifier(true);\n  }\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (eat(tt._extends)) {\n    parseExprSubscripts();\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (isTypeScriptEnabled) {\n    tsAfterParseClassSuper(hasSuper);\n  } else if (isFlowEnabled) {\n    flowAfterParseClassSuper(hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\nexport function parseExport() {\n  const exportIndex = state.tokens.length - 1;\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExport()) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    parseIdentifier();\n    if (match(tt.comma) && lookaheadType() === tt.star) {\n      expect(tt.comma);\n      expect(tt.star);\n      expectContextual(ContextualKeyword._as);\n      parseIdentifier();\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (eat(tt._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;\n}\nfunction parseExportDefaultExpression() {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  if (isFlowEnabled) {\n    if (flowTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  const functionStart = state.start;\n  if (eat(tt._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === tt._function) {\n    // async function declaration\n    eatContextual(ContextualKeyword._async);\n    eat(tt._function);\n    parseFunction(functionStart, true, true);\n  } else if (match(tt._class)) {\n    parseClass(true, true);\n  } else if (match(tt.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    parseMaybeAssign();\n    semicolon();\n  }\n}\nfunction parseExportDeclaration() {\n  if (isTypeScriptEnabled) {\n    tsParseExportDeclaration();\n  } else if (isFlowEnabled) {\n    flowParseExportDeclaration();\n  } else {\n    parseStatement(true);\n  }\n}\nfunction isExportDefaultSpecifier() {\n  if (isTypeScriptEnabled && tsIsDeclarationStart()) {\n    return false;\n  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {\n    return false;\n  }\n  if (match(tt.name)) {\n    return state.contextualKeyword !== ContextualKeyword._async;\n  }\n  if (!match(tt._default)) {\n    return false;\n  }\n  const _next = nextTokenStart();\n  const lookahead = lookaheadTypeAndKeyword();\n  const hasFrom = lookahead.type === tt.name && lookahead.contextualKeyword === ContextualKeyword._from;\n  if (lookahead.type === tt.comma) {\n    return true;\n  }\n  // lookahead again when `export default from` is seen\n  if (hasFrom) {\n    const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));\n    return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;\n  }\n  return false;\n}\nfunction parseExportSpecifiersMaybe() {\n  if (eat(tt.comma)) {\n    parseExportSpecifiers();\n  }\n}\nexport function parseExportFrom() {\n  if (eatContextual(ContextualKeyword._from)) {\n    parseExprAtom();\n    maybeParseImportAttributes();\n  }\n  semicolon();\n}\nfunction shouldParseExportStar() {\n  if (isFlowEnabled) {\n    return flowShouldParseExportStar();\n  } else {\n    return match(tt.star);\n  }\n}\nfunction parseExportStar() {\n  if (isFlowEnabled) {\n    flowParseExportStar();\n  } else {\n    baseParseExportStar();\n  }\n}\nexport function baseParseExportStar() {\n  expect(tt.star);\n  if (isContextual(ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n}\nfunction parseExportNamespace() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt._as;\n  parseIdentifier();\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\nfunction shouldParseExportDeclaration() {\n  return isTypeScriptEnabled && tsIsDeclarationStart() || isFlowEnabled && flowShouldParseExportDeclaration() || state.type === tt._var || state.type === tt._const || state.type === tt._let || state.type === tt._function || state.type === tt._class || isContextual(ContextualKeyword._async) || match(tt.at);\n}\n\n// Parses a comma-separated list of module exports.\nexport function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    parseExportSpecifier();\n  }\n}\nfunction parseExportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseExportSpecifier();\n    return;\n  }\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n  if (eatContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n  }\n}\n\n/**\n * Starting at the `module` token in an import, determine if it was truly an\n * import reflection token or just looks like one.\n *\n * Returns true for:\n * import module foo from \"foo\";\n * import module from from \"foo\";\n *\n * Returns false for:\n * import module from \"foo\";\n * import module, {bar} from \"foo\";\n */\nfunction isImportReflection() {\n  const snapshot = state.snapshot();\n  expectContextual(ContextualKeyword._module);\n  if (eatContextual(ContextualKeyword._from)) {\n    if (isContextual(ContextualKeyword._from)) {\n      state.restoreFromSnapshot(snapshot);\n      return true;\n    } else {\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (match(tt.comma)) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return true;\n  }\n}\n\n/**\n * Eat the \"module\" token from the import reflection proposal.\n * https://github.com/tc39/proposal-import-reflection\n */\nfunction parseMaybeImportReflection() {\n  // isImportReflection does snapshot/restore, so only run it if we see the word\n  // \"module\".\n  if (isContextual(ContextualKeyword._module) && isImportReflection()) {\n    next();\n  }\n}\n\n// Parses import declaration.\n\nexport function parseImport() {\n  if (isTypeScriptEnabled && match(tt.name) && lookaheadType() === tt.eq) {\n    tsParseImportEqualsDeclaration();\n    return;\n  }\n  if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {\n    const lookahead = lookaheadTypeAndKeyword();\n    if (lookahead.type === tt.name && lookahead.contextualKeyword !== ContextualKeyword._from) {\n      // One of these `import type` cases:\n      // import type T = require('T');\n      // import type A from 'A';\n      expectContextual(ContextualKeyword._type);\n      if (lookaheadType() === tt.eq) {\n        tsParseImportEqualsDeclaration();\n        return;\n      }\n      // If this is an `import type...from` statement, then we already ate the\n      // type token, so proceed to the regular import parser.\n    } else if (lookahead.type === tt.star || lookahead.type === tt.braceL) {\n      // One of these `import type` cases, in which case we can eat the type token\n      // and proceed as normal:\n      // import type * as A from 'A';\n      // import type {a} from 'A';\n      expectContextual(ContextualKeyword._type);\n    }\n    // Otherwise, we are importing the name \"type\".\n  }\n\n  // import '...'\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseMaybeImportReflection();\n    parseImportSpecifiers();\n    expectContextual(ContextualKeyword._from);\n    parseExprAtom();\n  }\n  maybeParseImportAttributes();\n  semicolon();\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return match(tt.name);\n}\nfunction parseImportSpecifierLocal() {\n  parseImportedIdentifier();\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (isFlowEnabled) {\n    flowStartParseImportSpecifiers();\n  }\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n    if (!eat(tt.comma)) return;\n  }\n  if (match(tt.star)) {\n    next();\n    expectContextual(ContextualKeyword._as);\n    parseImportSpecifierLocal();\n    return;\n  }\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (eat(tt.colon)) {\n        unexpected(\"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\");\n      }\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    parseImportSpecifier();\n  }\n}\nfunction parseImportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseImportSpecifier();\n    return;\n  }\n  if (isFlowEnabled) {\n    flowParseImportSpecifier();\n    return;\n  }\n  parseImportedIdentifier();\n  if (isContextual(ContextualKeyword._as)) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;\n    next();\n    parseImportedIdentifier();\n  }\n}\n\n/**\n * Parse import attributes like `with {type: \"json\"}`, or the legacy form\n * `assert {type: \"json\"}`.\n *\n * Import attributes technically have their own syntax, but are always parseable\n * as a plain JS object, so just do that for simplicity.\n */\nfunction maybeParseImportAttributes() {\n  if (match(tt._with) || isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak()) {\n    next();\n    parseObj(false, false);\n  }\n}","map":{"version":3,"names":["File","flowAfterParseClassSuper","flowAfterParseVarHead","flowParseExportDeclaration","flowParseExportStar","flowParseIdentifierStatement","flowParseImportSpecifier","flowParseTypeAnnotation","flowParseTypeParameterDeclaration","flowShouldDisallowExportDefaultSpecifier","flowShouldParseExportDeclaration","flowShouldParseExportStar","flowStartParseFunctionParams","flowStartParseImportSpecifiers","flowTryParseExportDefaultExpression","flowTryParseStatement","tsAfterParseClassSuper","tsAfterParseVarHead","tsIsDeclarationStart","tsParseExportDeclaration","tsParseExportSpecifier","tsParseIdentifierStatement","tsParseImportEqualsDeclaration","tsParseImportSpecifier","tsParseMaybeDecoratorArguments","tsParseModifiers","tsStartParseFunctionParams","tsTryParseClassMemberWithIsStatic","tsTryParseExport","tsTryParseExportDefaultExpression","tsTryParseStatementContent","tsTryParseTypeAnnotation","tsTryParseTypeParameters","eat","eatTypeToken","IdentifierRole","lookaheadType","lookaheadTypeAndKeyword","match","next","nextTokenStart","nextTokenStartSince","popTypeContext","pushTypeContext","ContextualKeyword","Scope","TokenType","tt","charCodes","getNextContextId","input","isFlowEnabled","isTypeScriptEnabled","state","parseCallExpressionArguments","parseExprAtom","parseExpression","parseExprSubscripts","parseFunctionBodyAndFinish","parseIdentifier","parseMaybeAssign","parseMethod","parseObj","parseParenExpression","parsePropertyName","parseBindingAtom","parseBindingIdentifier","parseBindingList","parseImportedIdentifier","canInsertSemicolon","eatContextual","expect","expectContextual","hasFollowingLineBreak","hasPrecedingLineBreak","isContextual","isLineTerminator","isLookaheadContextual","semicolon","unexpected","parseTopLevel","parseBlockBody","eof","scopes","push","tokens","length","scopeDepth","Error","parseStatement","declaration","at","parseDecorators","parseStatementContent","starttype","type","_break","_continue","parseBreakContinueStatement","_debugger","parseDebuggerStatement","_do","parseDoStatement","_for","parseForStatement","_function","dot","parseFunctionStatement","_class","parseClass","_if","parseIfStatement","_return","parseReturnStatement","_switch","parseSwitchStatement","_throw","parseThrowStatement","_try","parseTryStatement","_let","_const","_var","parseVarStatement","_while","parseWhileStatement","braceL","parseBlock","semi","parseEmptyStatement","_export","_import","nextType","parenL","parseImport","parseExport","name","contextualKeyword","_async","functionStart","start","snapshot","parseFunction","restoreFromSnapshot","_using","startsAwaitUsing","_await","initialTokensLength","simpleName","token","colon","parseLabeledStatement","parseIdentifierStatement","parseDecorator","parenR","parseMaybeDecoratorArguments","baseParseMaybeDecoratorArguments","startTokenIndex","parseAmbiguousForStatement","endTokenIndex","isUsingInLoop","_of","forAwait","parseFor","isAwaitUsing","parseVar","_in","parseForIn","_else","braceR","error","_case","_default","isCase","parseCatchClauseParam","_catch","catchBindingStartTokenIndex","_finally","isBlockScope","isFunctionScope","contextId","end","isFor","parseVarHead","eq","eqIndex","rhsEndIndex","comma","isStatement","optionalId","star","_yield","nameScopeStartTokenIndex","parseFunctionParams","allowModifiers","funcContextId","isExpression","parseClassId","parseClassSuper","openBraceIndex","parseClassBody","isClassProperty","bang","isClassMethod","lessThan","classContextId","memberStart","parseClassMember","_declare","_public","_protected","_private","_override","isStatic","_static","parseClassMethod","parseClassProperty","parseClassMemberWithIsStatic","parseClassPropertyName","isConstructor","_constructor","parsePostMemberNameModifiers","isGenerator","_get","_set","_accessor","oldIsType","question","equalsTokenIndex","_implements","hasSuper","_extends","exportIndex","shouldParseExportStar","parseExportStar","isExportDefaultSpecifier","_as","parseExportSpecifiersMaybe","parseExportFrom","parseExportDefaultExpression","shouldParseExportDeclaration","parseExportDeclaration","parseExportSpecifiers","_next","lookahead","hasFrom","_from","nextAfterFrom","charCodeAt","quotationMark","apostrophe","maybeParseImportAttributes","baseParseExportStar","parseExportNamespace","first","parseExportSpecifier","identifierRole","ExportAccess","isImportReflection","_module","parseMaybeImportReflection","_type","string","parseImportSpecifiers","shouldParseDefaultImport","parseImportSpecifierLocal","parseImportSpecifier","ImportAccess","_with","_assert"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/traverser/statement.js"],"sourcesContent":["/* eslint max-len: 0 */\n\nimport {File} from \"../index\";\nimport {\n  flowAfterParseClassSuper,\n  flowAfterParseVarHead,\n  flowParseExportDeclaration,\n  flowParseExportStar,\n  flowParseIdentifierStatement,\n  flowParseImportSpecifier,\n  flowParseTypeAnnotation,\n  flowParseTypeParameterDeclaration,\n  flowShouldDisallowExportDefaultSpecifier,\n  flowShouldParseExportDeclaration,\n  flowShouldParseExportStar,\n  flowStartParseFunctionParams,\n  flowStartParseImportSpecifiers,\n  flowTryParseExportDefaultExpression,\n  flowTryParseStatement,\n} from \"../plugins/flow\";\nimport {\n  tsAfterParseClassSuper,\n  tsAfterParseVarHead,\n  tsIsDeclarationStart,\n  tsParseExportDeclaration,\n  tsParseExportSpecifier,\n  tsParseIdentifierStatement,\n  tsParseImportEqualsDeclaration,\n  tsParseImportSpecifier,\n  tsParseMaybeDecoratorArguments,\n  tsParseModifiers,\n  tsStartParseFunctionParams,\n  tsTryParseClassMemberWithIsStatic,\n  tsTryParseExport,\n  tsTryParseExportDefaultExpression,\n  tsTryParseStatementContent,\n  tsTryParseTypeAnnotation,\n  tsTryParseTypeParameters,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  eatTypeToken,\n  IdentifierRole,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  nextTokenStart,\n  nextTokenStartSince,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport { TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {getNextContextId, input, isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseExprSubscripts,\n  parseFunctionBodyAndFinish,\n  parseIdentifier,\n  parseMaybeAssign,\n  parseMethod,\n  parseObj,\n  parseParenExpression,\n  parsePropertyName,\n} from \"./expression\";\nimport {\n  parseBindingAtom,\n  parseBindingIdentifier,\n  parseBindingList,\n  parseImportedIdentifier,\n} from \"./lval\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasFollowingLineBreak,\n  hasPrecedingLineBreak,\n  isContextual,\n  isLineTerminator,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"./util\";\n\nexport function parseTopLevel() {\n  parseBlockBody(tt.eof);\n  state.scopes.push(new Scope(0, state.tokens.length, true));\n  if (state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);\n  }\n  return new File(state.tokens, state.scopes);\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\nexport function parseStatement(declaration) {\n  if (isFlowEnabled) {\n    if (flowTryParseStatement()) {\n      return;\n    }\n  }\n  if (match(tt.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n}\n\nfunction parseStatementContent(declaration) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseStatementContent()) {\n      return;\n    }\n  }\n\n  const starttype = state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case tt._break:\n    case tt._continue:\n      parseBreakContinueStatement();\n      return;\n    case tt._debugger:\n      parseDebuggerStatement();\n      return;\n    case tt._do:\n      parseDoStatement();\n      return;\n    case tt._for:\n      parseForStatement();\n      return;\n    case tt._function:\n      if (lookaheadType() === tt.dot) break;\n      if (!declaration) unexpected();\n      parseFunctionStatement();\n      return;\n\n    case tt._class:\n      if (!declaration) unexpected();\n      parseClass(true);\n      return;\n\n    case tt._if:\n      parseIfStatement();\n      return;\n    case tt._return:\n      parseReturnStatement();\n      return;\n    case tt._switch:\n      parseSwitchStatement();\n      return;\n    case tt._throw:\n      parseThrowStatement();\n      return;\n    case tt._try:\n      parseTryStatement();\n      return;\n\n    case tt._let:\n    case tt._const:\n      if (!declaration) unexpected(); // NOTE: falls through to _var\n\n    case tt._var:\n      parseVarStatement(starttype !== tt._var);\n      return;\n\n    case tt._while:\n      parseWhileStatement();\n      return;\n    case tt.braceL:\n      parseBlock();\n      return;\n    case tt.semi:\n      parseEmptyStatement();\n      return;\n    case tt._export:\n    case tt._import: {\n      const nextType = lookaheadType();\n      if (nextType === tt.parenL || nextType === tt.dot) {\n        break;\n      }\n      next();\n      if (starttype === tt._import) {\n        parseImport();\n      } else {\n        parseExport();\n      }\n      return;\n    }\n    case tt.name:\n      if (state.contextualKeyword === ContextualKeyword._async) {\n        const functionStart = state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = state.snapshot();\n        next();\n        if (match(tt._function) && !canInsertSemicolon()) {\n          expect(tt._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          state.restoreFromSnapshot(snapshot);\n        }\n      } else if (\n        state.contextualKeyword === ContextualKeyword._using &&\n        !hasFollowingLineBreak() &&\n        // Statements like `using[0]` and `using in foo` aren't actual using\n        // declarations.\n        lookaheadType() === tt.name\n      ) {\n        parseVarStatement(true);\n        return;\n      } else if (startsAwaitUsing()) {\n        expectContextual(ContextualKeyword._await);\n        parseVarStatement(true);\n        return;\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = state.tokens.length;\n  parseExpression();\n  let simpleName = null;\n  if (state.tokens.length === initialTokensLength + 1) {\n    const token = state.tokens[state.tokens.length - 1];\n    if (token.type === tt.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    semicolon();\n    return;\n  }\n  if (eat(tt.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\n\n/**\n * Determine if we're positioned at an `await using` declaration.\n *\n * Note that this can happen either in place of a regular variable declaration\n * or in a loop body, and in both places, there are similar-looking cases where\n * we need to return false.\n *\n * Examples returning true:\n * await using foo = bar();\n * for (await using a of b) {}\n *\n * Examples returning false:\n * await using\n * await using + 1\n * await using instanceof T\n * for (await using;;) {}\n *\n * For now, we early return if we don't see `await`, then do a simple\n * backtracking-based lookahead for the `using` and identifier tokens. In the\n * future, this could be optimized with a character-based approach.\n */\nfunction startsAwaitUsing() {\n  if (!isContextual(ContextualKeyword._await)) {\n    return false;\n  }\n  const snapshot = state.snapshot();\n  // await\n  next();\n  if (!isContextual(ContextualKeyword._using) || hasPrecedingLineBreak()) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n  // using\n  next();\n  if (!match(tt.name) || hasPrecedingLineBreak()) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n  state.restoreFromSnapshot(snapshot);\n  return true;\n}\n\nexport function parseDecorators() {\n  while (match(tt.at)) {\n    parseDecorator();\n  }\n}\n\nfunction parseDecorator() {\n  next();\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  } else {\n    parseIdentifier();\n    while (eat(tt.dot)) {\n      parseIdentifier();\n    }\n    parseMaybeDecoratorArguments();\n  }\n}\n\nfunction parseMaybeDecoratorArguments() {\n  if (isTypeScriptEnabled) {\n    tsParseMaybeDecoratorArguments();\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\n\nexport function baseParseMaybeDecoratorArguments() {\n  if (eat(tt.parenL)) {\n    parseCallExpressionArguments();\n  }\n}\n\nfunction parseBreakContinueStatement() {\n  next();\n  if (!isLineTerminator()) {\n    parseIdentifier();\n    semicolon();\n  }\n}\n\nfunction parseDebuggerStatement() {\n  next();\n  semicolon();\n}\n\nfunction parseDoStatement() {\n  next();\n  parseStatement(false);\n  expect(tt._while);\n  parseParenExpression();\n  eat(tt.semi);\n}\n\nfunction parseForStatement() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\n/**\n * Determine if this token is a `using` declaration (explicit resource\n * management) as part of a loop.\n * https://github.com/tc39/proposal-explicit-resource-management\n */\nfunction isUsingInLoop() {\n  if (!isContextual(ContextualKeyword._using)) {\n    return false;\n  }\n  // This must be `for (using of`, where `using` is the name of the loop\n  // variable.\n  if (isLookaheadContextual(ContextualKeyword._of)) {\n    return false;\n  }\n  return true;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  next();\n\n  let forAwait = false;\n  if (isContextual(ContextualKeyword._await)) {\n    forAwait = true;\n    next();\n  }\n  expect(tt.parenL);\n\n  if (match(tt.semi)) {\n    if (forAwait) {\n      unexpected();\n    }\n    parseFor();\n    return;\n  }\n\n  const isAwaitUsing = startsAwaitUsing();\n  if (isAwaitUsing || match(tt._var) || match(tt._let) || match(tt._const) || isUsingInLoop()) {\n    if (isAwaitUsing) {\n      expectContextual(ContextualKeyword._await);\n    }\n    next();\n    parseVar(true, state.type !== tt._var);\n    if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n\n  parseExpression(true);\n  if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    unexpected();\n  }\n  parseFor();\n}\n\nfunction parseFunctionStatement() {\n  const functionStart = state.start;\n  next();\n  parseFunction(functionStart, true);\n}\n\nfunction parseIfStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n  if (eat(tt._else)) {\n    parseStatement(false);\n  }\n}\n\nfunction parseReturnStatement() {\n  next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!isLineTerminator()) {\n    parseExpression();\n    semicolon();\n  }\n}\n\nfunction parseSwitchStatement() {\n  next();\n  parseParenExpression();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  expect(tt.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._case) || match(tt._default)) {\n      const isCase = match(tt._case);\n      next();\n      if (isCase) {\n        parseExpression();\n      }\n      expect(tt.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  next(); // Closing brace\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\nfunction parseThrowStatement() {\n  next();\n  parseExpression();\n  semicolon();\n}\n\nfunction parseCatchClauseParam() {\n  parseBindingAtom(true /* isBlockScope */);\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeAnnotation();\n  }\n}\n\nfunction parseTryStatement() {\n  next();\n\n  parseBlock();\n\n  if (match(tt._catch)) {\n    next();\n    let catchBindingStartTokenIndex = null;\n    if (match(tt.parenL)) {\n      state.scopeDepth++;\n      catchBindingStartTokenIndex = state.tokens.length;\n      expect(tt.parenL);\n      parseCatchClauseParam();\n      expect(tt.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = state.tokens.length;\n      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));\n      state.scopeDepth--;\n    }\n  }\n  if (eat(tt._finally)) {\n    parseBlock();\n  }\n}\n\nexport function parseVarStatement(isBlockScope) {\n  next();\n  parseVar(false, isBlockScope);\n  semicolon();\n}\n\nfunction parseWhileStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n}\n\nfunction parseEmptyStatement() {\n  next();\n}\n\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (isTypeScriptEnabled) {\n    tsParseIdentifierStatement(contextualKeyword);\n  } else if (isFlowEnabled) {\n    flowParseIdentifierStatement(contextualKeyword);\n  } else {\n    semicolon();\n  }\n}\n\n// Parse a semicolon-enclosed block of statements.\nexport function parseBlock(isFunctionScope = false, contextId = 0) {\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  expect(tt.braceL);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(tt.braceR);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));\n  state.scopeDepth--;\n}\n\nexport function parseBlockBody(end) {\n  while (!eat(end) && !state.error) {\n    parseStatement(true);\n  }\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  expect(tt.semi);\n  if (!match(tt.semi)) {\n    parseExpression();\n  }\n  expect(tt.semi);\n  if (!match(tt.parenR)) {\n    parseExpression();\n  }\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    eatContextual(ContextualKeyword._of);\n  } else {\n    next();\n  }\n  parseExpression();\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, isBlockScope) {\n  while (true) {\n    parseVarHead(isBlockScope);\n    if (eat(tt.eq)) {\n      const eqIndex = state.tokens.length - 1;\n      parseMaybeAssign(isFor);\n      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n    }\n    if (!eat(tt.comma)) {\n      break;\n    }\n  }\n}\n\nfunction parseVarHead(isBlockScope) {\n  parseBindingAtom(isBlockScope);\n  if (isTypeScriptEnabled) {\n    tsAfterParseVarHead();\n  } else if (isFlowEnabled) {\n    flowAfterParseVarHead();\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseFunction(\n  functionStart,\n  isStatement,\n  optionalId = false,\n) {\n  if (match(tt.star)) {\n    next();\n  }\n\n  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {\n    unexpected();\n  }\n\n  let nameScopeStartTokenIndex = null;\n\n  if (match(tt.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = state.tokens.length;\n      state.scopeDepth++;\n    }\n    parseBindingIdentifier(false);\n  }\n\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  parseFunctionParams();\n  parseFunctionBodyAndFinish(functionStart);\n  const endTokenIndex = state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));\n    state.scopeDepth--;\n  }\n}\n\nexport function parseFunctionParams(\n  allowModifiers = false,\n  funcContextId = 0,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseFunctionParams();\n  } else if (isFlowEnabled) {\n    flowStartParseFunctionParams();\n  }\n\n  expect(tt.parenL);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n  parseBindingList(\n    tt.parenR,\n    false /* isBlockScope */,\n    false /* allowEmpty */,\n    allowModifiers,\n    funcContextId,\n  );\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = getNextContextId();\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  state.tokens[state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = state.tokens.length;\n    state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = state.tokens.length;\n  parseClassBody(contextId);\n  if (state.error) {\n    return;\n  }\n  state.tokens[openBraceIndex].contextId = contextId;\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = state.tokens.length;\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));\n    state.scopeDepth--;\n  }\n}\n\nfunction isClassProperty() {\n  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);\n}\n\nfunction isClassMethod() {\n  return match(tt.parenL) || match(tt.lessThan);\n}\n\nfunction parseClassBody(classContextId) {\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (eat(tt.semi)) {\n      continue;\n    }\n\n    if (match(tt.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\n\nfunction parseClassMember(memberStart, classContextId) {\n  if (isTypeScriptEnabled) {\n    tsParseModifiers([\n      ContextualKeyword._declare,\n      ContextualKeyword._public,\n      ContextualKeyword._protected,\n      ContextualKeyword._private,\n      ContextualKeyword._override,\n    ]);\n  }\n  let isStatic = false;\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {\n    parseIdentifier(); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */ false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    state.tokens[state.tokens.length - 1].type = tt._static;\n    isStatic = true;\n\n    if (match(tt.braceL)) {\n      // This is a static block. Mark the word \"static\" with the class context ID for class element\n      // detection and parse as a regular block.\n      state.tokens[state.tokens.length - 1].contextId = classContextId;\n      parseBlock();\n      return;\n    }\n  }\n\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\n\nfunction parseClassMemberWithIsStatic(\n  memberStart,\n  isStatic,\n  classContextId,\n) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseClassMemberWithIsStatic(isStatic)) {\n      return;\n    }\n  }\n  if (eat(tt.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = state.tokens[state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {\n    state.tokens[state.tokens.length - 1].type = tt._async;\n    // an async method\n    const isGenerator = match(tt.star);\n    if (isGenerator) {\n      next();\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if (\n    (token.contextualKeyword === ContextualKeyword._get ||\n      token.contextualKeyword === ContextualKeyword._set) &&\n    !(isLineTerminator() && match(tt.star))\n  ) {\n    if (token.contextualKeyword === ContextualKeyword._get) {\n      state.tokens[state.tokens.length - 1].type = tt._get;\n    } else {\n      state.tokens[state.tokens.length - 1].type = tt._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n  } else if (token.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {\n    parseClassPropertyName(classContextId);\n    parseClassProperty();\n  } else if (isLineTerminator()) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    unexpected();\n  }\n}\n\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n  parseMethod(functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\nexport function parseClassPropertyName(classContextId) {\n  parsePropertyName(classContextId);\n}\n\nexport function parsePostMemberNameModifiers() {\n  if (isTypeScriptEnabled) {\n    const oldIsType = pushTypeContext(0);\n    eat(tt.question);\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function parseClassProperty() {\n  if (isTypeScriptEnabled) {\n    eatTypeToken(tt.bang);\n    tsTryParseTypeAnnotation();\n  } else if (isFlowEnabled) {\n    if (match(tt.colon)) {\n      flowParseTypeAnnotation();\n    }\n  }\n\n  if (match(tt.eq)) {\n    const equalsTokenIndex = state.tokens.length;\n    next();\n    parseMaybeAssign();\n    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;\n  }\n  semicolon();\n}\n\nfunction parseClassId(isStatement, optionalId = false) {\n  if (\n    isTypeScriptEnabled &&\n    (!isStatement || optionalId) &&\n    isContextual(ContextualKeyword._implements)\n  ) {\n    return;\n  }\n\n  if (match(tt.name)) {\n    parseBindingIdentifier(true);\n  }\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (eat(tt._extends)) {\n    parseExprSubscripts();\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (isTypeScriptEnabled) {\n    tsAfterParseClassSuper(hasSuper);\n  } else if (isFlowEnabled) {\n    flowAfterParseClassSuper(hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\nexport function parseExport() {\n  const exportIndex = state.tokens.length - 1;\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExport()) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    parseIdentifier();\n    if (match(tt.comma) && lookaheadType() === tt.star) {\n      expect(tt.comma);\n      expect(tt.star);\n      expectContextual(ContextualKeyword._as);\n      parseIdentifier();\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (eat(tt._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;\n}\n\nfunction parseExportDefaultExpression() {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  if (isFlowEnabled) {\n    if (flowTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  const functionStart = state.start;\n  if (eat(tt._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === tt._function) {\n    // async function declaration\n    eatContextual(ContextualKeyword._async);\n    eat(tt._function);\n    parseFunction(functionStart, true, true);\n  } else if (match(tt._class)) {\n    parseClass(true, true);\n  } else if (match(tt.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    parseMaybeAssign();\n    semicolon();\n  }\n}\n\nfunction parseExportDeclaration() {\n  if (isTypeScriptEnabled) {\n    tsParseExportDeclaration();\n  } else if (isFlowEnabled) {\n    flowParseExportDeclaration();\n  } else {\n    parseStatement(true);\n  }\n}\n\nfunction isExportDefaultSpecifier() {\n  if (isTypeScriptEnabled && tsIsDeclarationStart()) {\n    return false;\n  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {\n    return false;\n  }\n  if (match(tt.name)) {\n    return state.contextualKeyword !== ContextualKeyword._async;\n  }\n\n  if (!match(tt._default)) {\n    return false;\n  }\n\n  const _next = nextTokenStart();\n  const lookahead = lookaheadTypeAndKeyword();\n  const hasFrom =\n    lookahead.type === tt.name && lookahead.contextualKeyword === ContextualKeyword._from;\n  if (lookahead.type === tt.comma) {\n    return true;\n  }\n  // lookahead again when `export default from` is seen\n  if (hasFrom) {\n    const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));\n    return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;\n  }\n  return false;\n}\n\nfunction parseExportSpecifiersMaybe() {\n  if (eat(tt.comma)) {\n    parseExportSpecifiers();\n  }\n}\n\nexport function parseExportFrom() {\n  if (eatContextual(ContextualKeyword._from)) {\n    parseExprAtom();\n    maybeParseImportAttributes();\n  }\n  semicolon();\n}\n\nfunction shouldParseExportStar() {\n  if (isFlowEnabled) {\n    return flowShouldParseExportStar();\n  } else {\n    return match(tt.star);\n  }\n}\n\nfunction parseExportStar() {\n  if (isFlowEnabled) {\n    flowParseExportStar();\n  } else {\n    baseParseExportStar();\n  }\n}\n\nexport function baseParseExportStar() {\n  expect(tt.star);\n\n  if (isContextual(ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n}\n\nfunction parseExportNamespace() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt._as;\n  parseIdentifier();\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\n\nfunction shouldParseExportDeclaration() {\n  return (\n    (isTypeScriptEnabled && tsIsDeclarationStart()) ||\n    (isFlowEnabled && flowShouldParseExportDeclaration()) ||\n    state.type === tt._var ||\n    state.type === tt._const ||\n    state.type === tt._let ||\n    state.type === tt._function ||\n    state.type === tt._class ||\n    isContextual(ContextualKeyword._async) ||\n    match(tt.at)\n  );\n}\n\n// Parses a comma-separated list of module exports.\nexport function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    parseExportSpecifier();\n  }\n}\n\nfunction parseExportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseExportSpecifier();\n    return;\n  }\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n  if (eatContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n  }\n}\n\n/**\n * Starting at the `module` token in an import, determine if it was truly an\n * import reflection token or just looks like one.\n *\n * Returns true for:\n * import module foo from \"foo\";\n * import module from from \"foo\";\n *\n * Returns false for:\n * import module from \"foo\";\n * import module, {bar} from \"foo\";\n */\nfunction isImportReflection() {\n  const snapshot = state.snapshot();\n  expectContextual(ContextualKeyword._module);\n  if (eatContextual(ContextualKeyword._from)) {\n    if (isContextual(ContextualKeyword._from)) {\n      state.restoreFromSnapshot(snapshot);\n      return true;\n    } else {\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (match(tt.comma)) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return true;\n  }\n}\n\n/**\n * Eat the \"module\" token from the import reflection proposal.\n * https://github.com/tc39/proposal-import-reflection\n */\nfunction parseMaybeImportReflection() {\n  // isImportReflection does snapshot/restore, so only run it if we see the word\n  // \"module\".\n  if (isContextual(ContextualKeyword._module) && isImportReflection()) {\n    next();\n  }\n}\n\n// Parses import declaration.\n\nexport function parseImport() {\n  if (isTypeScriptEnabled && match(tt.name) && lookaheadType() === tt.eq) {\n    tsParseImportEqualsDeclaration();\n    return;\n  }\n  if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {\n    const lookahead = lookaheadTypeAndKeyword();\n    if (lookahead.type === tt.name && lookahead.contextualKeyword !== ContextualKeyword._from) {\n      // One of these `import type` cases:\n      // import type T = require('T');\n      // import type A from 'A';\n      expectContextual(ContextualKeyword._type);\n      if (lookaheadType() === tt.eq) {\n        tsParseImportEqualsDeclaration();\n        return;\n      }\n      // If this is an `import type...from` statement, then we already ate the\n      // type token, so proceed to the regular import parser.\n    } else if (lookahead.type === tt.star || lookahead.type === tt.braceL) {\n      // One of these `import type` cases, in which case we can eat the type token\n      // and proceed as normal:\n      // import type * as A from 'A';\n      // import type {a} from 'A';\n      expectContextual(ContextualKeyword._type);\n    }\n    // Otherwise, we are importing the name \"type\".\n  }\n\n  // import '...'\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseMaybeImportReflection();\n    parseImportSpecifiers();\n    expectContextual(ContextualKeyword._from);\n    parseExprAtom();\n  }\n  maybeParseImportAttributes();\n  semicolon();\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return match(tt.name);\n}\n\nfunction parseImportSpecifierLocal() {\n  parseImportedIdentifier();\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (isFlowEnabled) {\n    flowStartParseImportSpecifiers();\n  }\n\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n\n    if (!eat(tt.comma)) return;\n  }\n\n  if (match(tt.star)) {\n    next();\n    expectContextual(ContextualKeyword._as);\n\n    parseImportSpecifierLocal();\n\n    return;\n  }\n\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (eat(tt.colon)) {\n        unexpected(\n          \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n        );\n      }\n\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    parseImportSpecifier();\n  }\n}\n\nfunction parseImportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseImportSpecifier();\n    return;\n  }\n  if (isFlowEnabled) {\n    flowParseImportSpecifier();\n    return;\n  }\n  parseImportedIdentifier();\n  if (isContextual(ContextualKeyword._as)) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;\n    next();\n    parseImportedIdentifier();\n  }\n}\n\n/**\n * Parse import attributes like `with {type: \"json\"}`, or the legacy form\n * `assert {type: \"json\"}`.\n *\n * Import attributes technically have their own syntax, but are always parseable\n * as a plain JS object, so just do that for simplicity.\n */\nfunction maybeParseImportAttributes() {\n  if (match(tt._with) || (isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak())) {\n    next();\n    parseObj(false, false);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}