{"ast":null,"code":"import { isDeclaration } from \"./parser/tokenizer\";\nimport { ContextualKeyword } from \"./parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"./parser/tokenizer/types\";\nimport getImportExportSpecifierInfo from \"./util/getImportExportSpecifierInfo\";\nimport { getNonTypeIdentifiers } from \"./util/getNonTypeIdentifiers\";\n\n/**\n * Class responsible for preprocessing and bookkeeping import and export declarations within the\n * file.\n *\n * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and\n * interopRequireWildcard, so we also allow that mode for compatibility.\n */\nexport default class CJSImportProcessor {\n  __init() {\n    this.nonTypeIdentifiers = new Set();\n  }\n  __init2() {\n    this.importInfoByPath = new Map();\n  }\n  __init3() {\n    this.importsToReplace = new Map();\n  }\n  __init4() {\n    this.identifierReplacements = new Map();\n  }\n  __init5() {\n    this.exportBindingsByLocalName = new Map();\n  }\n  constructor(nameManager, tokens, enableLegacyTypeScriptModuleInterop, options, isTypeScriptTransformEnabled, keepUnusedImports, helperManager) {\n    ;\n    this.nameManager = nameManager;\n    this.tokens = tokens;\n    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;\n    this.options = options;\n    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;\n    this.keepUnusedImports = keepUnusedImports;\n    this.helperManager = helperManager;\n    CJSImportProcessor.prototype.__init.call(this);\n    CJSImportProcessor.prototype.__init2.call(this);\n    CJSImportProcessor.prototype.__init3.call(this);\n    CJSImportProcessor.prototype.__init4.call(this);\n    CJSImportProcessor.prototype.__init5.call(this);\n  }\n  preprocessTokens() {\n    for (let i = 0; i < this.tokens.tokens.length; i++) {\n      if (this.tokens.matches1AtIndex(i, tt._import) && !this.tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)) {\n        this.preprocessImportAtIndex(i);\n      }\n      if (this.tokens.matches1AtIndex(i, tt._export) && !this.tokens.matches2AtIndex(i, tt._export, tt.eq)) {\n        this.preprocessExportAtIndex(i);\n      }\n    }\n    this.generateImportReplacements();\n  }\n\n  /**\n   * In TypeScript, import statements that only import types should be removed.\n   * This includes `import {} from 'foo';`, but not `import 'foo';`.\n   */\n  pruneTypeOnlyImports() {\n    this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      if (importInfo.hasBareImport || importInfo.hasStarExport || importInfo.exportStarNames.length > 0 || importInfo.namedExports.length > 0) {\n        continue;\n      }\n      const names = [...importInfo.defaultNames, ...importInfo.wildcardNames, ...importInfo.namedImports.map(({\n        localName\n      }) => localName)];\n      if (names.every(name => this.shouldAutomaticallyElideImportedName(name))) {\n        this.importsToReplace.set(path, \"\");\n      }\n    }\n  }\n  shouldAutomaticallyElideImportedName(name) {\n    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);\n  }\n  generateImportReplacements() {\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      const {\n        defaultNames,\n        wildcardNames,\n        namedImports,\n        namedExports,\n        exportStarNames,\n        hasStarExport\n      } = importInfo;\n      if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0 && namedExports.length === 0 && exportStarNames.length === 0 && !hasStarExport) {\n        // Import is never used, so don't even assign a name.\n        this.importsToReplace.set(path, `require('${path}');`);\n        continue;\n      }\n      const primaryImportName = this.getFreeIdentifierForPath(path);\n      let secondaryImportName;\n      if (this.enableLegacyTypeScriptModuleInterop) {\n        secondaryImportName = primaryImportName;\n      } else {\n        secondaryImportName = wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);\n      }\n      let requireCode = `var ${primaryImportName} = require('${path}');`;\n      if (wildcardNames.length > 0) {\n        for (const wildcardName of wildcardNames) {\n          const moduleExpr = this.enableLegacyTypeScriptModuleInterop ? primaryImportName : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName})`;\n          requireCode += ` var ${wildcardName} = ${moduleExpr};`;\n        }\n      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName});`;\n      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\"interopRequireDefault\")}(${primaryImportName});`;\n      }\n      for (const {\n        importedName,\n        localName\n      } of namedExports) {\n        requireCode += ` ${this.helperManager.getHelperName(\"createNamedExportFrom\")}(${primaryImportName}, '${localName}', '${importedName}');`;\n      }\n      for (const exportStarName of exportStarNames) {\n        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;\n      }\n      if (hasStarExport) {\n        requireCode += ` ${this.helperManager.getHelperName(\"createStarExport\")}(${primaryImportName});`;\n      }\n      this.importsToReplace.set(path, requireCode);\n      for (const defaultName of defaultNames) {\n        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);\n      }\n      for (const {\n        importedName,\n        localName\n      } of namedImports) {\n        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);\n      }\n    }\n  }\n  getFreeIdentifierForPath(path) {\n    const components = path.split(\"/\");\n    const lastComponent = components[components.length - 1];\n    const baseName = lastComponent.replace(/\\W/g, \"\");\n    return this.nameManager.claimFreeName(`_${baseName}`);\n  }\n  preprocessImportAtIndex(index) {\n    const defaultNames = [];\n    const wildcardNames = [];\n    const namedImports = [];\n    index++;\n    if ((this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) || this.tokens.matches1AtIndex(index, tt._typeof)) && !this.tokens.matches1AtIndex(index + 1, tt.comma) && !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)) {\n      // import type declaration, so no need to process anything.\n      return;\n    }\n    if (this.tokens.matches1AtIndex(index, tt.parenL)) {\n      // Dynamic import, so nothing to do\n      return;\n    }\n    if (this.tokens.matches1AtIndex(index, tt.name)) {\n      defaultNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n      if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      }\n    }\n    if (this.tokens.matches1AtIndex(index, tt.star)) {\n      // * as\n      index += 2;\n      wildcardNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n    }\n    if (this.tokens.matches1AtIndex(index, tt.braceL)) {\n      const result = this.getNamedImports(index + 1);\n      index = result.newIndex;\n      for (const namedImport of result.namedImports) {\n        // Treat {default as X} as a default import to ensure usage of require interop helper\n        if (namedImport.importedName === \"default\") {\n          defaultNames.push(namedImport.localName);\n        } else {\n          namedImports.push(namedImport);\n        }\n      }\n    }\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    }\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.defaultNames.push(...defaultNames);\n    importInfo.wildcardNames.push(...wildcardNames);\n    importInfo.namedImports.push(...namedImports);\n    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {\n      importInfo.hasBareImport = true;\n    }\n  }\n  preprocessExportAtIndex(index) {\n    if (this.tokens.matches2AtIndex(index, tt._export, tt._var) || this.tokens.matches2AtIndex(index, tt._export, tt._let) || this.tokens.matches2AtIndex(index, tt._export, tt._const)) {\n      this.preprocessVarExportAtIndex(index);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt._function) || this.tokens.matches2AtIndex(index, tt._export, tt._class)) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 2);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches3AtIndex(index, tt._export, tt.name, tt._function)) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 3);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.braceL)) {\n      this.preprocessNamedExportAtIndex(index);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.star)) {\n      this.preprocessExportStarAtIndex(index);\n    }\n  }\n  preprocessVarExportAtIndex(index) {\n    let depth = 0;\n    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.\n    for (let i = index + 2;; i++) {\n      if (this.tokens.matches1AtIndex(i, tt.braceL) || this.tokens.matches1AtIndex(i, tt.dollarBraceL) || this.tokens.matches1AtIndex(i, tt.bracketL)) {\n        depth++;\n      } else if (this.tokens.matches1AtIndex(i, tt.braceR) || this.tokens.matches1AtIndex(i, tt.bracketR)) {\n        depth--;\n      } else if (depth === 0 && !this.tokens.matches1AtIndex(i, tt.name)) {\n        break;\n      } else if (this.tokens.matches1AtIndex(1, tt.eq)) {\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        i = endIndex - 1;\n      } else {\n        const token = this.tokens.tokens[i];\n        if (isDeclaration(token)) {\n          const exportName = this.tokens.identifierNameAtIndex(i);\n          this.identifierReplacements.set(exportName, `exports.${exportName}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk this export statement just in case it's an export...from statement.\n   * If it is, combine it into the import info for that path. Otherwise, just\n   * bail out; it'll be handled later.\n   */\n  preprocessNamedExportAtIndex(index) {\n    // export {\n    index += 2;\n    const {\n      newIndex,\n      namedImports\n    } = this.getNamedImports(index);\n    index = newIndex;\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    } else {\n      // Reinterpret \"a as b\" to be local/exported rather than imported/local.\n      for (const {\n        importedName: localName,\n        localName: exportedName\n      } of namedImports) {\n        this.addExportBinding(localName, exportedName);\n      }\n      return;\n    }\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.namedExports.push(...namedImports);\n  }\n  preprocessExportStarAtIndex(index) {\n    let exportedName = null;\n    if (this.tokens.matches3AtIndex(index, tt._export, tt.star, tt._as)) {\n      // export * as\n      index += 3;\n      exportedName = this.tokens.identifierNameAtIndex(index);\n      // foo from\n      index += 2;\n    } else {\n      // export * from\n      index += 3;\n    }\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of star export statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    if (exportedName !== null) {\n      importInfo.exportStarNames.push(exportedName);\n    } else {\n      importInfo.hasStarExport = true;\n    }\n  }\n  getNamedImports(index) {\n    const namedImports = [];\n    while (true) {\n      if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      }\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens, index);\n      index = specifierInfo.endIndex;\n      if (!specifierInfo.isType) {\n        namedImports.push({\n          importedName: specifierInfo.leftName,\n          localName: specifierInfo.rightName\n        });\n      }\n      if (this.tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n        index += 2;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);\n      }\n    }\n    return {\n      newIndex: index,\n      namedImports\n    };\n  }\n\n  /**\n   * Get a mutable import info object for this path, creating one if it doesn't\n   * exist yet.\n   */\n  getImportInfo(path) {\n    const existingInfo = this.importInfoByPath.get(path);\n    if (existingInfo) {\n      return existingInfo;\n    }\n    const newInfo = {\n      defaultNames: [],\n      wildcardNames: [],\n      namedImports: [],\n      namedExports: [],\n      hasBareImport: false,\n      exportStarNames: [],\n      hasStarExport: false\n    };\n    this.importInfoByPath.set(path, newInfo);\n    return newInfo;\n  }\n  addExportBinding(localName, exportedName) {\n    if (!this.exportBindingsByLocalName.has(localName)) {\n      this.exportBindingsByLocalName.set(localName, []);\n    }\n    this.exportBindingsByLocalName.get(localName).push(exportedName);\n  }\n\n  /**\n   * Return the code to use for the import for this path, or the empty string if\n   * the code has already been \"claimed\" by a previous import.\n   */\n  claimImportCode(importPath) {\n    const result = this.importsToReplace.get(importPath);\n    this.importsToReplace.set(importPath, \"\");\n    return result || \"\";\n  }\n  getIdentifierReplacement(identifierName) {\n    return this.identifierReplacements.get(identifierName) || null;\n  }\n\n  /**\n   * Return a string like `exports.foo = exports.bar`.\n   */\n  resolveExportBinding(assignedName) {\n    const exportedNames = this.exportBindingsByLocalName.get(assignedName);\n    if (!exportedNames || exportedNames.length === 0) {\n      return null;\n    }\n    return exportedNames.map(exportedName => `exports.${exportedName}`).join(\" = \");\n  }\n\n  /**\n   * Return all imported/exported names where we might be interested in whether usages of those\n   * names are shadowed.\n   */\n  getGlobalNames() {\n    return new Set([...this.identifierReplacements.keys(), ...this.exportBindingsByLocalName.keys()]);\n  }\n}","map":{"version":3,"names":["isDeclaration","ContextualKeyword","TokenType","tt","getImportExportSpecifierInfo","getNonTypeIdentifiers","CJSImportProcessor","__init","nonTypeIdentifiers","Set","__init2","importInfoByPath","Map","__init3","importsToReplace","__init4","identifierReplacements","__init5","exportBindingsByLocalName","constructor","nameManager","tokens","enableLegacyTypeScriptModuleInterop","options","isTypeScriptTransformEnabled","keepUnusedImports","helperManager","prototype","call","preprocessTokens","i","length","matches1AtIndex","_import","matches3AtIndex","name","eq","preprocessImportAtIndex","_export","matches2AtIndex","preprocessExportAtIndex","generateImportReplacements","pruneTypeOnlyImports","path","importInfo","entries","hasBareImport","hasStarExport","exportStarNames","namedExports","names","defaultNames","wildcardNames","namedImports","map","localName","every","shouldAutomaticallyElideImportedName","set","has","primaryImportName","getFreeIdentifierForPath","secondaryImportName","requireCode","wildcardName","moduleExpr","getHelperName","importedName","exportStarName","defaultName","components","split","lastComponent","baseName","replace","claimFreeName","index","matchesContextualAtIndex","_type","_typeof","comma","_from","parenL","push","identifierNameAtIndex","star","braceL","result","getNamedImports","newIndex","namedImport","string","Error","stringValueAtIndex","getImportInfo","_var","_let","_const","preprocessVarExportAtIndex","_function","_class","exportName","addExportBinding","preprocessNamedExportAtIndex","preprocessExportStarAtIndex","depth","dollarBraceL","bracketL","braceR","bracketR","endIndex","currentToken","rhsEndIndex","token","exportedName","_as","specifierInfo","isType","leftName","rightName","JSON","stringify","existingInfo","get","newInfo","claimImportCode","importPath","getIdentifierReplacement","identifierName","resolveExportBinding","assignedName","exportedNames","join","getGlobalNames","keys"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/CJSImportProcessor.js"],"sourcesContent":["\n\n\nimport {isDeclaration} from \"./parser/tokenizer\";\nimport {ContextualKeyword} from \"./parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"./parser/tokenizer/types\";\n\nimport getImportExportSpecifierInfo from \"./util/getImportExportSpecifierInfo\";\nimport {getNonTypeIdentifiers} from \"./util/getNonTypeIdentifiers\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Class responsible for preprocessing and bookkeeping import and export declarations within the\n * file.\n *\n * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and\n * interopRequireWildcard, so we also allow that mode for compatibility.\n */\nexport default class CJSImportProcessor {\n   __init() {this.nonTypeIdentifiers = new Set()}\n   __init2() {this.importInfoByPath = new Map()}\n   __init3() {this.importsToReplace = new Map()}\n   __init4() {this.identifierReplacements = new Map()}\n   __init5() {this.exportBindingsByLocalName = new Map()}\n\n  constructor(\n     nameManager,\n     tokens,\n     enableLegacyTypeScriptModuleInterop,\n     options,\n     isTypeScriptTransformEnabled,\n     keepUnusedImports,\n     helperManager,\n  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.keepUnusedImports = keepUnusedImports;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}\n\n  preprocessTokens() {\n    for (let i = 0; i < this.tokens.tokens.length; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, tt._import) &&\n        !this.tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)\n      ) {\n        this.preprocessImportAtIndex(i);\n      }\n      if (\n        this.tokens.matches1AtIndex(i, tt._export) &&\n        !this.tokens.matches2AtIndex(i, tt._export, tt.eq)\n      ) {\n        this.preprocessExportAtIndex(i);\n      }\n    }\n    this.generateImportReplacements();\n  }\n\n  /**\n   * In TypeScript, import statements that only import types should be removed.\n   * This includes `import {} from 'foo';`, but not `import 'foo';`.\n   */\n  pruneTypeOnlyImports() {\n    this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      if (\n        importInfo.hasBareImport ||\n        importInfo.hasStarExport ||\n        importInfo.exportStarNames.length > 0 ||\n        importInfo.namedExports.length > 0\n      ) {\n        continue;\n      }\n      const names = [\n        ...importInfo.defaultNames,\n        ...importInfo.wildcardNames,\n        ...importInfo.namedImports.map(({localName}) => localName),\n      ];\n      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {\n        this.importsToReplace.set(path, \"\");\n      }\n    }\n  }\n\n  shouldAutomaticallyElideImportedName(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      !this.keepUnusedImports &&\n      !this.nonTypeIdentifiers.has(name)\n    );\n  }\n\n   generateImportReplacements() {\n    for (const [path, importInfo] of this.importInfoByPath.entries()) {\n      const {\n        defaultNames,\n        wildcardNames,\n        namedImports,\n        namedExports,\n        exportStarNames,\n        hasStarExport,\n      } = importInfo;\n\n      if (\n        defaultNames.length === 0 &&\n        wildcardNames.length === 0 &&\n        namedImports.length === 0 &&\n        namedExports.length === 0 &&\n        exportStarNames.length === 0 &&\n        !hasStarExport\n      ) {\n        // Import is never used, so don't even assign a name.\n        this.importsToReplace.set(path, `require('${path}');`);\n        continue;\n      }\n\n      const primaryImportName = this.getFreeIdentifierForPath(path);\n      let secondaryImportName;\n      if (this.enableLegacyTypeScriptModuleInterop) {\n        secondaryImportName = primaryImportName;\n      } else {\n        secondaryImportName =\n          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);\n      }\n      let requireCode = `var ${primaryImportName} = require('${path}');`;\n      if (wildcardNames.length > 0) {\n        for (const wildcardName of wildcardNames) {\n          const moduleExpr = this.enableLegacyTypeScriptModuleInterop\n            ? primaryImportName\n            : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(${primaryImportName})`;\n          requireCode += ` var ${wildcardName} = ${moduleExpr};`;\n        }\n      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireWildcard\",\n        )}(${primaryImportName});`;\n      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {\n        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(\n          \"interopRequireDefault\",\n        )}(${primaryImportName});`;\n      }\n\n      for (const {importedName, localName} of namedExports) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createNamedExportFrom\",\n        )}(${primaryImportName}, '${localName}', '${importedName}');`;\n      }\n      for (const exportStarName of exportStarNames) {\n        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;\n      }\n      if (hasStarExport) {\n        requireCode += ` ${this.helperManager.getHelperName(\n          \"createStarExport\",\n        )}(${primaryImportName});`;\n      }\n\n      this.importsToReplace.set(path, requireCode);\n\n      for (const defaultName of defaultNames) {\n        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);\n      }\n      for (const {importedName, localName} of namedImports) {\n        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);\n      }\n    }\n  }\n\n  getFreeIdentifierForPath(path) {\n    const components = path.split(\"/\");\n    const lastComponent = components[components.length - 1];\n    const baseName = lastComponent.replace(/\\W/g, \"\");\n    return this.nameManager.claimFreeName(`_${baseName}`);\n  }\n\n   preprocessImportAtIndex(index) {\n    const defaultNames = [];\n    const wildcardNames = [];\n    const namedImports = [];\n\n    index++;\n    if (\n      (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||\n        this.tokens.matches1AtIndex(index, tt._typeof)) &&\n      !this.tokens.matches1AtIndex(index + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)\n    ) {\n      // import type declaration, so no need to process anything.\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.parenL)) {\n      // Dynamic import, so nothing to do\n      return;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.name)) {\n      defaultNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n      if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      }\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.star)) {\n      // * as\n      index += 2;\n      wildcardNames.push(this.tokens.identifierNameAtIndex(index));\n      index++;\n    }\n\n    if (this.tokens.matches1AtIndex(index, tt.braceL)) {\n      const result = this.getNamedImports(index + 1);\n      index = result.newIndex;\n\n      for (const namedImport of result.namedImports) {\n        // Treat {default as X} as a default import to ensure usage of require interop helper\n        if (namedImport.importedName === \"default\") {\n          defaultNames.push(namedImport.localName);\n        } else {\n          namedImports.push(namedImport);\n        }\n      }\n    }\n\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.defaultNames.push(...defaultNames);\n    importInfo.wildcardNames.push(...wildcardNames);\n    importInfo.namedImports.push(...namedImports);\n    if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {\n      importInfo.hasBareImport = true;\n    }\n  }\n\n   preprocessExportAtIndex(index) {\n    if (\n      this.tokens.matches2AtIndex(index, tt._export, tt._var) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._let) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._const)\n    ) {\n      this.preprocessVarExportAtIndex(index);\n    } else if (\n      this.tokens.matches2AtIndex(index, tt._export, tt._function) ||\n      this.tokens.matches2AtIndex(index, tt._export, tt._class)\n    ) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 2);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches3AtIndex(index, tt._export, tt.name, tt._function)) {\n      const exportName = this.tokens.identifierNameAtIndex(index + 3);\n      this.addExportBinding(exportName, exportName);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.braceL)) {\n      this.preprocessNamedExportAtIndex(index);\n    } else if (this.tokens.matches2AtIndex(index, tt._export, tt.star)) {\n      this.preprocessExportStarAtIndex(index);\n    }\n  }\n\n   preprocessVarExportAtIndex(index) {\n    let depth = 0;\n    // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.\n    for (let i = index + 2; ; i++) {\n      if (\n        this.tokens.matches1AtIndex(i, tt.braceL) ||\n        this.tokens.matches1AtIndex(i, tt.dollarBraceL) ||\n        this.tokens.matches1AtIndex(i, tt.bracketL)\n      ) {\n        depth++;\n      } else if (\n        this.tokens.matches1AtIndex(i, tt.braceR) ||\n        this.tokens.matches1AtIndex(i, tt.bracketR)\n      ) {\n        depth--;\n      } else if (depth === 0 && !this.tokens.matches1AtIndex(i, tt.name)) {\n        break;\n      } else if (this.tokens.matches1AtIndex(1, tt.eq)) {\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        i = endIndex - 1;\n      } else {\n        const token = this.tokens.tokens[i];\n        if (isDeclaration(token)) {\n          const exportName = this.tokens.identifierNameAtIndex(i);\n          this.identifierReplacements.set(exportName, `exports.${exportName}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk this export statement just in case it's an export...from statement.\n   * If it is, combine it into the import info for that path. Otherwise, just\n   * bail out; it'll be handled later.\n   */\n   preprocessNamedExportAtIndex(index) {\n    // export {\n    index += 2;\n    const {newIndex, namedImports} = this.getNamedImports(index);\n    index = newIndex;\n\n    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {\n      index++;\n    } else {\n      // Reinterpret \"a as b\" to be local/exported rather than imported/local.\n      for (const {importedName: localName, localName: exportedName} of namedImports) {\n        this.addExportBinding(localName, exportedName);\n      }\n      return;\n    }\n\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of import statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    importInfo.namedExports.push(...namedImports);\n  }\n\n   preprocessExportStarAtIndex(index) {\n    let exportedName = null;\n    if (this.tokens.matches3AtIndex(index, tt._export, tt.star, tt._as)) {\n      // export * as\n      index += 3;\n      exportedName = this.tokens.identifierNameAtIndex(index);\n      // foo from\n      index += 2;\n    } else {\n      // export * from\n      index += 3;\n    }\n    if (!this.tokens.matches1AtIndex(index, tt.string)) {\n      throw new Error(\"Expected string token at the end of star export statement.\");\n    }\n    const path = this.tokens.stringValueAtIndex(index);\n    const importInfo = this.getImportInfo(path);\n    if (exportedName !== null) {\n      importInfo.exportStarNames.push(exportedName);\n    } else {\n      importInfo.hasStarExport = true;\n    }\n  }\n\n   getNamedImports(index) {\n    const namedImports = [];\n    while (true) {\n      if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      }\n\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens, index);\n      index = specifierInfo.endIndex;\n      if (!specifierInfo.isType) {\n        namedImports.push({\n          importedName: specifierInfo.leftName,\n          localName: specifierInfo.rightName,\n        });\n      }\n\n      if (this.tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n        index += 2;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.braceR)) {\n        index++;\n        break;\n      } else if (this.tokens.matches1AtIndex(index, tt.comma)) {\n        index++;\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);\n      }\n    }\n    return {newIndex: index, namedImports};\n  }\n\n  /**\n   * Get a mutable import info object for this path, creating one if it doesn't\n   * exist yet.\n   */\n   getImportInfo(path) {\n    const existingInfo = this.importInfoByPath.get(path);\n    if (existingInfo) {\n      return existingInfo;\n    }\n    const newInfo = {\n      defaultNames: [],\n      wildcardNames: [],\n      namedImports: [],\n      namedExports: [],\n      hasBareImport: false,\n      exportStarNames: [],\n      hasStarExport: false,\n    };\n    this.importInfoByPath.set(path, newInfo);\n    return newInfo;\n  }\n\n   addExportBinding(localName, exportedName) {\n    if (!this.exportBindingsByLocalName.has(localName)) {\n      this.exportBindingsByLocalName.set(localName, []);\n    }\n    this.exportBindingsByLocalName.get(localName).push(exportedName);\n  }\n\n  /**\n   * Return the code to use for the import for this path, or the empty string if\n   * the code has already been \"claimed\" by a previous import.\n   */\n  claimImportCode(importPath) {\n    const result = this.importsToReplace.get(importPath);\n    this.importsToReplace.set(importPath, \"\");\n    return result || \"\";\n  }\n\n  getIdentifierReplacement(identifierName) {\n    return this.identifierReplacements.get(identifierName) || null;\n  }\n\n  /**\n   * Return a string like `exports.foo = exports.bar`.\n   */\n  resolveExportBinding(assignedName) {\n    const exportedNames = this.exportBindingsByLocalName.get(assignedName);\n    if (!exportedNames || exportedNames.length === 0) {\n      return null;\n    }\n    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(\" = \");\n  }\n\n  /**\n   * Return all imported/exported names where we might be interested in whether usages of those\n   * names are shadowed.\n   */\n  getGlobalNames() {\n    return new Set([\n      ...this.identifierReplacements.keys(),\n      ...this.exportBindingsByLocalName.keys(),\n    ]);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}