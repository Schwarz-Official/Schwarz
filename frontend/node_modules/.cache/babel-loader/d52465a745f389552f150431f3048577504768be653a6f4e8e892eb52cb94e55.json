{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  INTERNAL_FEATURES: function () {\n    return INTERNAL_FEATURES;\n  },\n  isValidVariantFormatString: function () {\n    return isValidVariantFormatString;\n  },\n  parseVariant: function () {\n    return parseVariant;\n  },\n  getFileModifiedMap: function () {\n    return getFileModifiedMap;\n  },\n  createContext: function () {\n    return createContext;\n  },\n  getContext: function () {\n    return getContext;\n  }\n});\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _url = /*#__PURE__*/_interop_require_default(require(\"url\"));\nconst _postcss = /*#__PURE__*/_interop_require_default(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/_interop_require_default(require(\"dlv\"));\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/_interop_require_default(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/_interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/_interop_require_default(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/_interop_require_default(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/_interop_require_default(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/_interop_require_wildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/_interop_require_wildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/_interop_require_default(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/_interop_require_default(require(\"../util/negateValue\"));\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/_interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidation = require(\"./cacheInvalidation.js\");\nconst _offsets = require(\"./offsets.js\");\nconst _featureFlags = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst INTERNAL_FEATURES = Symbol();\nconst VARIANT_TYPES = {\n  AddVariant: Symbol.for(\"ADD_VARIANT\"),\n  MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n  Base: 1 << 0,\n  Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes({\n  type = \"any\",\n  ...options\n}) {\n  let types = [].concat(type);\n  return {\n    ...options,\n    types: types.map(type => {\n      if (Array.isArray(type)) {\n        return {\n          type: type[0],\n          ...type[1]\n        };\n      }\n      return {\n        type,\n        preferOnConflict: false\n      };\n    })\n  };\n}\nfunction parseVariantFormatString(input) {\n  /** @type {string[]} */let parts = [];\n  // When parsing whitespace around special characters are insignificant\n  // However, _inside_ of a variant they could be\n  // Because the selector could look like this\n  // @media { &[data-name=\"foo bar\"] }\n  // This is why we do not skip whitespace\n  let current = \"\";\n  let depth = 0;\n  for (let idx = 0; idx < input.length; idx++) {\n    let char = input[idx];\n    if (char === \"\\\\\") {\n      // Escaped characters are not special\n      current += \"\\\\\" + input[++idx];\n    } else if (char === \"{\") {\n      // Nested rule: start\n      ++depth;\n      parts.push(current.trim());\n      current = \"\";\n    } else if (char === \"}\") {\n      // Nested rule: end\n      if (--depth < 0) {\n        throw new Error(`Your { and } are unbalanced.`);\n      }\n      parts.push(current.trim());\n      current = \"\";\n    } else {\n      // Normal character\n      current += char;\n    }\n  }\n  if (current.length > 0) {\n    parts.push(current.trim());\n  }\n  parts = parts.filter(part => part !== \"\");\n  return parts;\n}\nfunction insertInto(list, value, {\n  before = []\n} = {}) {\n  before = [].concat(before);\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n  let idx = list.length - 1;\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n  list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n    return isNode ? style : (0, _parseObjectStyles.default)(style);\n  });\n}\nfunction getClasses(selector, mutate) {\n  let parser = (0, _postcssselectorparser.default)(selectors => {\n    let allClasses = [];\n    if (mutate) {\n      mutate(selectors);\n    }\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\nfunction extractCandidates(node, state = {\n  containsNonOnDemandable: false\n}, depth = 0) {\n  let classes = [];\n  // Handle normal rules\n  if (node.type === \"rule\") {\n    // Ignore everything inside a :not(...). This allows you to write code like\n    // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n    // not generated it. But now we will ignore everything inside a `:not`, so\n    // that it still gets generated.\n    function ignoreNot(selectors) {\n      selectors.walkPseudos(pseudo => {\n        if (pseudo.value === \":not\") {\n          pseudo.remove();\n        }\n      });\n    }\n    for (let selector of node.selectors) {\n      let classCandidates = getClasses(selector, ignoreNot);\n      // At least one of the selectors contains non-\"on-demandable\" candidates.\n      if (classCandidates.length === 0) {\n        state.containsNonOnDemandable = true;\n      }\n      for (let classCandidate of classCandidates) {\n        classes.push(classCandidate);\n      }\n    }\n  } else if (node.type === \"atrule\") {\n    node.walkRules(rule => {\n      for (let classCandidate of rule.selectors.flatMap(selector => getClasses(selector))) {\n        classes.push(classCandidate);\n      }\n    });\n  }\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes];\n  }\n  return classes;\n}\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n    // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(_sharedState.NOT_ON_DEMAND);\n    }\n    // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\nfunction isValidVariantFormatString(format) {\n  return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n  variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n  let fns = parseVariantFormatString(variant).map(str => {\n    if (!str.startsWith(\"@\")) {\n      return ({\n        format\n      }) => format(str);\n    }\n    let [, name, params] = /@(\\S*)( .+|[({].*)?/g.exec(str);\n    var _params_trim;\n    return ({\n      wrap\n    }) => {\n      return wrap(_postcss.default.atRule({\n        name,\n        params: (_params_trim = params === null || params === void 0 ? void 0 : params.trim()) !== null && _params_trim !== void 0 ? _params_trim : \"\"\n      }));\n    };\n  }).reverse();\n  return api => {\n    for (let fn of fns) {\n      fn(api);\n    }\n  };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */\nfunction buildPluginApi(tailwindConfig, context, {\n  variantList,\n  variantMap,\n  offsets,\n  classList\n}) {\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n  }\n  function prefixIdentifier(identifier, options) {\n    if (identifier === _sharedState.NOT_ON_DEMAND) {\n      return _sharedState.NOT_ON_DEMAND;\n    }\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n    return context.tailwindConfig.prefix + identifier;\n  }\n  function resolveThemeValue(path, defaultValue, opts = {}) {\n    let parts = (0, _toPath.toPath)(path);\n    let value = getConfigValue([\"theme\", ...parts], defaultValue);\n    return (0, _transformThemeValue.default)(parts[0])(value, opts);\n  }\n  let variantIdentifier = 0;\n  let api = {\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n    theme: resolveThemeValue,\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n      return getConfigValue([\"corePlugins\", path], true);\n    },\n    variants: () => {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return [];\n    },\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.create(\"base\");\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: \"base\"\n        }, rule]);\n      }\n    },\n    /**\n    * @param {string} group\n    * @param {Record<string, string | string[]>} declarations\n    */\n    addDefaults(group, declarations) {\n      const groups = {\n        [`@defaults ${group}`]: declarations\n      };\n      for (let [identifier, rule] of withIdentifiers(groups)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"defaults\"),\n          layer: \"defaults\"\n        }, rule]);\n      }\n    },\n    addComponents(components, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"components\"),\n          layer: \"components\",\n          options\n        }, rule]);\n      }\n    },\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"utilities\"),\n          layer: \"utilities\",\n          options\n        }, rule]);\n      }\n    },\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"utilities\");\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, {\n          isOnlyPlugin\n        }) {\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(({\n            type\n          }) => type === coercedType)) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"utilities\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    matchComponents: function (components, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"components\");\n      for (let identifier in components) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = components[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, {\n          isOnlyPlugin\n        }) {\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(({\n            type\n          }) => type === coercedType)) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"components\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    addVariant(variantName, variantFunctions, options = {}) {\n      variantFunctions = [].concat(variantFunctions).map(variantFunction => {\n        if (typeof variantFunction !== \"string\") {\n          // Safelist public API functions\n          return (api = {}) => {\n            let {\n              args,\n              modifySelectors,\n              container,\n              separator,\n              wrap,\n              format\n            } = api;\n            let result = variantFunction(Object.assign({\n              modifySelectors,\n              container,\n              separator\n            }, options.type === VARIANT_TYPES.MatchVariant && {\n              args,\n              wrap,\n              format\n            }));\n            if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n              throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n            }\n            if (Array.isArray(result)) {\n              return result.filter(variant => typeof variant === \"string\").map(variant => parseVariant(variant));\n            }\n            // result may be undefined with legacy variants that use APIs like `modifySelectors`\n            // result may also be a postcss node if someone was returning the result from `modifySelectors`\n            return result && typeof result === \"string\" && parseVariant(result)(api);\n          };\n        }\n        if (!isValidVariantFormatString(variantFunction)) {\n          throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n        }\n        return parseVariant(variantFunction);\n      });\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n      context.variantOptions.set(variantName, options);\n    },\n    matchVariant(variant, variantFn, options) {\n      var _options_id;\n      // A unique identifier that \"groups\" these variants together.\n      // This is for internal use only which is why it is not present in the types\n      let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;\n      let isSpecial = variant === \"@\";\n      let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n      var _options_values;\n      for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})) {\n        if (key === \"DEFAULT\") continue;\n        api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({\n          args,\n          container\n        }) => {\n          return variantFn(value, modifiersEnabled ? {\n            modifier: args === null || args === void 0 ? void 0 : args.modifier,\n            container\n          } : {\n            container\n          });\n        }, {\n          ...options,\n          value,\n          id,\n          type: VARIANT_TYPES.MatchVariant,\n          variantInfo: VARIANT_INFO.Base\n        });\n      }\n      var _options_values1;\n      let hasDefault = (\"DEFAULT\" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n      api.addVariant(variant, ({\n        args,\n        container\n      }) => {\n        if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n          return null;\n        }\n        var\n        // (JetBrains) plugins.\n        _args_value;\n        return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n          modifier: args === null || args === void 0 ? void 0 : args.modifier,\n          container\n        } : {\n          container\n        });\n      }, {\n        ...options,\n        id,\n        type: VARIANT_TYPES.MatchVariant,\n        variantInfo: VARIANT_INFO.Dynamic\n      });\n    }\n  };\n  return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n  return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n  let mtimesToCommit = new Map();\n  for (let file of files) {\n    var _fs_statSync;\n    if (!file) continue;\n    let parsed = _url.default.parse(file);\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n    let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {\n      throwIfNoEntry: false\n    })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;\n    if (!newModified) {\n      continue;\n    }\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n    mtimesToCommit.set(file, newModified);\n  }\n  return [changed, mtimesToCommit];\n}\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if ([\"responsive\", \"variants\"].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === \"atrule\" && [\"responsive\", \"variants\"].includes(node.name)) {\n      node.name = \"layer\";\n      node.params = \"utilities\";\n    }\n  });\n  // Walk @layer rules and treat them like plugins\n  root.walkAtRules(\"layer\", layerRule => {\n    extractVariantAtRules(layerRule);\n    if (layerRule.params === \"base\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addBase\n        }) {\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"components\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addComponents\n        }) {\n          addComponents(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"utilities\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addUtilities\n        }) {\n          addUtilities(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n  let corePluginList = Object.entries({\n    ..._corePlugins.variantPlugins,\n    ..._corePlugins.corePlugins\n  }).map(([name, plugin]) => {\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n    return typeof plugin === \"function\" ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root);\n  // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n  let beforeVariants = [_corePlugins.variantPlugins[\"pseudoElementVariants\"], _corePlugins.variantPlugins[\"pseudoClassVariants\"], _corePlugins.variantPlugins[\"ariaVariants\"], _corePlugins.variantPlugins[\"dataVariants\"]];\n  let afterVariants = [_corePlugins.variantPlugins[\"supportsVariants\"], _corePlugins.variantPlugins[\"directionVariants\"], _corePlugins.variantPlugins[\"reducedMotionVariants\"], _corePlugins.variantPlugins[\"prefersContrastVariants\"], _corePlugins.variantPlugins[\"darkVariants\"], _corePlugins.variantPlugins[\"printVariant\"], _corePlugins.variantPlugins[\"screenVariants\"], _corePlugins.variantPlugins[\"orientationVariants\"]];\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  context.variantMap = variantMap;\n  let offsets = new _offsets.Offsets();\n  context.offsets = offsets;\n  let classList = new Set();\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  });\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n    }\n  }\n  // Make sure to record bit masks for every variant\n  offsets.recordVariants(variantList, variant => variantMap.get(variant).length);\n  // Build variantMap\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [offsets.forVariant(variantName, idx), variantFunction]));\n  }\n  var _context_tailwindConfig_safelist;\n  let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);\n  if (safelist.length > 0) {\n    let checks = [];\n    for (let value of safelist) {\n      if (typeof value === \"string\") {\n        context.changedContent.push({\n          content: value,\n          extension: \"html\"\n        });\n        continue;\n      }\n      if (value instanceof RegExp) {\n        _log.default.warn(\"root-regex\", [\"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\", \"Update your `safelist` configuration to eliminate this warning.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n        continue;\n      }\n      checks.push(value);\n    }\n    if (checks.length > 0) {\n      let patternMatchingCount = new Map();\n      let prefixLength = context.tailwindConfig.prefix.length;\n      let checkImportantUtils = checks.some(check => check.pattern.source.includes(\"!\"));\n      for (let util of classList) {\n        let utils = Array.isArray(util) ? (() => {\n          let [utilName, options] = util;\n          var _options_values;\n          let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});\n          let classes = values.map(value => (0, _nameClass.formatClass)(utilName, value));\n          if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n            // This is the normal negated version\n            // e.g. `-inset-1` or `-tw-inset-1`\n            classes = [...classes, ...classes.map(cls => \"-\" + cls)];\n            // This is the negated version *after* the prefix\n            // e.g. `tw--inset-1`\n            // The prefix is already attached to util name\n            // So we add the negative after the prefix\n            classes = [...classes, ...classes.map(cls => cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))];\n          }\n          if (options.types.some(({\n            type\n          }) => type === \"color\")) {\n            classes = [...classes, ...classes.flatMap(cls => Object.keys(context.tailwindConfig.theme.opacity).map(opacity => `${cls}/${opacity}`))];\n          }\n          if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n            classes = [...classes, ...classes.map(cls => \"!\" + cls)];\n          }\n          return classes;\n        })() : [util];\n        for (let util of utils) {\n          for (let {\n            pattern,\n            variants = []\n          } of checks) {\n            // RegExp with the /g flag are stateful, so let's reset the last\n            // index pointer to reset the state.\n            pattern.lastIndex = 0;\n            if (!patternMatchingCount.has(pattern)) {\n              patternMatchingCount.set(pattern, 0);\n            }\n            if (!pattern.test(util)) continue;\n            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n            context.changedContent.push({\n              content: util,\n              extension: \"html\"\n            });\n            for (let variant of variants) {\n              context.changedContent.push({\n                content: variant + context.tailwindConfig.separator + util,\n                extension: \"html\"\n              });\n            }\n          }\n        }\n      }\n      for (let [regex, count] of patternMatchingCount.entries()) {\n        if (count !== 0) continue;\n        _log.default.warn([`The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`, \"Fix this pattern or remove it from your `safelist` configuration.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n      }\n    }\n  }\n  var _context_tailwindConfig_darkMode, _concat_;\n  let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : \"media\")[1]) !== null && _concat_ !== void 0 ? _concat_ : \"dark\";\n  // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utilities work properly. (Thanks Biology)\n  let parasiteUtilities = [prefix(context, darkClassName), prefix(context, \"group\"), prefix(context, \"peer\")];\n  context.getClassOrder = function getClassOrder(classes) {\n    // Sort classes so they're ordered in a deterministic manner\n    let sorted = [...classes].sort((a, z) => {\n      if (a === z) return 0;\n      if (a < z) return -1;\n      return 1;\n    });\n    // Non-util classes won't be generated, so we default them to null\n    let sortedClassNames = new Map(sorted.map(className => [className, null]));\n    // Sort all classes in order\n    // Non-tailwind classes won't be generated and will be left as `null`\n    let rules = (0, _generateRules.generateRules)(new Set(sorted), context);\n    rules = context.offsets.sort(rules);\n    let idx = BigInt(parasiteUtilities.length);\n    for (const [, rule] of rules) {\n      let candidate = rule.raws.tailwind.candidate;\n      var _sortedClassNames_get;\n      // When multiple rules match a candidate\n      // always take the position of the first one\n      sortedClassNames.set(candidate, (_sortedClassNames_get = sortedClassNames.get(candidate)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : idx++);\n    }\n    return classes.map(className => {\n      var _sortedClassNames_get;\n      let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;\n      let parasiteIndex = parasiteUtilities.indexOf(className);\n      if (order === null && parasiteIndex !== -1) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = BigInt(parasiteIndex);\n      }\n      return [className, order];\n    });\n  };\n  // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n  context.getClassList = function getClassList(options = {}) {\n    let output = [];\n    for (let util of classList) {\n      if (Array.isArray(util)) {\n        var _utilOptions_types;\n        let [utilName, utilOptions] = util;\n        let negativeClasses = [];\n        var _utilOptions_modifiers;\n        let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});\n        if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({\n          type\n        }) => type === \"color\")) {\n          var _context_tailwindConfig_theme_opacity;\n          modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));\n        }\n        let metadata = {\n          modifiers\n        };\n        let includeMetadata = options.includeMetadata && modifiers.length > 0;\n        var _utilOptions_values;\n        for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})) {\n          // Ignore undefined and null values\n          if (value == null) {\n            continue;\n          }\n          let cls = (0, _nameClass.formatClass)(utilName, key);\n          output.push(includeMetadata ? [cls, metadata] : cls);\n          if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n            let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);\n            negativeClasses.push(includeMetadata ? [cls, metadata] : cls);\n          }\n        }\n        output.push(...negativeClasses);\n      } else {\n        output.push(util);\n      }\n    }\n    return output;\n  };\n  // Generate a list of available variants with meta information of the type of variant.\n  context.getVariants = function getVariants() {\n    let result = [];\n    for (let [name, options] of context.variantOptions.entries()) {\n      if (options.variantInfo === VARIANT_INFO.Base) continue;\n      var _options_values;\n      result.push({\n        name,\n        isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n        values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),\n        hasDash: name !== \"@\",\n        selectors({\n          modifier,\n          value\n        } = {}) {\n          let candidate = \"__TAILWIND_PLACEHOLDER__\";\n          let rule = _postcss.default.rule({\n            selector: `.${candidate}`\n          });\n          let container = _postcss.default.root({\n            nodes: [rule.clone()]\n          });\n          let before = container.toString();\n          var _context_variantMap_get;\n          let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn]) => fn);\n          let formatStrings = [];\n          for (let fn of fns) {\n            var _options_values;\n            let localFormatStrings = [];\n            var _options_values_value;\n            let api = {\n              args: {\n                modifier,\n                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value\n              },\n              separator: context.tailwindConfig.separator,\n              modifySelectors(modifierFunction) {\n                // Run the modifierFunction over each rule\n                container.each(rule => {\n                  if (rule.type !== \"rule\") {\n                    return;\n                  }\n                  rule.selectors = rule.selectors.map(selector => {\n                    return modifierFunction({\n                      get className() {\n                        return (0, _generateRules.getClassNameFromSelector)(selector);\n                      },\n                      selector\n                    });\n                  });\n                });\n                return container;\n              },\n              format(str) {\n                localFormatStrings.push(str);\n              },\n              wrap(wrapper) {\n                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n              },\n              container\n            };\n            let ruleWithVariant = fn(api);\n            if (localFormatStrings.length > 0) {\n              formatStrings.push(localFormatStrings);\n            }\n            if (Array.isArray(ruleWithVariant)) {\n              for (let variantFunction of ruleWithVariant) {\n                localFormatStrings = [];\n                variantFunction(api);\n                formatStrings.push(localFormatStrings);\n              }\n            }\n          }\n          // Reverse engineer the result of the `container`\n          let manualFormatStrings = [];\n          let after = container.toString();\n          if (before !== after) {\n            // Figure out all selectors\n            container.walkRules(rule => {\n              let modified = rule.selector;\n              // Rebuild the base selector, this is what plugin authors would do\n              // as well. E.g.: `${variant}${separator}${className}`.\n              // However, plugin authors probably also prepend or append certain\n              // classes, pseudos, ids, ...\n              let rebuiltBase = (0, _postcssselectorparser.default)(selectors => {\n                selectors.walkClasses(classNode => {\n                  classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                });\n              }).processSync(modified);\n              // Now that we know the original selector, the new selector, and\n              // the rebuild part in between, we can replace the part that plugin\n              // authors need to rebuild with `&`, and eventually store it in the\n              // collectedFormats. Similar to what `format('...')` would do.\n              //\n              // E.g.:\n              //                   variant: foo\n              //                  selector: .markdown > p\n              //      modified (by plugin): .foo .foo\\\\:markdown > p\n              //    rebuiltBase (internal): .foo\\\\:markdown > p\n              //                    format: .foo &\n              manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n            });\n            // Figure out all atrules\n            container.walkAtRules(atrule => {\n              manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n            });\n          }\n          var _options_values1;\n          let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n          var _options_INTERNAL_FEATURES;\n          let internalFeatures = (_options_INTERNAL_FEATURES = options[INTERNAL_FEATURES]) !== null && _options_INTERNAL_FEATURES !== void 0 ? _options_INTERNAL_FEATURES : {};\n          let respectPrefix = (() => {\n            if (isArbitraryVariant) return false;\n            if (internalFeatures.respectPrefix === false) return false;\n            return true;\n          })();\n          formatStrings = formatStrings.map(format => format.map(str => ({\n            format: str,\n            respectPrefix\n          })));\n          manualFormatStrings = manualFormatStrings.map(format => ({\n            format,\n            respectPrefix\n          }));\n          let opts = {\n            candidate,\n            context\n          };\n          let result = formatStrings.map(formats => (0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n          if (manualFormatStrings.length > 0) {\n            result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, \"&\"));\n          }\n          return result;\n        }\n      });\n    }\n    return result;\n  };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */\nfunction markInvalidUtilityCandidate(context, candidate) {\n  if (!context.classCache.has(candidate)) {\n    return;\n  }\n  // Mark this as not being a real utility\n  context.notClassCache.add(candidate);\n  // Remove it from any candidate-specific caches\n  context.classCache.delete(candidate);\n  context.applyClassCache.delete(candidate);\n  context.candidateRuleMap.delete(candidate);\n  context.candidateRuleCache.delete(candidate);\n  // Ensure the stylesheet gets rebuilt\n  context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */\nfunction markInvalidUtilityNode(context, node) {\n  let candidate = node.raws.tailwind.candidate;\n  if (!candidate) {\n    return;\n  }\n  for (const entry of context.ruleCache) {\n    if (entry[1].raws.tailwind.candidate === candidate) {\n      context.ruleCache.delete(entry);\n      // context.postCssNodeCache.delete(node)\n    }\n  }\n\n  markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n  var _tailwindConfig_blocklist;\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    candidateRuleCache: new Map(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    // Seed the not class cache with the blocklist (which is only strings)\n    notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null,\n    variantOptions: new Map(),\n    markInvalidUtilityCandidate: candidate => markInvalidUtilityCandidate(context, candidate),\n    markInvalidUtilityNode: node => markInvalidUtilityNode(context, node)\n  };\n  let resolvedPlugins = resolvePlugins(context, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n  let existingContext;\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  }\n  let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);\n  // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n  if (existingContext) {\n    let [contextDependenciesChanged, mtimesToCommit] = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n    if (!contextDependenciesChanged && !cssDidChange) {\n      return [existingContext, false, mtimesToCommit];\n    }\n  }\n  // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n        for (let [tailwindConfigHash, context] of configContextMap) {\n          if (context === oldContext) {\n            configContextMap.delete(tailwindConfigHash);\n          }\n        }\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n  _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n  let context = createContext(tailwindConfig, [], root);\n  Object.assign(context, {\n    userConfigPath\n  });\n  let [, mtimesToCommit] = trackModified([...contextDependencies], getFileModifiedMap(context));\n  // ---\n  // Update all context tracking state\n  configContextMap.set(tailwindConfigHash, context);\n  contextMap.set(sourcePath, context);\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set());\n  }\n  contextSourcesMap.get(context).add(sourcePath);\n  return [context, true, mtimesToCommit];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","INTERNAL_FEATURES","isValidVariantFormatString","parseVariant","getFileModifiedMap","createContext","getContext","_fs","_interop_require_default","require","_url","_postcss","_dlv","_postcssselectorparser","_transformThemeValue","_parseObjectStyles","_prefixSelector","_isPlainObject","_escapeClassName","_nameClass","_interop_require_wildcard","_pluginUtils","_corePlugins","_sharedState","_toPath","_log","_negateValue","_isSyntacticallyValidPropertyValue","_generateRules","_cacheInvalidation","_offsets","_featureFlags","_formatVariantSelector","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","VARIANT_TYPES","AddVariant","for","MatchVariant","VARIANT_INFO","Base","Dynamic","prefix","context","selector","tailwindConfig","normalizeOptionTypes","type","options","types","concat","map","Array","isArray","preferOnConflict","parseVariantFormatString","input","parts","current","depth","idx","length","char","push","trim","Error","filter","part","insertInto","list","before","other","iidx","indexOf","Math","min","splice","parseStyles","styles","flatMap","style","isNode","getClasses","mutate","parser","selectors","allClasses","walkClasses","classNode","transformSync","extractCandidates","node","state","containsNonOnDemandable","classes","ignoreNot","walkPseudos","pseudo","remove","classCandidates","classCandidate","walkRules","rule","withIdentifiers","nodeMap","Map","containsNonOnDemandableSelectors","candidates","unshift","NOT_ON_DEMAND","c","format","startsWith","includes","variant","replace","fns","str","params","exec","_params_trim","wrap","atRule","reverse","api","fn","buildPluginApi","variantList","variantMap","offsets","classList","getConfigValue","path","defaultValue","applyConfiguredPrefix","prefixIdentifier","identifier","respectPrefix","resolveThemeValue","opts","toPath","variantIdentifier","postcss","e","config","theme","corePlugins","variants","addBase","base","prefixedIdentifier","offset","create","candidateRuleMap","sort","layer","addDefaults","group","declarations","groups","addComponents","components","defaultOptions","preserveSource","respectImportant","assign","add","addUtilities","utilities","matchUtilities","modifiers","wrapped","modifier","isOnlyPlugin","coercedType","utilityModifier","coerceValue","undefined","some","warn","extras","modifiersEnabled","flagEnabled","ruleSets","Boolean","declaration","withOffsets","matchComponents","addVariant","variantName","variantFunctions","variantFunction","args","modifySelectors","container","separator","result","variantOptions","matchVariant","variantFn","_options_id","id","isSpecial","_options_values","entries","values","variantInfo","_options_values1","hasDefault","NONE","_args_value","DEFAULT","fileModifiedMapCache","trackModified","files","fileModifiedMap","changed","mtimesToCommit","file","_fs_statSync","parsed","parse","pathname","hash","href","search","newModified","statSync","decodeURIComponent","throwIfNoEntry","mtimeMs","extractVariantAtRules","walkAtRules","nodes","collectLayerPlugins","root","layerPlugins","each","layerRule","resolvePlugins","corePluginList","variantPlugins","plugin","userPlugins","plugins","__isOptionsFunction","handler","beforeVariants","afterVariants","registerPlugins","Offsets","Set","pluginApi","pluginItem","recordVariants","forVariant","_context_tailwindConfig_safelist","safelist","checks","changedContent","content","extension","RegExp","patternMatchingCount","prefixLength","checkImportantUtils","check","pattern","source","util","utils","utilName","keys","formatClass","supportsNegativeValues","cls","slice","opacity","lastIndex","test","regex","count","_context_tailwindConfig_darkMode","_concat_","darkClassName","darkMode","parasiteUtilities","getClassOrder","sorted","a","z","sortedClassNames","className","rules","generateRules","BigInt","candidate","raws","tailwind","_sortedClassNames_get","order","parasiteIndex","getClassList","output","_utilOptions_types","utilOptions","negativeClasses","_utilOptions_modifiers","_context_tailwindConfig_theme_opacity","metadata","includeMetadata","_utilOptions_values","getVariants","isArbitrary","hasDash","clone","toString","_context_variantMap_get","_","formatStrings","localFormatStrings","_options_values_value","modifierFunction","getClassNameFromSelector","wrapper","ruleWithVariant","manualFormatStrings","after","modified","rebuiltBase","processSync","atrule","isArbitraryVariant","_options_INTERNAL_FEATURES","internalFeatures","formats","finalizeSelector","formatVariantSelector","markInvalidUtilityCandidate","classCache","notClassCache","delete","applyClassCache","candidateRuleCache","stylesheetCache","markInvalidUtilityNode","entry","ruleCache","_tailwindConfig_blocklist","disposables","blocklist","postCssNodeCache","resolvedPlugins","contextMap","configContextMap","contextSourcesMap","userConfigPath","tailwindConfigHash","contextDependencies","sourcePath","from","isConfigFile","env","DEBUG","console","log","existingContext","cssDidChange","hasContentChanged","contextDependenciesChanged","oldContext","size","disposable"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/lib/setupContextUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    INTERNAL_FEATURES: function() {\n        return INTERNAL_FEATURES;\n    },\n    isValidVariantFormatString: function() {\n        return isValidVariantFormatString;\n    },\n    parseVariant: function() {\n        return parseVariant;\n    },\n    getFileModifiedMap: function() {\n        return getFileModifiedMap;\n    },\n    createContext: function() {\n        return createContext;\n    },\n    getContext: function() {\n        return getContext;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _url = /*#__PURE__*/ _interop_require_default(require(\"url\"));\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/ _interop_require_default(require(\"dlv\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/ _interop_require_default(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/ _interop_require_default(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/ _interop_require_wildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/ _interop_require_default(require(\"../util/negateValue\"));\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidation = require(\"./cacheInvalidation.js\");\nconst _offsets = require(\"./offsets.js\");\nconst _featureFlags = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst INTERNAL_FEATURES = Symbol();\nconst VARIANT_TYPES = {\n    AddVariant: Symbol.for(\"ADD_VARIANT\"),\n    MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n    Base: 1 << 0,\n    Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes({ type =\"any\" , ...options }) {\n    let types = [].concat(type);\n    return {\n        ...options,\n        types: types.map((type)=>{\n            if (Array.isArray(type)) {\n                return {\n                    type: type[0],\n                    ...type[1]\n                };\n            }\n            return {\n                type,\n                preferOnConflict: false\n            };\n        })\n    };\n}\nfunction parseVariantFormatString(input) {\n    /** @type {string[]} */ let parts = [];\n    // When parsing whitespace around special characters are insignificant\n    // However, _inside_ of a variant they could be\n    // Because the selector could look like this\n    // @media { &[data-name=\"foo bar\"] }\n    // This is why we do not skip whitespace\n    let current = \"\";\n    let depth = 0;\n    for(let idx = 0; idx < input.length; idx++){\n        let char = input[idx];\n        if (char === \"\\\\\") {\n            // Escaped characters are not special\n            current += \"\\\\\" + input[++idx];\n        } else if (char === \"{\") {\n            // Nested rule: start\n            ++depth;\n            parts.push(current.trim());\n            current = \"\";\n        } else if (char === \"}\") {\n            // Nested rule: end\n            if (--depth < 0) {\n                throw new Error(`Your { and } are unbalanced.`);\n            }\n            parts.push(current.trim());\n            current = \"\";\n        } else {\n            // Normal character\n            current += char;\n        }\n    }\n    if (current.length > 0) {\n        parts.push(current.trim());\n    }\n    parts = parts.filter((part)=>part !== \"\");\n    return parts;\n}\nfunction insertInto(list, value, { before =[]  } = {}) {\n    before = [].concat(before);\n    if (before.length <= 0) {\n        list.push(value);\n        return;\n    }\n    let idx = list.length - 1;\n    for (let other of before){\n        let iidx = list.indexOf(other);\n        if (iidx === -1) continue;\n        idx = Math.min(idx, iidx);\n    }\n    list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n        return isNode ? style : (0, _parseObjectStyles.default)(style);\n    });\n}\nfunction getClasses(selector, mutate) {\n    let parser = (0, _postcssselectorparser.default)((selectors)=>{\n        let allClasses = [];\n        if (mutate) {\n            mutate(selectors);\n        }\n        selectors.walkClasses((classNode)=>{\n            allClasses.push(classNode.value);\n        });\n        return allClasses;\n    });\n    return parser.transformSync(selector);\n}\nfunction extractCandidates(node, state = {\n    containsNonOnDemandable: false\n}, depth = 0) {\n    let classes = [];\n    // Handle normal rules\n    if (node.type === \"rule\") {\n        // Ignore everything inside a :not(...). This allows you to write code like\n        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n        // not generated it. But now we will ignore everything inside a `:not`, so\n        // that it still gets generated.\n        function ignoreNot(selectors) {\n            selectors.walkPseudos((pseudo)=>{\n                if (pseudo.value === \":not\") {\n                    pseudo.remove();\n                }\n            });\n        }\n        for (let selector of node.selectors){\n            let classCandidates = getClasses(selector, ignoreNot);\n            // At least one of the selectors contains non-\"on-demandable\" candidates.\n            if (classCandidates.length === 0) {\n                state.containsNonOnDemandable = true;\n            }\n            for (let classCandidate of classCandidates){\n                classes.push(classCandidate);\n            }\n        }\n    } else if (node.type === \"atrule\") {\n        node.walkRules((rule)=>{\n            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){\n                classes.push(classCandidate);\n            }\n        });\n    }\n    if (depth === 0) {\n        return [\n            state.containsNonOnDemandable || classes.length === 0,\n            classes\n        ];\n    }\n    return classes;\n}\nfunction withIdentifiers(styles) {\n    return parseStyles(styles).flatMap((node)=>{\n        let nodeMap = new Map();\n        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n        // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n        if (containsNonOnDemandableSelectors) {\n            candidates.unshift(_sharedState.NOT_ON_DEMAND);\n        }\n        // However, it could be that it also contains \"on-demandable\" candidates.\n        // E.g.: `span, .foo {}`, in that case it should still be possible to use\n        // `@apply foo` for example.\n        return candidates.map((c)=>{\n            if (!nodeMap.has(node)) {\n                nodeMap.set(node, node);\n            }\n            return [\n                c,\n                nodeMap.get(node)\n            ];\n        });\n    });\n}\nfunction isValidVariantFormatString(format) {\n    return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n    variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n    let fns = parseVariantFormatString(variant).map((str)=>{\n        if (!str.startsWith(\"@\")) {\n            return ({ format  })=>format(str);\n        }\n        let [, name, params] = /@(\\S*)( .+|[({].*)?/g.exec(str);\n        var _params_trim;\n        return ({ wrap  })=>{\n            return wrap(_postcss.default.atRule({\n                name,\n                params: (_params_trim = params === null || params === void 0 ? void 0 : params.trim()) !== null && _params_trim !== void 0 ? _params_trim : \"\"\n            }));\n        };\n    }).reverse();\n    return (api)=>{\n        for (let fn of fns){\n            fn(api);\n        }\n    };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {\n    function getConfigValue(path, defaultValue) {\n        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n    }\n    function applyConfiguredPrefix(selector) {\n        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n    }\n    function prefixIdentifier(identifier, options) {\n        if (identifier === _sharedState.NOT_ON_DEMAND) {\n            return _sharedState.NOT_ON_DEMAND;\n        }\n        if (!options.respectPrefix) {\n            return identifier;\n        }\n        return context.tailwindConfig.prefix + identifier;\n    }\n    function resolveThemeValue(path, defaultValue, opts = {}) {\n        let parts = (0, _toPath.toPath)(path);\n        let value = getConfigValue([\n            \"theme\",\n            ...parts\n        ], defaultValue);\n        return (0, _transformThemeValue.default)(parts[0])(value, opts);\n    }\n    let variantIdentifier = 0;\n    let api = {\n        postcss: _postcss.default,\n        prefix: applyConfiguredPrefix,\n        e: _escapeClassName.default,\n        config: getConfigValue,\n        theme: resolveThemeValue,\n        corePlugins: (path)=>{\n            if (Array.isArray(tailwindConfig.corePlugins)) {\n                return tailwindConfig.corePlugins.includes(path);\n            }\n            return getConfigValue([\n                \"corePlugins\",\n                path\n            ], true);\n        },\n        variants: ()=>{\n            // Preserved for backwards compatibility but not used in v3.0+\n            return [];\n        },\n        addBase (base) {\n            for (let [identifier, rule] of withIdentifiers(base)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                let offset = offsets.create(\"base\");\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offset,\n                        layer: \"base\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */ addDefaults (group, declarations) {\n            const groups = {\n                [`@defaults ${group}`]: declarations\n            };\n            for (let [identifier, rule] of withIdentifiers(groups)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"defaults\"),\n                        layer: \"defaults\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        addComponents (components, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(components)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"components\"),\n                        layer: \"components\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        addUtilities (utilities, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(utilities)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"utilities\"),\n                        layer: \"utilities\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        matchUtilities: function(utilities, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: true,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"utilities\");\n            for(let identifier in utilities){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = utilities[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"utilities\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        matchComponents: function(components, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: false,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"components\");\n            for(let identifier in components){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = components[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"components\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        addVariant (variantName, variantFunctions, options = {}) {\n            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{\n                if (typeof variantFunction !== \"string\") {\n                    // Safelist public API functions\n                    return (api = {})=>{\n                        let { args , modifySelectors , container , separator , wrap , format  } = api;\n                        let result = variantFunction(Object.assign({\n                            modifySelectors,\n                            container,\n                            separator\n                        }, options.type === VARIANT_TYPES.MatchVariant && {\n                            args,\n                            wrap,\n                            format\n                        }));\n                        if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n                            throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                        }\n                        if (Array.isArray(result)) {\n                            return result.filter((variant)=>typeof variant === \"string\").map((variant)=>parseVariant(variant));\n                        }\n                        // result may be undefined with legacy variants that use APIs like `modifySelectors`\n                        // result may also be a postcss node if someone was returning the result from `modifySelectors`\n                        return result && typeof result === \"string\" && parseVariant(result)(api);\n                    };\n                }\n                if (!isValidVariantFormatString(variantFunction)) {\n                    throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                }\n                return parseVariant(variantFunction);\n            });\n            insertInto(variantList, variantName, options);\n            variantMap.set(variantName, variantFunctions);\n            context.variantOptions.set(variantName, options);\n        },\n        matchVariant (variant, variantFn, options) {\n            var _options_id;\n            // A unique identifier that \"groups\" these variants together.\n            // This is for internal use only which is why it is not present in the types\n            let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;\n            let isSpecial = variant === \"@\";\n            let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n            var _options_values;\n            for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})){\n                if (key === \"DEFAULT\") continue;\n                api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args , container  })=>{\n                    return variantFn(value, modifiersEnabled ? {\n                        modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                        container\n                    } : {\n                        container\n                    });\n                }, {\n                    ...options,\n                    value,\n                    id,\n                    type: VARIANT_TYPES.MatchVariant,\n                    variantInfo: VARIANT_INFO.Base\n                });\n            }\n            var _options_values1;\n            let hasDefault = \"DEFAULT\" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {});\n            api.addVariant(variant, ({ args , container  })=>{\n                if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n                    return null;\n                }\n                var // (JetBrains) plugins.\n                _args_value;\n                return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n                    modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                    container\n                } : {\n                    container\n                });\n            }, {\n                ...options,\n                id,\n                type: VARIANT_TYPES.MatchVariant,\n                variantInfo: VARIANT_INFO.Dynamic\n            });\n        }\n    };\n    return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n    if (!fileModifiedMapCache.has(context)) {\n        fileModifiedMapCache.set(context, new Map());\n    }\n    return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n    let changed = false;\n    let mtimesToCommit = new Map();\n    for (let file of files){\n        var _fs_statSync;\n        if (!file) continue;\n        let parsed = _url.default.parse(file);\n        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n        pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n        let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {\n            throwIfNoEntry: false\n        })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;\n        if (!newModified) {\n            continue;\n        }\n        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n            changed = true;\n        }\n        mtimesToCommit.set(file, newModified);\n    }\n    return [\n        changed,\n        mtimesToCommit\n    ];\n}\nfunction extractVariantAtRules(node) {\n    node.walkAtRules((atRule)=>{\n        if ([\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            extractVariantAtRules(atRule);\n            atRule.before(atRule.nodes);\n            atRule.remove();\n        }\n    });\n}\nfunction collectLayerPlugins(root) {\n    let layerPlugins = [];\n    root.each((node)=>{\n        if (node.type === \"atrule\" && [\n            \"responsive\",\n            \"variants\"\n        ].includes(node.name)) {\n            node.name = \"layer\";\n            node.params = \"utilities\";\n        }\n    });\n    // Walk @layer rules and treat them like plugins\n    root.walkAtRules(\"layer\", (layerRule)=>{\n        extractVariantAtRules(layerRule);\n        if (layerRule.params === \"base\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addBase  }) {\n                    addBase(node, {\n                        respectPrefix: false\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"components\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addComponents  }) {\n                    addComponents(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"utilities\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addUtilities  }) {\n                    addUtilities(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        }\n    });\n    return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n    let corePluginList = Object.entries({\n        ..._corePlugins.variantPlugins,\n        ..._corePlugins.corePlugins\n    }).map(([name, plugin])=>{\n        if (!context.tailwindConfig.corePlugins.includes(name)) {\n            return null;\n        }\n        return plugin;\n    }).filter(Boolean);\n    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{\n        if (plugin.__isOptionsFunction) {\n            plugin = plugin();\n        }\n        return typeof plugin === \"function\" ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root);\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [\n        _corePlugins.variantPlugins[\"pseudoElementVariants\"],\n        _corePlugins.variantPlugins[\"pseudoClassVariants\"],\n        _corePlugins.variantPlugins[\"ariaVariants\"],\n        _corePlugins.variantPlugins[\"dataVariants\"]\n    ];\n    let afterVariants = [\n        _corePlugins.variantPlugins[\"supportsVariants\"],\n        _corePlugins.variantPlugins[\"directionVariants\"],\n        _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n        _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n        _corePlugins.variantPlugins[\"darkVariants\"],\n        _corePlugins.variantPlugins[\"printVariant\"],\n        _corePlugins.variantPlugins[\"screenVariants\"],\n        _corePlugins.variantPlugins[\"orientationVariants\"]\n    ];\n    return [\n        ...corePluginList,\n        ...beforeVariants,\n        ...userPlugins,\n        ...afterVariants,\n        ...layerPlugins\n    ];\n}\nfunction registerPlugins(plugins, context) {\n    let variantList = [];\n    let variantMap = new Map();\n    context.variantMap = variantMap;\n    let offsets = new _offsets.Offsets();\n    context.offsets = offsets;\n    let classList = new Set();\n    let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n        variantList,\n        variantMap,\n        offsets,\n        classList\n    });\n    for (let plugin of plugins){\n        if (Array.isArray(plugin)) {\n            for (let pluginItem of plugin){\n                pluginItem(pluginApi);\n            }\n        } else {\n            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n        }\n    }\n    // Make sure to record bit masks for every variant\n    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);\n    // Build variantMap\n    for (let [variantName, variantFunctions] of variantMap.entries()){\n        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[\n                offsets.forVariant(variantName, idx),\n                variantFunction\n            ]));\n    }\n    var _context_tailwindConfig_safelist;\n    let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);\n    if (safelist.length > 0) {\n        let checks = [];\n        for (let value of safelist){\n            if (typeof value === \"string\") {\n                context.changedContent.push({\n                    content: value,\n                    extension: \"html\"\n                });\n                continue;\n            }\n            if (value instanceof RegExp) {\n                _log.default.warn(\"root-regex\", [\n                    \"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\n                    \"Update your `safelist` configuration to eliminate this warning.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n                continue;\n            }\n            checks.push(value);\n        }\n        if (checks.length > 0) {\n            let patternMatchingCount = new Map();\n            let prefixLength = context.tailwindConfig.prefix.length;\n            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes(\"!\"));\n            for (let util of classList){\n                let utils = Array.isArray(util) ? (()=>{\n                    let [utilName, options] = util;\n                    var _options_values;\n                    let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});\n                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));\n                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                        // This is the normal negated version\n                        // e.g. `-inset-1` or `-tw-inset-1`\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"-\" + cls)\n                        ];\n                        // This is the negated version *after* the prefix\n                        // e.g. `tw--inset-1`\n                        // The prefix is already attached to util name\n                        // So we add the negative after the prefix\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))\n                        ];\n                    }\n                    if (options.types.some(({ type  })=>type === \"color\")) {\n                        classes = [\n                            ...classes,\n                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))\n                        ];\n                    }\n                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"!\" + cls)\n                        ];\n                    }\n                    return classes;\n                })() : [\n                    util\n                ];\n                for (let util of utils){\n                    for (let { pattern , variants =[]  } of checks){\n                        // RegExp with the /g flag are stateful, so let's reset the last\n                        // index pointer to reset the state.\n                        pattern.lastIndex = 0;\n                        if (!patternMatchingCount.has(pattern)) {\n                            patternMatchingCount.set(pattern, 0);\n                        }\n                        if (!pattern.test(util)) continue;\n                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                        context.changedContent.push({\n                            content: util,\n                            extension: \"html\"\n                        });\n                        for (let variant of variants){\n                            context.changedContent.push({\n                                content: variant + context.tailwindConfig.separator + util,\n                                extension: \"html\"\n                            });\n                        }\n                    }\n                }\n            }\n            for (let [regex, count] of patternMatchingCount.entries()){\n                if (count !== 0) continue;\n                _log.default.warn([\n                    `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n                    \"Fix this pattern or remove it from your `safelist` configuration.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n            }\n        }\n    }\n    var _context_tailwindConfig_darkMode, _concat_;\n    let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : \"media\")[1]) !== null && _concat_ !== void 0 ? _concat_ : \"dark\";\n    // A list of utilities that are used by certain Tailwind CSS utilities but\n    // that don't exist on their own. This will result in them \"not existing\" and\n    // sorting could be weird since you still require them in order to make the\n    // host utilities work properly. (Thanks Biology)\n    let parasiteUtilities = [\n        prefix(context, darkClassName),\n        prefix(context, \"group\"),\n        prefix(context, \"peer\")\n    ];\n    context.getClassOrder = function getClassOrder(classes) {\n        // Sort classes so they're ordered in a deterministic manner\n        let sorted = [\n            ...classes\n        ].sort((a, z)=>{\n            if (a === z) return 0;\n            if (a < z) return -1;\n            return 1;\n        });\n        // Non-util classes won't be generated, so we default them to null\n        let sortedClassNames = new Map(sorted.map((className)=>[\n                className,\n                null\n            ]));\n        // Sort all classes in order\n        // Non-tailwind classes won't be generated and will be left as `null`\n        let rules = (0, _generateRules.generateRules)(new Set(sorted), context);\n        rules = context.offsets.sort(rules);\n        let idx = BigInt(parasiteUtilities.length);\n        for (const [, rule] of rules){\n            let candidate = rule.raws.tailwind.candidate;\n            var _sortedClassNames_get;\n            // When multiple rules match a candidate\n            // always take the position of the first one\n            sortedClassNames.set(candidate, (_sortedClassNames_get = sortedClassNames.get(candidate)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : idx++);\n        }\n        return classes.map((className)=>{\n            var _sortedClassNames_get;\n            let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;\n            let parasiteIndex = parasiteUtilities.indexOf(className);\n            if (order === null && parasiteIndex !== -1) {\n                // This will make sure that it is at the very beginning of the\n                // `components` layer which technically means 'before any\n                // components'.\n                order = BigInt(parasiteIndex);\n            }\n            return [\n                className,\n                order\n            ];\n        });\n    };\n    // Generate a list of strings for autocompletion purposes, e.g.\n    // ['uppercase', 'lowercase', ...]\n    context.getClassList = function getClassList(options = {}) {\n        let output = [];\n        for (let util of classList){\n            if (Array.isArray(util)) {\n                var _utilOptions_types;\n                let [utilName, utilOptions] = util;\n                let negativeClasses = [];\n                var _utilOptions_modifiers;\n                let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});\n                if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({ type  })=>type === \"color\")) {\n                    var _context_tailwindConfig_theme_opacity;\n                    modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));\n                }\n                let metadata = {\n                    modifiers\n                };\n                let includeMetadata = options.includeMetadata && modifiers.length > 0;\n                var _utilOptions_values;\n                for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})){\n                    // Ignore undefined and null values\n                    if (value == null) {\n                        continue;\n                    }\n                    let cls = (0, _nameClass.formatClass)(utilName, key);\n                    output.push(includeMetadata ? [\n                        cls,\n                        metadata\n                    ] : cls);\n                    if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n                        let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);\n                        negativeClasses.push(includeMetadata ? [\n                            cls,\n                            metadata\n                        ] : cls);\n                    }\n                }\n                output.push(...negativeClasses);\n            } else {\n                output.push(util);\n            }\n        }\n        return output;\n    };\n    // Generate a list of available variants with meta information of the type of variant.\n    context.getVariants = function getVariants() {\n        let result = [];\n        for (let [name, options] of context.variantOptions.entries()){\n            if (options.variantInfo === VARIANT_INFO.Base) continue;\n            var _options_values;\n            result.push({\n                name,\n                isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n                values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),\n                hasDash: name !== \"@\",\n                selectors ({ modifier , value  } = {}) {\n                    let candidate = \"__TAILWIND_PLACEHOLDER__\";\n                    let rule = _postcss.default.rule({\n                        selector: `.${candidate}`\n                    });\n                    let container = _postcss.default.root({\n                        nodes: [\n                            rule.clone()\n                        ]\n                    });\n                    let before = container.toString();\n                    var _context_variantMap_get;\n                    let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn])=>fn);\n                    let formatStrings = [];\n                    for (let fn of fns){\n                        var _options_values;\n                        let localFormatStrings = [];\n                        var _options_values_value;\n                        let api = {\n                            args: {\n                                modifier,\n                                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value\n                            },\n                            separator: context.tailwindConfig.separator,\n                            modifySelectors (modifierFunction) {\n                                // Run the modifierFunction over each rule\n                                container.each((rule)=>{\n                                    if (rule.type !== \"rule\") {\n                                        return;\n                                    }\n                                    rule.selectors = rule.selectors.map((selector)=>{\n                                        return modifierFunction({\n                                            get className () {\n                                                return (0, _generateRules.getClassNameFromSelector)(selector);\n                                            },\n                                            selector\n                                        });\n                                    });\n                                });\n                                return container;\n                            },\n                            format (str) {\n                                localFormatStrings.push(str);\n                            },\n                            wrap (wrapper) {\n                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n                            },\n                            container\n                        };\n                        let ruleWithVariant = fn(api);\n                        if (localFormatStrings.length > 0) {\n                            formatStrings.push(localFormatStrings);\n                        }\n                        if (Array.isArray(ruleWithVariant)) {\n                            for (let variantFunction of ruleWithVariant){\n                                localFormatStrings = [];\n                                variantFunction(api);\n                                formatStrings.push(localFormatStrings);\n                            }\n                        }\n                    }\n                    // Reverse engineer the result of the `container`\n                    let manualFormatStrings = [];\n                    let after = container.toString();\n                    if (before !== after) {\n                        // Figure out all selectors\n                        container.walkRules((rule)=>{\n                            let modified = rule.selector;\n                            // Rebuild the base selector, this is what plugin authors would do\n                            // as well. E.g.: `${variant}${separator}${className}`.\n                            // However, plugin authors probably also prepend or append certain\n                            // classes, pseudos, ids, ...\n                            let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{\n                                selectors.walkClasses((classNode)=>{\n                                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                                });\n                            }).processSync(modified);\n                            // Now that we know the original selector, the new selector, and\n                            // the rebuild part in between, we can replace the part that plugin\n                            // authors need to rebuild with `&`, and eventually store it in the\n                            // collectedFormats. Similar to what `format('...')` would do.\n                            //\n                            // E.g.:\n                            //                   variant: foo\n                            //                  selector: .markdown > p\n                            //      modified (by plugin): .foo .foo\\\\:markdown > p\n                            //    rebuiltBase (internal): .foo\\\\:markdown > p\n                            //                    format: .foo &\n                            manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n                        });\n                        // Figure out all atrules\n                        container.walkAtRules((atrule)=>{\n                            manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n                        });\n                    }\n                    var _options_values1;\n                    let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n                    var _options_INTERNAL_FEATURES;\n                    let internalFeatures = (_options_INTERNAL_FEATURES = options[INTERNAL_FEATURES]) !== null && _options_INTERNAL_FEATURES !== void 0 ? _options_INTERNAL_FEATURES : {};\n                    let respectPrefix = (()=>{\n                        if (isArbitraryVariant) return false;\n                        if (internalFeatures.respectPrefix === false) return false;\n                        return true;\n                    })();\n                    formatStrings = formatStrings.map((format)=>format.map((str)=>({\n                                format: str,\n                                respectPrefix\n                            })));\n                    manualFormatStrings = manualFormatStrings.map((format)=>({\n                            format,\n                            respectPrefix\n                        }));\n                    let opts = {\n                        candidate,\n                        context\n                    };\n                    let result = formatStrings.map((formats)=>(0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n                    if (manualFormatStrings.length > 0) {\n                        result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, \"&\"));\n                    }\n                    return result;\n                }\n            });\n        }\n        return result;\n    };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */ function markInvalidUtilityCandidate(context, candidate) {\n    if (!context.classCache.has(candidate)) {\n        return;\n    }\n    // Mark this as not being a real utility\n    context.notClassCache.add(candidate);\n    // Remove it from any candidate-specific caches\n    context.classCache.delete(candidate);\n    context.applyClassCache.delete(candidate);\n    context.candidateRuleMap.delete(candidate);\n    context.candidateRuleCache.delete(candidate);\n    // Ensure the stylesheet gets rebuilt\n    context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */ function markInvalidUtilityNode(context, node) {\n    let candidate = node.raws.tailwind.candidate;\n    if (!candidate) {\n        return;\n    }\n    for (const entry of context.ruleCache){\n        if (entry[1].raws.tailwind.candidate === candidate) {\n            context.ruleCache.delete(entry);\n        // context.postCssNodeCache.delete(node)\n        }\n    }\n    markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n    var _tailwindConfig_blocklist;\n    let context = {\n        disposables: [],\n        ruleCache: new Set(),\n        candidateRuleCache: new Map(),\n        classCache: new Map(),\n        applyClassCache: new Map(),\n        // Seed the not class cache with the blocklist (which is only strings)\n        notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),\n        postCssNodeCache: new Map(),\n        candidateRuleMap: new Map(),\n        tailwindConfig,\n        changedContent: changedContent,\n        variantMap: new Map(),\n        stylesheetCache: null,\n        variantOptions: new Map(),\n        markInvalidUtilityCandidate: (candidate)=>markInvalidUtilityCandidate(context, candidate),\n        markInvalidUtilityNode: (node)=>markInvalidUtilityNode(context, node)\n    };\n    let resolvedPlugins = resolvePlugins(context, root);\n    registerPlugins(resolvedPlugins, context);\n    return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n    let sourcePath = result.opts.from;\n    let isConfigFile = userConfigPath !== null;\n    _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n    let existingContext;\n    if (isConfigFile && contextMap.has(sourcePath)) {\n        existingContext = contextMap.get(sourcePath);\n    } else if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        existingContext = context;\n    }\n    let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);\n    // If there's already a context in the cache and we don't need to\n    // reset the context, return the cached context.\n    if (existingContext) {\n        let [contextDependenciesChanged, mtimesToCommit] = trackModified([\n            ...contextDependencies\n        ], getFileModifiedMap(existingContext));\n        if (!contextDependenciesChanged && !cssDidChange) {\n            return [\n                existingContext,\n                false,\n                mtimesToCommit\n            ];\n        }\n    }\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n        let oldContext = contextMap.get(sourcePath);\n        if (contextSourcesMap.has(oldContext)) {\n            contextSourcesMap.get(oldContext).delete(sourcePath);\n            if (contextSourcesMap.get(oldContext).size === 0) {\n                contextSourcesMap.delete(oldContext);\n                for (let [tailwindConfigHash, context] of configContextMap){\n                    if (context === oldContext) {\n                        configContextMap.delete(tailwindConfigHash);\n                    }\n                }\n                for (let disposable of oldContext.disposables.splice(0)){\n                    disposable(oldContext);\n                }\n            }\n        }\n    }\n    _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n    let context = createContext(tailwindConfig, [], root);\n    Object.assign(context, {\n        userConfigPath\n    });\n    let [, mtimesToCommit] = trackModified([\n        ...contextDependencies\n    ], getFileModifiedMap(context));\n    // ---\n    // Update all context tracking state\n    configContextMap.set(tailwindConfigHash, context);\n    contextMap.set(sourcePath, context);\n    if (!contextSourcesMap.has(context)) {\n        contextSourcesMap.set(context, new Set());\n    }\n    contextSourcesMap.get(context).add(sourcePath);\n    return [\n        context,\n        true,\n        mtimesToCommit\n    ];\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACF,SAASC,OAAOA,CAACC,MAAM,EAAEC,GAAG,EAAE;EAC1B,KAAI,IAAIC,IAAI,IAAID,GAAG,EAACN,MAAM,CAACC,cAAc,CAACI,MAAM,EAAEE,IAAI,EAAE;IACpDC,UAAU,EAAE,IAAI;IAChBC,GAAG,EAAEH,GAAG,CAACC,IAAI;EACjB,CAAC,CAAC;AACN;AACAH,OAAO,CAACF,OAAO,EAAE;EACbQ,iBAAiB,EAAE,SAAAA,CAAA,EAAW;IAC1B,OAAOA,iBAAiB;EAC5B,CAAC;EACDC,0BAA0B,EAAE,SAAAA,CAAA,EAAW;IACnC,OAAOA,0BAA0B;EACrC,CAAC;EACDC,YAAY,EAAE,SAAAA,CAAA,EAAW;IACrB,OAAOA,YAAY;EACvB,CAAC;EACDC,kBAAkB,EAAE,SAAAA,CAAA,EAAW;IAC3B,OAAOA,kBAAkB;EAC7B,CAAC;EACDC,aAAa,EAAE,SAAAA,CAAA,EAAW;IACtB,OAAOA,aAAa;EACxB,CAAC;EACDC,UAAU,EAAE,SAAAA,CAAA,EAAW;IACnB,OAAOA,UAAU;EACrB;AACJ,CAAC,CAAC;AACF,MAAMC,GAAG,GAAG,aAAcC,wBAAwB,CAACC,OAAO,CAAC,IAAI,CAAC,CAAC;AACjE,MAAMC,IAAI,GAAG,aAAcF,wBAAwB,CAACC,OAAO,CAAC,KAAK,CAAC,CAAC;AACnE,MAAME,QAAQ,GAAG,aAAcH,wBAAwB,CAACC,OAAO,CAAC,SAAS,CAAC,CAAC;AAC3E,MAAMG,IAAI,GAAG,aAAcJ,wBAAwB,CAACC,OAAO,CAAC,KAAK,CAAC,CAAC;AACnE,MAAMI,sBAAsB,GAAG,aAAcL,wBAAwB,CAACC,OAAO,CAAC,yBAAyB,CAAC,CAAC;AACzG,MAAMK,oBAAoB,GAAG,aAAcN,wBAAwB,CAACC,OAAO,CAAC,6BAA6B,CAAC,CAAC;AAC3G,MAAMM,kBAAkB,GAAG,aAAcP,wBAAwB,CAACC,OAAO,CAAC,2BAA2B,CAAC,CAAC;AACvG,MAAMO,eAAe,GAAG,aAAcR,wBAAwB,CAACC,OAAO,CAAC,wBAAwB,CAAC,CAAC;AACjG,MAAMQ,cAAc,GAAG,aAAcT,wBAAwB,CAACC,OAAO,CAAC,uBAAuB,CAAC,CAAC;AAC/F,MAAMS,gBAAgB,GAAG,aAAcV,wBAAwB,CAACC,OAAO,CAAC,yBAAyB,CAAC,CAAC;AACnG,MAAMU,UAAU,GAAG,aAAcC,yBAAyB,CAACX,OAAO,CAAC,mBAAmB,CAAC,CAAC;AACxF,MAAMY,YAAY,GAAGZ,OAAO,CAAC,qBAAqB,CAAC;AACnD,MAAMa,YAAY,GAAGb,OAAO,CAAC,gBAAgB,CAAC;AAC9C,MAAMc,YAAY,GAAG,aAAcH,yBAAyB,CAACX,OAAO,CAAC,eAAe,CAAC,CAAC;AACtF,MAAMe,OAAO,GAAGf,OAAO,CAAC,gBAAgB,CAAC;AACzC,MAAMgB,IAAI,GAAG,aAAcjB,wBAAwB,CAACC,OAAO,CAAC,aAAa,CAAC,CAAC;AAC3E,MAAMiB,YAAY,GAAG,aAAclB,wBAAwB,CAACC,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAC3F,MAAMkB,kCAAkC,GAAG,aAAcnB,wBAAwB,CAACC,OAAO,CAAC,2CAA2C,CAAC,CAAC;AACvI,MAAMmB,cAAc,GAAGnB,OAAO,CAAC,iBAAiB,CAAC;AACjD,MAAMoB,kBAAkB,GAAGpB,OAAO,CAAC,wBAAwB,CAAC;AAC5D,MAAMqB,QAAQ,GAAGrB,OAAO,CAAC,cAAc,CAAC;AACxC,MAAMsB,aAAa,GAAGtB,OAAO,CAAC,oBAAoB,CAAC;AACnD,MAAMuB,sBAAsB,GAAGvB,OAAO,CAAC,+BAA+B,CAAC;AACvE,SAASD,wBAAwBA,CAACyB,GAAG,EAAE;EACnC,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IACjCE,OAAO,EAAEF;EACb,CAAC;AACL;AACA,SAASG,wBAAwBA,CAACC,WAAW,EAAE;EAC3C,IAAI,OAAOC,OAAO,KAAK,UAAU,EAAE,OAAO,IAAI;EAC9C,IAAIC,iBAAiB,GAAG,IAAID,OAAO,CAAC,CAAC;EACrC,IAAIE,gBAAgB,GAAG,IAAIF,OAAO,CAAC,CAAC;EACpC,OAAO,CAACF,wBAAwB,GAAG,SAAAA,CAASC,WAAW,EAAE;IACrD,OAAOA,WAAW,GAAGG,gBAAgB,GAAGD,iBAAiB;EAC7D,CAAC,EAAEF,WAAW,CAAC;AACnB;AACA,SAASjB,yBAAyBA,CAACa,GAAG,EAAEI,WAAW,EAAE;EACjD,IAAI,CAACA,WAAW,IAAIJ,GAAG,IAAIA,GAAG,CAACC,UAAU,EAAE;IACvC,OAAOD,GAAG;EACd;EACA,IAAIA,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;IACtE,OAAO;MACHE,OAAO,EAAEF;IACb,CAAC;EACL;EACA,IAAIQ,KAAK,GAAGL,wBAAwB,CAACC,WAAW,CAAC;EACjD,IAAII,KAAK,IAAIA,KAAK,CAACC,GAAG,CAACT,GAAG,CAAC,EAAE;IACzB,OAAOQ,KAAK,CAACzC,GAAG,CAACiC,GAAG,CAAC;EACzB;EACA,IAAIU,MAAM,GAAG,CAAC,CAAC;EACf,IAAIC,qBAAqB,GAAGrD,MAAM,CAACC,cAAc,IAAID,MAAM,CAACsD,wBAAwB;EACpF,KAAI,IAAIC,GAAG,IAAIb,GAAG,EAAC;IACf,IAAIa,GAAG,KAAK,SAAS,IAAIvD,MAAM,CAACwD,SAAS,CAACC,cAAc,CAACC,IAAI,CAAChB,GAAG,EAAEa,GAAG,CAAC,EAAE;MACrE,IAAII,IAAI,GAAGN,qBAAqB,GAAGrD,MAAM,CAACsD,wBAAwB,CAACZ,GAAG,EAAEa,GAAG,CAAC,GAAG,IAAI;MACnF,IAAII,IAAI,KAAKA,IAAI,CAAClD,GAAG,IAAIkD,IAAI,CAACC,GAAG,CAAC,EAAE;QAChC5D,MAAM,CAACC,cAAc,CAACmD,MAAM,EAAEG,GAAG,EAAEI,IAAI,CAAC;MAC5C,CAAC,MAAM;QACHP,MAAM,CAACG,GAAG,CAAC,GAAGb,GAAG,CAACa,GAAG,CAAC;MAC1B;IACJ;EACJ;EACAH,MAAM,CAACR,OAAO,GAAGF,GAAG;EACpB,IAAIQ,KAAK,EAAE;IACPA,KAAK,CAACU,GAAG,CAAClB,GAAG,EAAEU,MAAM,CAAC;EAC1B;EACA,OAAOA,MAAM;AACjB;AACA,MAAM1C,iBAAiB,GAAGmD,MAAM,CAAC,CAAC;AAClC,MAAMC,aAAa,GAAG;EAClBC,UAAU,EAAEF,MAAM,CAACG,GAAG,CAAC,aAAa,CAAC;EACrCC,YAAY,EAAEJ,MAAM,CAACG,GAAG,CAAC,eAAe;AAC5C,CAAC;AACD,MAAME,YAAY,GAAG;EACjBC,IAAI,EAAE,CAAC,IAAI,CAAC;EACZC,OAAO,EAAE,CAAC,IAAI;AAClB,CAAC;AACD,SAASC,MAAMA,CAACC,OAAO,EAAEC,QAAQ,EAAE;EAC/B,IAAIF,MAAM,GAAGC,OAAO,CAACE,cAAc,CAACH,MAAM;EAC1C,OAAO,OAAOA,MAAM,KAAK,UAAU,GAAGA,MAAM,CAACE,QAAQ,CAAC,GAAGF,MAAM,GAAGE,QAAQ;AAC9E;AACA,SAASE,oBAAoBA,CAAC;EAAEC,IAAI,GAAE,KAAK;EAAG,GAAGC;AAAQ,CAAC,EAAE;EACxD,IAAIC,KAAK,GAAG,EAAE,CAACC,MAAM,CAACH,IAAI,CAAC;EAC3B,OAAO;IACH,GAAGC,OAAO;IACVC,KAAK,EAAEA,KAAK,CAACE,GAAG,CAAEJ,IAAI,IAAG;MACrB,IAAIK,KAAK,CAACC,OAAO,CAACN,IAAI,CAAC,EAAE;QACrB,OAAO;UACHA,IAAI,EAAEA,IAAI,CAAC,CAAC,CAAC;UACb,GAAGA,IAAI,CAAC,CAAC;QACb,CAAC;MACL;MACA,OAAO;QACHA,IAAI;QACJO,gBAAgB,EAAE;MACtB,CAAC;IACL,CAAC;EACL,CAAC;AACL;AACA,SAASC,wBAAwBA,CAACC,KAAK,EAAE;EACrC,uBAAwB,IAAIC,KAAK,GAAG,EAAE;EACtC;EACA;EACA;EACA;EACA;EACA,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,KAAK,GAAG,CAAC;EACb,KAAI,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGJ,KAAK,CAACK,MAAM,EAAED,GAAG,EAAE,EAAC;IACvC,IAAIE,IAAI,GAAGN,KAAK,CAACI,GAAG,CAAC;IACrB,IAAIE,IAAI,KAAK,IAAI,EAAE;MACf;MACAJ,OAAO,IAAI,IAAI,GAAGF,KAAK,CAAC,EAAEI,GAAG,CAAC;IAClC,CAAC,MAAM,IAAIE,IAAI,KAAK,GAAG,EAAE;MACrB;MACA,EAAEH,KAAK;MACPF,KAAK,CAACM,IAAI,CAACL,OAAO,CAACM,IAAI,CAAC,CAAC,CAAC;MAC1BN,OAAO,GAAG,EAAE;IAChB,CAAC,MAAM,IAAII,IAAI,KAAK,GAAG,EAAE;MACrB;MACA,IAAI,EAAEH,KAAK,GAAG,CAAC,EAAE;QACb,MAAM,IAAIM,KAAK,CAAE,8BAA6B,CAAC;MACnD;MACAR,KAAK,CAACM,IAAI,CAACL,OAAO,CAACM,IAAI,CAAC,CAAC,CAAC;MAC1BN,OAAO,GAAG,EAAE;IAChB,CAAC,MAAM;MACH;MACAA,OAAO,IAAII,IAAI;IACnB;EACJ;EACA,IAAIJ,OAAO,CAACG,MAAM,GAAG,CAAC,EAAE;IACpBJ,KAAK,CAACM,IAAI,CAACL,OAAO,CAACM,IAAI,CAAC,CAAC,CAAC;EAC9B;EACAP,KAAK,GAAGA,KAAK,CAACS,MAAM,CAAEC,IAAI,IAAGA,IAAI,KAAK,EAAE,CAAC;EACzC,OAAOV,KAAK;AAChB;AACA,SAASW,UAAUA,CAACC,IAAI,EAAE7F,KAAK,EAAE;EAAE8F,MAAM,GAAE;AAAI,CAAC,GAAG,CAAC,CAAC,EAAE;EACnDA,MAAM,GAAG,EAAE,CAACpB,MAAM,CAACoB,MAAM,CAAC;EAC1B,IAAIA,MAAM,CAACT,MAAM,IAAI,CAAC,EAAE;IACpBQ,IAAI,CAACN,IAAI,CAACvF,KAAK,CAAC;IAChB;EACJ;EACA,IAAIoF,GAAG,GAAGS,IAAI,CAACR,MAAM,GAAG,CAAC;EACzB,KAAK,IAAIU,KAAK,IAAID,MAAM,EAAC;IACrB,IAAIE,IAAI,GAAGH,IAAI,CAACI,OAAO,CAACF,KAAK,CAAC;IAC9B,IAAIC,IAAI,KAAK,CAAC,CAAC,EAAE;IACjBZ,GAAG,GAAGc,IAAI,CAACC,GAAG,CAACf,GAAG,EAAEY,IAAI,CAAC;EAC7B;EACAH,IAAI,CAACO,MAAM,CAAChB,GAAG,EAAE,CAAC,EAAEpF,KAAK,CAAC;AAC9B;AACA,SAASqG,WAAWA,CAACC,MAAM,EAAE;EACzB,IAAI,CAAC1B,KAAK,CAACC,OAAO,CAACyB,MAAM,CAAC,EAAE;IACxB,OAAOD,WAAW,CAAC,CACfC,MAAM,CACT,CAAC;EACN;EACA,OAAOA,MAAM,CAACC,OAAO,CAAEC,KAAK,IAAG;IAC3B,IAAIC,MAAM,GAAG,CAAC7B,KAAK,CAACC,OAAO,CAAC2B,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAEjF,cAAc,CAACkB,OAAO,EAAE+D,KAAK,CAAC;IACzE,OAAOC,MAAM,GAAGD,KAAK,GAAG,CAAC,CAAC,EAAEnF,kBAAkB,CAACoB,OAAO,EAAE+D,KAAK,CAAC;EAClE,CAAC,CAAC;AACN;AACA,SAASE,UAAUA,CAACtC,QAAQ,EAAEuC,MAAM,EAAE;EAClC,IAAIC,MAAM,GAAG,CAAC,CAAC,EAAEzF,sBAAsB,CAACsB,OAAO,EAAGoE,SAAS,IAAG;IAC1D,IAAIC,UAAU,GAAG,EAAE;IACnB,IAAIH,MAAM,EAAE;MACRA,MAAM,CAACE,SAAS,CAAC;IACrB;IACAA,SAAS,CAACE,WAAW,CAAEC,SAAS,IAAG;MAC/BF,UAAU,CAACvB,IAAI,CAACyB,SAAS,CAAChH,KAAK,CAAC;IACpC,CAAC,CAAC;IACF,OAAO8G,UAAU;EACrB,CAAC,CAAC;EACF,OAAOF,MAAM,CAACK,aAAa,CAAC7C,QAAQ,CAAC;AACzC;AACA,SAAS8C,iBAAiBA,CAACC,IAAI,EAAEC,KAAK,GAAG;EACrCC,uBAAuB,EAAE;AAC7B,CAAC,EAAElC,KAAK,GAAG,CAAC,EAAE;EACV,IAAImC,OAAO,GAAG,EAAE;EAChB;EACA,IAAIH,IAAI,CAAC5C,IAAI,KAAK,MAAM,EAAE;IACtB;IACA;IACA;IACA;IACA,SAASgD,SAASA,CAACV,SAAS,EAAE;MAC1BA,SAAS,CAACW,WAAW,CAAEC,MAAM,IAAG;QAC5B,IAAIA,MAAM,CAACzH,KAAK,KAAK,MAAM,EAAE;UACzByH,MAAM,CAACC,MAAM,CAAC,CAAC;QACnB;MACJ,CAAC,CAAC;IACN;IACA,KAAK,IAAItD,QAAQ,IAAI+C,IAAI,CAACN,SAAS,EAAC;MAChC,IAAIc,eAAe,GAAGjB,UAAU,CAACtC,QAAQ,EAAEmD,SAAS,CAAC;MACrD;MACA,IAAII,eAAe,CAACtC,MAAM,KAAK,CAAC,EAAE;QAC9B+B,KAAK,CAACC,uBAAuB,GAAG,IAAI;MACxC;MACA,KAAK,IAAIO,cAAc,IAAID,eAAe,EAAC;QACvCL,OAAO,CAAC/B,IAAI,CAACqC,cAAc,CAAC;MAChC;IACJ;EACJ,CAAC,MAAM,IAAIT,IAAI,CAAC5C,IAAI,KAAK,QAAQ,EAAE;IAC/B4C,IAAI,CAACU,SAAS,CAAEC,IAAI,IAAG;MACnB,KAAK,IAAIF,cAAc,IAAIE,IAAI,CAACjB,SAAS,CAACN,OAAO,CAAEnC,QAAQ,IAAGsC,UAAU,CAACtC,QAAQ,CAAC,CAAC,EAAC;QAChFkD,OAAO,CAAC/B,IAAI,CAACqC,cAAc,CAAC;MAChC;IACJ,CAAC,CAAC;EACN;EACA,IAAIzC,KAAK,KAAK,CAAC,EAAE;IACb,OAAO,CACHiC,KAAK,CAACC,uBAAuB,IAAIC,OAAO,CAACjC,MAAM,KAAK,CAAC,EACrDiC,OAAO,CACV;EACL;EACA,OAAOA,OAAO;AAClB;AACA,SAASS,eAAeA,CAACzB,MAAM,EAAE;EAC7B,OAAOD,WAAW,CAACC,MAAM,CAAC,CAACC,OAAO,CAAEY,IAAI,IAAG;IACvC,IAAIa,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IACvB,IAAI,CAACC,gCAAgC,EAAEC,UAAU,CAAC,GAAGjB,iBAAiB,CAACC,IAAI,CAAC;IAC5E;IACA,IAAIe,gCAAgC,EAAE;MAClCC,UAAU,CAACC,OAAO,CAACvG,YAAY,CAACwG,aAAa,CAAC;IAClD;IACA;IACA;IACA;IACA,OAAOF,UAAU,CAACxD,GAAG,CAAE2D,CAAC,IAAG;MACvB,IAAI,CAACN,OAAO,CAAChF,GAAG,CAACmE,IAAI,CAAC,EAAE;QACpBa,OAAO,CAACvE,GAAG,CAAC0D,IAAI,EAAEA,IAAI,CAAC;MAC3B;MACA,OAAO,CACHmB,CAAC,EACDN,OAAO,CAAC1H,GAAG,CAAC6G,IAAI,CAAC,CACpB;IACL,CAAC,CAAC;EACN,CAAC,CAAC;AACN;AACA,SAAS3G,0BAA0BA,CAAC+H,MAAM,EAAE;EACxC,OAAOA,MAAM,CAACC,UAAU,CAAC,GAAG,CAAC,IAAID,MAAM,CAACE,QAAQ,CAAC,GAAG,CAAC;AACzD;AACA,SAAShI,YAAYA,CAACiI,OAAO,EAAE;EAC3BA,OAAO,GAAGA,OAAO,CAACC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,SAAS,EAAE,GAAG,CAAC,CAACnD,IAAI,CAAC,CAAC;EACpE,IAAIoD,GAAG,GAAG7D,wBAAwB,CAAC2D,OAAO,CAAC,CAAC/D,GAAG,CAAEkE,GAAG,IAAG;IACnD,IAAI,CAACA,GAAG,CAACL,UAAU,CAAC,GAAG,CAAC,EAAE;MACtB,OAAO,CAAC;QAAED;MAAQ,CAAC,KAAGA,MAAM,CAACM,GAAG,CAAC;IACrC;IACA,IAAI,GAAGzI,IAAI,EAAE0I,MAAM,CAAC,GAAG,sBAAsB,CAACC,IAAI,CAACF,GAAG,CAAC;IACvD,IAAIG,YAAY;IAChB,OAAO,CAAC;MAAEC;IAAM,CAAC,KAAG;MAChB,OAAOA,IAAI,CAAChI,QAAQ,CAACwB,OAAO,CAACyG,MAAM,CAAC;QAChC9I,IAAI;QACJ0I,MAAM,EAAE,CAACE,YAAY,GAAGF,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACtD,IAAI,CAAC,CAAC,MAAM,IAAI,IAAIwD,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG;MAChJ,CAAC,CAAC,CAAC;IACP,CAAC;EACL,CAAC,CAAC,CAACG,OAAO,CAAC,CAAC;EACZ,OAAQC,GAAG,IAAG;IACV,KAAK,IAAIC,EAAE,IAAIT,GAAG,EAAC;MACfS,EAAE,CAACD,GAAG,CAAC;IACX;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAASE,cAAcA,CAACjF,cAAc,EAAEF,OAAO,EAAE;EAAEoF,WAAW;EAAGC,UAAU;EAAGC,OAAO;EAAGC;AAAW,CAAC,EAAE;EACtG,SAASC,cAAcA,CAACC,IAAI,EAAEC,YAAY,EAAE;IACxC,OAAOD,IAAI,GAAG,CAAC,CAAC,EAAE1I,IAAI,CAACuB,OAAO,EAAE4B,cAAc,EAAEuF,IAAI,EAAEC,YAAY,CAAC,GAAGxF,cAAc;EACxF;EACA,SAASyF,qBAAqBA,CAAC1F,QAAQ,EAAE;IACrC,OAAO,CAAC,CAAC,EAAE9C,eAAe,CAACmB,OAAO,EAAE4B,cAAc,CAACH,MAAM,EAAEE,QAAQ,CAAC;EACxE;EACA,SAAS2F,gBAAgBA,CAACC,UAAU,EAAExF,OAAO,EAAE;IAC3C,IAAIwF,UAAU,KAAKnI,YAAY,CAACwG,aAAa,EAAE;MAC3C,OAAOxG,YAAY,CAACwG,aAAa;IACrC;IACA,IAAI,CAAC7D,OAAO,CAACyF,aAAa,EAAE;MACxB,OAAOD,UAAU;IACrB;IACA,OAAO7F,OAAO,CAACE,cAAc,CAACH,MAAM,GAAG8F,UAAU;EACrD;EACA,SAASE,iBAAiBA,CAACN,IAAI,EAAEC,YAAY,EAAEM,IAAI,GAAG,CAAC,CAAC,EAAE;IACtD,IAAIlF,KAAK,GAAG,CAAC,CAAC,EAAEnD,OAAO,CAACsI,MAAM,EAAER,IAAI,CAAC;IACrC,IAAI5J,KAAK,GAAG2J,cAAc,CAAC,CACvB,OAAO,EACP,GAAG1E,KAAK,CACX,EAAE4E,YAAY,CAAC;IAChB,OAAO,CAAC,CAAC,EAAEzI,oBAAoB,CAACqB,OAAO,EAAEwC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACjF,KAAK,EAAEmK,IAAI,CAAC;EACnE;EACA,IAAIE,iBAAiB,GAAG,CAAC;EACzB,IAAIjB,GAAG,GAAG;IACNkB,OAAO,EAAErJ,QAAQ,CAACwB,OAAO;IACzByB,MAAM,EAAE4F,qBAAqB;IAC7BS,CAAC,EAAE/I,gBAAgB,CAACiB,OAAO;IAC3B+H,MAAM,EAAEb,cAAc;IACtBc,KAAK,EAAEP,iBAAiB;IACxBQ,WAAW,EAAGd,IAAI,IAAG;MACjB,IAAIhF,KAAK,CAACC,OAAO,CAACR,cAAc,CAACqG,WAAW,CAAC,EAAE;QAC3C,OAAOrG,cAAc,CAACqG,WAAW,CAACjC,QAAQ,CAACmB,IAAI,CAAC;MACpD;MACA,OAAOD,cAAc,CAAC,CAClB,aAAa,EACbC,IAAI,CACP,EAAE,IAAI,CAAC;IACZ,CAAC;IACDe,QAAQ,EAAEA,CAAA,KAAI;MACV;MACA,OAAO,EAAE;IACb,CAAC;IACDC,OAAOA,CAAEC,IAAI,EAAE;MACX,KAAK,IAAI,CAACb,UAAU,EAAElC,IAAI,CAAC,IAAIC,eAAe,CAAC8C,IAAI,CAAC,EAAC;QACjD,IAAIC,kBAAkB,GAAGf,gBAAgB,CAACC,UAAU,EAAE,CAAC,CAAC,CAAC;QACzD,IAAIe,MAAM,GAAGtB,OAAO,CAACuB,MAAM,CAAC,MAAM,CAAC;QACnC,IAAI,CAAC7G,OAAO,CAAC8G,gBAAgB,CAACjI,GAAG,CAAC8H,kBAAkB,CAAC,EAAE;UACnD3G,OAAO,CAAC8G,gBAAgB,CAACxH,GAAG,CAACqH,kBAAkB,EAAE,EAAE,CAAC;QACxD;QACA3G,OAAO,CAAC8G,gBAAgB,CAAC3K,GAAG,CAACwK,kBAAkB,CAAC,CAACvF,IAAI,CAAC,CAClD;UACI2F,IAAI,EAAEH,MAAM;UACZI,KAAK,EAAE;QACX,CAAC,EACDrD,IAAI,CACP,CAAC;MACN;IACJ,CAAC;IACD;AACR;AACA;AACA;IAAQsD,WAAWA,CAAEC,KAAK,EAAEC,YAAY,EAAE;MAC9B,MAAMC,MAAM,GAAG;QACX,CAAE,aAAYF,KAAM,EAAC,GAAGC;MAC5B,CAAC;MACD,KAAK,IAAI,CAACtB,UAAU,EAAElC,IAAI,CAAC,IAAIC,eAAe,CAACwD,MAAM,CAAC,EAAC;QACnD,IAAIT,kBAAkB,GAAGf,gBAAgB,CAACC,UAAU,EAAE,CAAC,CAAC,CAAC;QACzD,IAAI,CAAC7F,OAAO,CAAC8G,gBAAgB,CAACjI,GAAG,CAAC8H,kBAAkB,CAAC,EAAE;UACnD3G,OAAO,CAAC8G,gBAAgB,CAACxH,GAAG,CAACqH,kBAAkB,EAAE,EAAE,CAAC;QACxD;QACA3G,OAAO,CAAC8G,gBAAgB,CAAC3K,GAAG,CAACwK,kBAAkB,CAAC,CAACvF,IAAI,CAAC,CAClD;UACI2F,IAAI,EAAEzB,OAAO,CAACuB,MAAM,CAAC,UAAU,CAAC;UAChCG,KAAK,EAAE;QACX,CAAC,EACDrD,IAAI,CACP,CAAC;MACN;IACJ,CAAC;IACD0D,aAAaA,CAAEC,UAAU,EAAEjH,OAAO,EAAE;MAChC,IAAIkH,cAAc,GAAG;QACjBC,cAAc,EAAE,KAAK;QACrB1B,aAAa,EAAE,IAAI;QACnB2B,gBAAgB,EAAE;MACtB,CAAC;MACDpH,OAAO,GAAG3E,MAAM,CAACgM,MAAM,CAAC,CAAC,CAAC,EAAEH,cAAc,EAAE9G,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,GAAG,CAAC,CAAC,GAAGA,OAAO,CAAC;MAClF,KAAK,IAAI,CAACwF,UAAU,EAAElC,IAAI,CAAC,IAAIC,eAAe,CAAC0D,UAAU,CAAC,EAAC;QACvD,IAAIX,kBAAkB,GAAGf,gBAAgB,CAACC,UAAU,EAAExF,OAAO,CAAC;QAC9DkF,SAAS,CAACoC,GAAG,CAAChB,kBAAkB,CAAC;QACjC,IAAI,CAAC3G,OAAO,CAAC8G,gBAAgB,CAACjI,GAAG,CAAC8H,kBAAkB,CAAC,EAAE;UACnD3G,OAAO,CAAC8G,gBAAgB,CAACxH,GAAG,CAACqH,kBAAkB,EAAE,EAAE,CAAC;QACxD;QACA3G,OAAO,CAAC8G,gBAAgB,CAAC3K,GAAG,CAACwK,kBAAkB,CAAC,CAACvF,IAAI,CAAC,CAClD;UACI2F,IAAI,EAAEzB,OAAO,CAACuB,MAAM,CAAC,YAAY,CAAC;UAClCG,KAAK,EAAE,YAAY;UACnB3G;QACJ,CAAC,EACDsD,IAAI,CACP,CAAC;MACN;IACJ,CAAC;IACDiE,YAAYA,CAAEC,SAAS,EAAExH,OAAO,EAAE;MAC9B,IAAIkH,cAAc,GAAG;QACjBC,cAAc,EAAE,KAAK;QACrB1B,aAAa,EAAE,IAAI;QACnB2B,gBAAgB,EAAE;MACtB,CAAC;MACDpH,OAAO,GAAG3E,MAAM,CAACgM,MAAM,CAAC,CAAC,CAAC,EAAEH,cAAc,EAAE9G,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,GAAG,CAAC,CAAC,GAAGA,OAAO,CAAC;MAClF,KAAK,IAAI,CAACwF,UAAU,EAAElC,IAAI,CAAC,IAAIC,eAAe,CAACiE,SAAS,CAAC,EAAC;QACtD,IAAIlB,kBAAkB,GAAGf,gBAAgB,CAACC,UAAU,EAAExF,OAAO,CAAC;QAC9DkF,SAAS,CAACoC,GAAG,CAAChB,kBAAkB,CAAC;QACjC,IAAI,CAAC3G,OAAO,CAAC8G,gBAAgB,CAACjI,GAAG,CAAC8H,kBAAkB,CAAC,EAAE;UACnD3G,OAAO,CAAC8G,gBAAgB,CAACxH,GAAG,CAACqH,kBAAkB,EAAE,EAAE,CAAC;QACxD;QACA3G,OAAO,CAAC8G,gBAAgB,CAAC3K,GAAG,CAACwK,kBAAkB,CAAC,CAACvF,IAAI,CAAC,CAClD;UACI2F,IAAI,EAAEzB,OAAO,CAACuB,MAAM,CAAC,WAAW,CAAC;UACjCG,KAAK,EAAE,WAAW;UAClB3G;QACJ,CAAC,EACDsD,IAAI,CACP,CAAC;MACN;IACJ,CAAC;IACDmE,cAAc,EAAE,SAAAA,CAASD,SAAS,EAAExH,OAAO,EAAE;MACzC,IAAIkH,cAAc,GAAG;QACjBzB,aAAa,EAAE,IAAI;QACnB2B,gBAAgB,EAAE,IAAI;QACtBM,SAAS,EAAE;MACf,CAAC;MACD1H,OAAO,GAAGF,oBAAoB,CAAC;QAC3B,GAAGoH,cAAc;QACjB,GAAGlH;MACP,CAAC,CAAC;MACF,IAAIuG,MAAM,GAAGtB,OAAO,CAACuB,MAAM,CAAC,WAAW,CAAC;MACxC,KAAI,IAAIhB,UAAU,IAAIgC,SAAS,EAAC;QAC5B,IAAIlB,kBAAkB,GAAGf,gBAAgB,CAACC,UAAU,EAAExF,OAAO,CAAC;QAC9D,IAAIsD,IAAI,GAAGkE,SAAS,CAAChC,UAAU,CAAC;QAChCN,SAAS,CAACoC,GAAG,CAAC,CACVhB,kBAAkB,EAClBtG,OAAO,CACV,CAAC;QACF,SAAS2H,OAAOA,CAACC,QAAQ,EAAE;UAAEC;QAAc,CAAC,EAAE;UAC1C,IAAI,CAACrM,KAAK,EAAEsM,WAAW,EAAEC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE5K,YAAY,CAAC6K,WAAW,EAAEhI,OAAO,CAACC,KAAK,EAAE2H,QAAQ,EAAE5H,OAAO,EAAEH,cAAc,CAAC;UAC3H,IAAIrE,KAAK,KAAKyM,SAAS,EAAE;YACrB,OAAO,EAAE;UACb;UACA,IAAI,CAACjI,OAAO,CAACC,KAAK,CAACiI,IAAI,CAAC,CAAC;YAAEnI;UAAM,CAAC,KAAGA,IAAI,KAAK+H,WAAW,CAAC,EAAE;YACxD,IAAID,YAAY,EAAE;cACdtK,IAAI,CAACU,OAAO,CAACkK,IAAI,CAAC,CACb,0BAAyBL,WAAY,WAAUtC,UAAW,IAAGoC,QAAS,KAAI,EAC1E,iCAAgCpC,UAAW,IAAGoC,QAAQ,CAACzD,OAAO,CAAC2D,WAAW,GAAG,GAAG,EAAE,EAAE,CAAE,KAAI,CAC9F,CAAC;YACN,CAAC,MAAM;cACH,OAAO,EAAE;YACb;UACJ;UACA,IAAI,CAAC,CAAC,CAAC,EAAErK,kCAAkC,CAACQ,OAAO,EAAEzC,KAAK,CAAC,EAAE;YACzD,OAAO,EAAE;UACb;UACA,IAAI4M,MAAM,GAAG;YACT,IAAIR,QAAQA,CAAA,EAAI;cACZ,IAAI,CAAC5H,OAAO,CAAC0H,SAAS,EAAE;gBACpBnK,IAAI,CAACU,OAAO,CAACkK,IAAI,CAAE,qCAAoC3C,UAAW,EAAC,EAAE,CACjE,6EAA6E,CAChF,CAAC;cACN;cACA,OAAOuC,eAAe;YAC1B;UACJ,CAAC;UACD,IAAIM,gBAAgB,GAAG,CAAC,CAAC,EAAExK,aAAa,CAACyK,WAAW,EAAEzI,cAAc,EAAE,sBAAsB,CAAC;UAC7F,IAAI0I,QAAQ,GAAG,EAAE,CAACrI,MAAM,CAACmI,gBAAgB,GAAG/E,IAAI,CAAC9H,KAAK,EAAE4M,MAAM,CAAC,GAAG9E,IAAI,CAAC9H,KAAK,CAAC,CAAC,CAAC0F,MAAM,CAACsH,OAAO,CAAC,CAACrI,GAAG,CAAEsI,WAAW,KAAI;YAC3G,CAAC,CAAC,CAAC,EAAExL,UAAU,CAACgB,OAAO,EAAEuH,UAAU,EAAEoC,QAAQ,CAAC,GAAGa;UACrD,CAAC,CAAC,CAAC;UACP,OAAOF,QAAQ;QACnB;QACA,IAAIG,WAAW,GAAG,CACd;UACIhC,IAAI,EAAEH,MAAM;UACZI,KAAK,EAAE,WAAW;UAClB3G;QACJ,CAAC,EACD2H,OAAO,CACV;QACD,IAAI,CAAChI,OAAO,CAAC8G,gBAAgB,CAACjI,GAAG,CAAC8H,kBAAkB,CAAC,EAAE;UACnD3G,OAAO,CAAC8G,gBAAgB,CAACxH,GAAG,CAACqH,kBAAkB,EAAE,EAAE,CAAC;QACxD;QACA3G,OAAO,CAAC8G,gBAAgB,CAAC3K,GAAG,CAACwK,kBAAkB,CAAC,CAACvF,IAAI,CAAC2H,WAAW,CAAC;MACtE;IACJ,CAAC;IACDC,eAAe,EAAE,SAAAA,CAAS1B,UAAU,EAAEjH,OAAO,EAAE;MAC3C,IAAIkH,cAAc,GAAG;QACjBzB,aAAa,EAAE,IAAI;QACnB2B,gBAAgB,EAAE,KAAK;QACvBM,SAAS,EAAE;MACf,CAAC;MACD1H,OAAO,GAAGF,oBAAoB,CAAC;QAC3B,GAAGoH,cAAc;QACjB,GAAGlH;MACP,CAAC,CAAC;MACF,IAAIuG,MAAM,GAAGtB,OAAO,CAACuB,MAAM,CAAC,YAAY,CAAC;MACzC,KAAI,IAAIhB,UAAU,IAAIyB,UAAU,EAAC;QAC7B,IAAIX,kBAAkB,GAAGf,gBAAgB,CAACC,UAAU,EAAExF,OAAO,CAAC;QAC9D,IAAIsD,IAAI,GAAG2D,UAAU,CAACzB,UAAU,CAAC;QACjCN,SAAS,CAACoC,GAAG,CAAC,CACVhB,kBAAkB,EAClBtG,OAAO,CACV,CAAC;QACF,SAAS2H,OAAOA,CAACC,QAAQ,EAAE;UAAEC;QAAc,CAAC,EAAE;UAC1C,IAAI,CAACrM,KAAK,EAAEsM,WAAW,EAAEC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE5K,YAAY,CAAC6K,WAAW,EAAEhI,OAAO,CAACC,KAAK,EAAE2H,QAAQ,EAAE5H,OAAO,EAAEH,cAAc,CAAC;UAC3H,IAAIrE,KAAK,KAAKyM,SAAS,EAAE;YACrB,OAAO,EAAE;UACb;UACA,IAAI,CAACjI,OAAO,CAACC,KAAK,CAACiI,IAAI,CAAC,CAAC;YAAEnI;UAAM,CAAC,KAAGA,IAAI,KAAK+H,WAAW,CAAC,EAAE;YACxD,IAAID,YAAY,EAAE;cACdtK,IAAI,CAACU,OAAO,CAACkK,IAAI,CAAC,CACb,0BAAyBL,WAAY,WAAUtC,UAAW,IAAGoC,QAAS,KAAI,EAC1E,iCAAgCpC,UAAW,IAAGoC,QAAQ,CAACzD,OAAO,CAAC2D,WAAW,GAAG,GAAG,EAAE,EAAE,CAAE,KAAI,CAC9F,CAAC;YACN,CAAC,MAAM;cACH,OAAO,EAAE;YACb;UACJ;UACA,IAAI,CAAC,CAAC,CAAC,EAAErK,kCAAkC,CAACQ,OAAO,EAAEzC,KAAK,CAAC,EAAE;YACzD,OAAO,EAAE;UACb;UACA,IAAI4M,MAAM,GAAG;YACT,IAAIR,QAAQA,CAAA,EAAI;cACZ,IAAI,CAAC5H,OAAO,CAAC0H,SAAS,EAAE;gBACpBnK,IAAI,CAACU,OAAO,CAACkK,IAAI,CAAE,qCAAoC3C,UAAW,EAAC,EAAE,CACjE,6EAA6E,CAChF,CAAC;cACN;cACA,OAAOuC,eAAe;YAC1B;UACJ,CAAC;UACD,IAAIM,gBAAgB,GAAG,CAAC,CAAC,EAAExK,aAAa,CAACyK,WAAW,EAAEzI,cAAc,EAAE,sBAAsB,CAAC;UAC7F,IAAI0I,QAAQ,GAAG,EAAE,CAACrI,MAAM,CAACmI,gBAAgB,GAAG/E,IAAI,CAAC9H,KAAK,EAAE4M,MAAM,CAAC,GAAG9E,IAAI,CAAC9H,KAAK,CAAC,CAAC,CAAC0F,MAAM,CAACsH,OAAO,CAAC,CAACrI,GAAG,CAAEsI,WAAW,KAAI;YAC3G,CAAC,CAAC,CAAC,EAAExL,UAAU,CAACgB,OAAO,EAAEuH,UAAU,EAAEoC,QAAQ,CAAC,GAAGa;UACrD,CAAC,CAAC,CAAC;UACP,OAAOF,QAAQ;QACnB;QACA,IAAIG,WAAW,GAAG,CACd;UACIhC,IAAI,EAAEH,MAAM;UACZI,KAAK,EAAE,YAAY;UACnB3G;QACJ,CAAC,EACD2H,OAAO,CACV;QACD,IAAI,CAAChI,OAAO,CAAC8G,gBAAgB,CAACjI,GAAG,CAAC8H,kBAAkB,CAAC,EAAE;UACnD3G,OAAO,CAAC8G,gBAAgB,CAACxH,GAAG,CAACqH,kBAAkB,EAAE,EAAE,CAAC;QACxD;QACA3G,OAAO,CAAC8G,gBAAgB,CAAC3K,GAAG,CAACwK,kBAAkB,CAAC,CAACvF,IAAI,CAAC2H,WAAW,CAAC;MACtE;IACJ,CAAC;IACDE,UAAUA,CAAEC,WAAW,EAAEC,gBAAgB,EAAE9I,OAAO,GAAG,CAAC,CAAC,EAAE;MACrD8I,gBAAgB,GAAG,EAAE,CAAC5I,MAAM,CAAC4I,gBAAgB,CAAC,CAAC3I,GAAG,CAAE4I,eAAe,IAAG;QAClE,IAAI,OAAOA,eAAe,KAAK,QAAQ,EAAE;UACrC;UACA,OAAO,CAACnE,GAAG,GAAG,CAAC,CAAC,KAAG;YACf,IAAI;cAAEoE,IAAI;cAAGC,eAAe;cAAGC,SAAS;cAAGC,SAAS;cAAG1E,IAAI;cAAGV;YAAQ,CAAC,GAAGa,GAAG;YAC7E,IAAIwE,MAAM,GAAGL,eAAe,CAAC1N,MAAM,CAACgM,MAAM,CAAC;cACvC4B,eAAe;cACfC,SAAS;cACTC;YACJ,CAAC,EAAEnJ,OAAO,CAACD,IAAI,KAAKZ,aAAa,CAACG,YAAY,IAAI;cAC9C0J,IAAI;cACJvE,IAAI;cACJV;YACJ,CAAC,CAAC,CAAC;YACH,IAAI,OAAOqF,MAAM,KAAK,QAAQ,IAAI,CAACpN,0BAA0B,CAACoN,MAAM,CAAC,EAAE;cACnE,MAAM,IAAInI,KAAK,CAAE,yBAAwB4H,WAAY,6FAA4F,CAAC;YACtJ;YACA,IAAIzI,KAAK,CAACC,OAAO,CAAC+I,MAAM,CAAC,EAAE;cACvB,OAAOA,MAAM,CAAClI,MAAM,CAAEgD,OAAO,IAAG,OAAOA,OAAO,KAAK,QAAQ,CAAC,CAAC/D,GAAG,CAAE+D,OAAO,IAAGjI,YAAY,CAACiI,OAAO,CAAC,CAAC;YACtG;YACA;YACA;YACA,OAAOkF,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAInN,YAAY,CAACmN,MAAM,CAAC,CAACxE,GAAG,CAAC;UAC5E,CAAC;QACL;QACA,IAAI,CAAC5I,0BAA0B,CAAC+M,eAAe,CAAC,EAAE;UAC9C,MAAM,IAAI9H,KAAK,CAAE,yBAAwB4H,WAAY,6FAA4F,CAAC;QACtJ;QACA,OAAO5M,YAAY,CAAC8M,eAAe,CAAC;MACxC,CAAC,CAAC;MACF3H,UAAU,CAAC2D,WAAW,EAAE8D,WAAW,EAAE7I,OAAO,CAAC;MAC7CgF,UAAU,CAAC/F,GAAG,CAAC4J,WAAW,EAAEC,gBAAgB,CAAC;MAC7CnJ,OAAO,CAAC0J,cAAc,CAACpK,GAAG,CAAC4J,WAAW,EAAE7I,OAAO,CAAC;IACpD,CAAC;IACDsJ,YAAYA,CAAEpF,OAAO,EAAEqF,SAAS,EAAEvJ,OAAO,EAAE;MACvC,IAAIwJ,WAAW;MACf;MACA;MACA,IAAIC,EAAE,GAAG,CAACD,WAAW,GAAGxJ,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACyJ,EAAE,MAAM,IAAI,IAAID,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAG,EAAE3D,iBAAiB;MAC5J,IAAI6D,SAAS,GAAGxF,OAAO,KAAK,GAAG;MAC/B,IAAImE,gBAAgB,GAAG,CAAC,CAAC,EAAExK,aAAa,CAACyK,WAAW,EAAEzI,cAAc,EAAE,sBAAsB,CAAC;MAC7F,IAAI8J,eAAe;MACnB,KAAK,IAAI,CAAC/K,GAAG,EAAEpD,KAAK,CAAC,IAAIH,MAAM,CAACuO,OAAO,CAAC,CAACD,eAAe,GAAG3J,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC6J,MAAM,MAAM,IAAI,IAAIF,eAAe,KAAK,KAAK,CAAC,GAAGA,eAAe,GAAG,CAAC,CAAC,CAAC,EAAC;QACxL,IAAI/K,GAAG,KAAK,SAAS,EAAE;QACvBgG,GAAG,CAACgE,UAAU,CAACc,SAAS,GAAI,GAAExF,OAAQ,GAAEtF,GAAI,EAAC,GAAI,GAAEsF,OAAQ,IAAGtF,GAAI,EAAC,EAAE,CAAC;UAAEoK,IAAI;UAAGE;QAAW,CAAC,KAAG;UAC1F,OAAOK,SAAS,CAAC/N,KAAK,EAAE6M,gBAAgB,GAAG;YACvCT,QAAQ,EAAEoB,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACpB,QAAQ;YACnEsB;UACJ,CAAC,GAAG;YACAA;UACJ,CAAC,CAAC;QACN,CAAC,EAAE;UACC,GAAGlJ,OAAO;UACVxE,KAAK;UACLiO,EAAE;UACF1J,IAAI,EAAEZ,aAAa,CAACG,YAAY;UAChCwK,WAAW,EAAEvK,YAAY,CAACC;QAC9B,CAAC,CAAC;MACN;MACA,IAAIuK,gBAAgB;MACpB,IAAIC,UAAU,IAAG,SAAS,KAAK,CAACD,gBAAgB,GAAG/J,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC6J,MAAM,MAAM,IAAI,IAAIE,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC,CAAC,CAAC;MACrLnF,GAAG,CAACgE,UAAU,CAAC1E,OAAO,EAAE,CAAC;QAAE8E,IAAI;QAAGE;MAAW,CAAC,KAAG;QAC7C,IAAI,CAACF,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACxN,KAAK,MAAM6B,YAAY,CAAC4M,IAAI,IAAI,CAACD,UAAU,EAAE;UAC/F,OAAO,IAAI;QACf;QACA;QAAI;QACJE,WAAW;QACX,OAAOX,SAAS,CAAC,CAACP,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACxN,KAAK,MAAM6B,YAAY,CAAC4M,IAAI,GAAGjK,OAAO,CAAC6J,MAAM,CAACM,OAAO,GAAG,CAACD,WAAW,GAAGlB,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACxN,KAAK,MAAM,IAAI,IAAI0O,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAG,OAAOlB,IAAI,KAAK,QAAQ,GAAGA,IAAI,GAAG,EAAE,EAAEX,gBAAgB,GAAG;UAC1ST,QAAQ,EAAEoB,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACpB,QAAQ;UACnEsB;QACJ,CAAC,GAAG;UACAA;QACJ,CAAC,CAAC;MACN,CAAC,EAAE;QACC,GAAGlJ,OAAO;QACVyJ,EAAE;QACF1J,IAAI,EAAEZ,aAAa,CAACG,YAAY;QAChCwK,WAAW,EAAEvK,YAAY,CAACE;MAC9B,CAAC,CAAC;IACN;EACJ,CAAC;EACD,OAAOmF,GAAG;AACd;AACA,IAAIwF,oBAAoB,GAAG,IAAIhM,OAAO,CAAC,CAAC;AACxC,SAASlC,kBAAkBA,CAACyD,OAAO,EAAE;EACjC,IAAI,CAACyK,oBAAoB,CAAC5L,GAAG,CAACmB,OAAO,CAAC,EAAE;IACpCyK,oBAAoB,CAACnL,GAAG,CAACU,OAAO,EAAE,IAAI8D,GAAG,CAAC,CAAC,CAAC;EAChD;EACA,OAAO2G,oBAAoB,CAACtO,GAAG,CAAC6D,OAAO,CAAC;AAC5C;AACA,SAAS0K,aAAaA,CAACC,KAAK,EAAEC,eAAe,EAAE;EAC3C,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIC,cAAc,GAAG,IAAIhH,GAAG,CAAC,CAAC;EAC9B,KAAK,IAAIiH,IAAI,IAAIJ,KAAK,EAAC;IACnB,IAAIK,YAAY;IAChB,IAAI,CAACD,IAAI,EAAE;IACX,IAAIE,MAAM,GAAGpO,IAAI,CAACyB,OAAO,CAAC4M,KAAK,CAACH,IAAI,CAAC;IACrC,IAAII,QAAQ,GAAGF,MAAM,CAACG,IAAI,GAAGH,MAAM,CAACI,IAAI,CAAC7G,OAAO,CAACyG,MAAM,CAACG,IAAI,EAAE,EAAE,CAAC,GAAGH,MAAM,CAACI,IAAI;IAC/EF,QAAQ,GAAGF,MAAM,CAACK,MAAM,GAAGH,QAAQ,CAAC3G,OAAO,CAACyG,MAAM,CAACK,MAAM,EAAE,EAAE,CAAC,GAAGH,QAAQ;IACzE,IAAII,WAAW,GAAG,CAACP,YAAY,GAAGtO,GAAG,CAAC4B,OAAO,CAACkN,QAAQ,CAACC,kBAAkB,CAACN,QAAQ,CAAC,EAAE;MACjFO,cAAc,EAAE;IACpB,CAAC,CAAC,MAAM,IAAI,IAAIV,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACW,OAAO;IACvE,IAAI,CAACJ,WAAW,EAAE;MACd;IACJ;IACA,IAAI,CAACX,eAAe,CAAC/L,GAAG,CAACkM,IAAI,CAAC,IAAIQ,WAAW,GAAGX,eAAe,CAACzO,GAAG,CAAC4O,IAAI,CAAC,EAAE;MACvEF,OAAO,GAAG,IAAI;IAClB;IACAC,cAAc,CAACxL,GAAG,CAACyL,IAAI,EAAEQ,WAAW,CAAC;EACzC;EACA,OAAO,CACHV,OAAO,EACPC,cAAc,CACjB;AACL;AACA,SAASc,qBAAqBA,CAAC5I,IAAI,EAAE;EACjCA,IAAI,CAAC6I,WAAW,CAAE9G,MAAM,IAAG;IACvB,IAAI,CACA,YAAY,EACZ,UAAU,CACb,CAACT,QAAQ,CAACS,MAAM,CAAC9I,IAAI,CAAC,EAAE;MACrB2P,qBAAqB,CAAC7G,MAAM,CAAC;MAC7BA,MAAM,CAACpD,MAAM,CAACoD,MAAM,CAAC+G,KAAK,CAAC;MAC3B/G,MAAM,CAACxB,MAAM,CAAC,CAAC;IACnB;EACJ,CAAC,CAAC;AACN;AACA,SAASwI,mBAAmBA,CAACC,IAAI,EAAE;EAC/B,IAAIC,YAAY,GAAG,EAAE;EACrBD,IAAI,CAACE,IAAI,CAAElJ,IAAI,IAAG;IACd,IAAIA,IAAI,CAAC5C,IAAI,KAAK,QAAQ,IAAI,CAC1B,YAAY,EACZ,UAAU,CACb,CAACkE,QAAQ,CAACtB,IAAI,CAAC/G,IAAI,CAAC,EAAE;MACnB+G,IAAI,CAAC/G,IAAI,GAAG,OAAO;MACnB+G,IAAI,CAAC2B,MAAM,GAAG,WAAW;IAC7B;EACJ,CAAC,CAAC;EACF;EACAqH,IAAI,CAACH,WAAW,CAAC,OAAO,EAAGM,SAAS,IAAG;IACnCP,qBAAqB,CAACO,SAAS,CAAC;IAChC,IAAIA,SAAS,CAACxH,MAAM,KAAK,MAAM,EAAE;MAC7B,KAAK,IAAI3B,IAAI,IAAImJ,SAAS,CAACL,KAAK,EAAC;QAC7BG,YAAY,CAAC7K,IAAI,CAAC,UAAS;UAAEqF;QAAS,CAAC,EAAE;UACrCA,OAAO,CAACzD,IAAI,EAAE;YACV8C,aAAa,EAAE;UACnB,CAAC,CAAC;QACN,CAAC,CAAC;MACN;MACAqG,SAAS,CAAC5I,MAAM,CAAC,CAAC;IACtB,CAAC,MAAM,IAAI4I,SAAS,CAACxH,MAAM,KAAK,YAAY,EAAE;MAC1C,KAAK,IAAI3B,IAAI,IAAImJ,SAAS,CAACL,KAAK,EAAC;QAC7BG,YAAY,CAAC7K,IAAI,CAAC,UAAS;UAAEiG;QAAe,CAAC,EAAE;UAC3CA,aAAa,CAACrE,IAAI,EAAE;YAChB8C,aAAa,EAAE,KAAK;YACpB0B,cAAc,EAAE;UACpB,CAAC,CAAC;QACN,CAAC,CAAC;MACN;MACA2E,SAAS,CAAC5I,MAAM,CAAC,CAAC;IACtB,CAAC,MAAM,IAAI4I,SAAS,CAACxH,MAAM,KAAK,WAAW,EAAE;MACzC,KAAK,IAAI3B,IAAI,IAAImJ,SAAS,CAACL,KAAK,EAAC;QAC7BG,YAAY,CAAC7K,IAAI,CAAC,UAAS;UAAEwG;QAAc,CAAC,EAAE;UAC1CA,YAAY,CAAC5E,IAAI,EAAE;YACf8C,aAAa,EAAE,KAAK;YACpB0B,cAAc,EAAE;UACpB,CAAC,CAAC;QACN,CAAC,CAAC;MACN;MACA2E,SAAS,CAAC5I,MAAM,CAAC,CAAC;IACtB;EACJ,CAAC,CAAC;EACF,OAAO0I,YAAY;AACvB;AACA,SAASG,cAAcA,CAACpM,OAAO,EAAEgM,IAAI,EAAE;EACnC,IAAIK,cAAc,GAAG3Q,MAAM,CAACuO,OAAO,CAAC;IAChC,GAAGxM,YAAY,CAAC6O,cAAc;IAC9B,GAAG7O,YAAY,CAAC8I;EACpB,CAAC,CAAC,CAAC/F,GAAG,CAAC,CAAC,CAACvE,IAAI,EAAEsQ,MAAM,CAAC,KAAG;IACrB,IAAI,CAACvM,OAAO,CAACE,cAAc,CAACqG,WAAW,CAACjC,QAAQ,CAACrI,IAAI,CAAC,EAAE;MACpD,OAAO,IAAI;IACf;IACA,OAAOsQ,MAAM;EACjB,CAAC,CAAC,CAAChL,MAAM,CAACsH,OAAO,CAAC;EAClB,IAAI2D,WAAW,GAAGxM,OAAO,CAACE,cAAc,CAACuM,OAAO,CAACjM,GAAG,CAAE+L,MAAM,IAAG;IAC3D,IAAIA,MAAM,CAACG,mBAAmB,EAAE;MAC5BH,MAAM,GAAGA,MAAM,CAAC,CAAC;IACrB;IACA,OAAO,OAAOA,MAAM,KAAK,UAAU,GAAGA,MAAM,GAAGA,MAAM,CAACI,OAAO;EACjE,CAAC,CAAC;EACF,IAAIV,YAAY,GAAGF,mBAAmB,CAACC,IAAI,CAAC;EAC5C;EACA;EACA,IAAIY,cAAc,GAAG,CACjBnP,YAAY,CAAC6O,cAAc,CAAC,uBAAuB,CAAC,EACpD7O,YAAY,CAAC6O,cAAc,CAAC,qBAAqB,CAAC,EAClD7O,YAAY,CAAC6O,cAAc,CAAC,cAAc,CAAC,EAC3C7O,YAAY,CAAC6O,cAAc,CAAC,cAAc,CAAC,CAC9C;EACD,IAAIO,aAAa,GAAG,CAChBpP,YAAY,CAAC6O,cAAc,CAAC,kBAAkB,CAAC,EAC/C7O,YAAY,CAAC6O,cAAc,CAAC,mBAAmB,CAAC,EAChD7O,YAAY,CAAC6O,cAAc,CAAC,uBAAuB,CAAC,EACpD7O,YAAY,CAAC6O,cAAc,CAAC,yBAAyB,CAAC,EACtD7O,YAAY,CAAC6O,cAAc,CAAC,cAAc,CAAC,EAC3C7O,YAAY,CAAC6O,cAAc,CAAC,cAAc,CAAC,EAC3C7O,YAAY,CAAC6O,cAAc,CAAC,gBAAgB,CAAC,EAC7C7O,YAAY,CAAC6O,cAAc,CAAC,qBAAqB,CAAC,CACrD;EACD,OAAO,CACH,GAAGD,cAAc,EACjB,GAAGO,cAAc,EACjB,GAAGJ,WAAW,EACd,GAAGK,aAAa,EAChB,GAAGZ,YAAY,CAClB;AACL;AACA,SAASa,eAAeA,CAACL,OAAO,EAAEzM,OAAO,EAAE;EACvC,IAAIoF,WAAW,GAAG,EAAE;EACpB,IAAIC,UAAU,GAAG,IAAIvB,GAAG,CAAC,CAAC;EAC1B9D,OAAO,CAACqF,UAAU,GAAGA,UAAU;EAC/B,IAAIC,OAAO,GAAG,IAAIrH,QAAQ,CAAC8O,OAAO,CAAC,CAAC;EACpC/M,OAAO,CAACsF,OAAO,GAAGA,OAAO;EACzB,IAAIC,SAAS,GAAG,IAAIyH,GAAG,CAAC,CAAC;EACzB,IAAIC,SAAS,GAAG9H,cAAc,CAACnF,OAAO,CAACE,cAAc,EAAEF,OAAO,EAAE;IAC5DoF,WAAW;IACXC,UAAU;IACVC,OAAO;IACPC;EACJ,CAAC,CAAC;EACF,KAAK,IAAIgH,MAAM,IAAIE,OAAO,EAAC;IACvB,IAAIhM,KAAK,CAACC,OAAO,CAAC6L,MAAM,CAAC,EAAE;MACvB,KAAK,IAAIW,UAAU,IAAIX,MAAM,EAAC;QAC1BW,UAAU,CAACD,SAAS,CAAC;MACzB;IACJ,CAAC,MAAM;MACHV,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACU,SAAS,CAAC;IACrE;EACJ;EACA;EACA3H,OAAO,CAAC6H,cAAc,CAAC/H,WAAW,EAAGb,OAAO,IAAGc,UAAU,CAAClJ,GAAG,CAACoI,OAAO,CAAC,CAACrD,MAAM,CAAC;EAC9E;EACA,KAAK,IAAI,CAACgI,WAAW,EAAEC,gBAAgB,CAAC,IAAI9D,UAAU,CAAC4E,OAAO,CAAC,CAAC,EAAC;IAC7DjK,OAAO,CAACqF,UAAU,CAAC/F,GAAG,CAAC4J,WAAW,EAAEC,gBAAgB,CAAC3I,GAAG,CAAC,CAAC4I,eAAe,EAAEnI,GAAG,KAAG,CACzEqE,OAAO,CAAC8H,UAAU,CAAClE,WAAW,EAAEjI,GAAG,CAAC,EACpCmI,eAAe,CAClB,CAAC,CAAC;EACX;EACA,IAAIiE,gCAAgC;EACpC,IAAIC,QAAQ,GAAG,CAAC,CAACD,gCAAgC,GAAGrN,OAAO,CAACE,cAAc,CAACoN,QAAQ,MAAM,IAAI,IAAID,gCAAgC,KAAK,KAAK,CAAC,GAAGA,gCAAgC,GAAG,EAAE,EAAE9L,MAAM,CAACsH,OAAO,CAAC;EACrM,IAAIyE,QAAQ,CAACpM,MAAM,GAAG,CAAC,EAAE;IACrB,IAAIqM,MAAM,GAAG,EAAE;IACf,KAAK,IAAI1R,KAAK,IAAIyR,QAAQ,EAAC;MACvB,IAAI,OAAOzR,KAAK,KAAK,QAAQ,EAAE;QAC3BmE,OAAO,CAACwN,cAAc,CAACpM,IAAI,CAAC;UACxBqM,OAAO,EAAE5R,KAAK;UACd6R,SAAS,EAAE;QACf,CAAC,CAAC;QACF;MACJ;MACA,IAAI7R,KAAK,YAAY8R,MAAM,EAAE;QACzB/P,IAAI,CAACU,OAAO,CAACkK,IAAI,CAAC,YAAY,EAAE,CAC5B,0EAA0E,EAC1E,iEAAiE,EACjE,wEAAwE,CAC3E,CAAC;QACF;MACJ;MACA+E,MAAM,CAACnM,IAAI,CAACvF,KAAK,CAAC;IACtB;IACA,IAAI0R,MAAM,CAACrM,MAAM,GAAG,CAAC,EAAE;MACnB,IAAI0M,oBAAoB,GAAG,IAAI9J,GAAG,CAAC,CAAC;MACpC,IAAI+J,YAAY,GAAG7N,OAAO,CAACE,cAAc,CAACH,MAAM,CAACmB,MAAM;MACvD,IAAI4M,mBAAmB,GAAGP,MAAM,CAAChF,IAAI,CAAEwF,KAAK,IAAGA,KAAK,CAACC,OAAO,CAACC,MAAM,CAAC3J,QAAQ,CAAC,GAAG,CAAC,CAAC;MAClF,KAAK,IAAI4J,IAAI,IAAI3I,SAAS,EAAC;QACvB,IAAI4I,KAAK,GAAG1N,KAAK,CAACC,OAAO,CAACwN,IAAI,CAAC,GAAG,CAAC,MAAI;UACnC,IAAI,CAACE,QAAQ,EAAE/N,OAAO,CAAC,GAAG6N,IAAI;UAC9B,IAAIlE,eAAe;UACnB,IAAIE,MAAM,GAAGxO,MAAM,CAAC2S,IAAI,CAAC,CAACrE,eAAe,GAAG3J,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC6J,MAAM,MAAM,IAAI,IAAIF,eAAe,KAAK,KAAK,CAAC,GAAGA,eAAe,GAAG,CAAC,CAAC,CAAC;UAC5K,IAAI7G,OAAO,GAAG+G,MAAM,CAAC1J,GAAG,CAAE3E,KAAK,IAAG,CAAC,CAAC,EAAEyB,UAAU,CAACgR,WAAW,EAAEF,QAAQ,EAAEvS,KAAK,CAAC,CAAC;UAC/E,IAAIwE,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACkO,sBAAsB,EAAE;YAClF;YACA;YACApL,OAAO,GAAG,CACN,GAAGA,OAAO,EACV,GAAGA,OAAO,CAAC3C,GAAG,CAAEgO,GAAG,IAAG,GAAG,GAAGA,GAAG,CAAC,CACnC;YACD;YACA;YACA;YACA;YACArL,OAAO,GAAG,CACN,GAAGA,OAAO,EACV,GAAGA,OAAO,CAAC3C,GAAG,CAAEgO,GAAG,IAAGA,GAAG,CAACC,KAAK,CAAC,CAAC,EAAEZ,YAAY,CAAC,GAAG,GAAG,GAAGW,GAAG,CAACC,KAAK,CAACZ,YAAY,CAAC,CAAC,CACpF;UACL;UACA,IAAIxN,OAAO,CAACC,KAAK,CAACiI,IAAI,CAAC,CAAC;YAAEnI;UAAM,CAAC,KAAGA,IAAI,KAAK,OAAO,CAAC,EAAE;YACnD+C,OAAO,GAAG,CACN,GAAGA,OAAO,EACV,GAAGA,OAAO,CAACf,OAAO,CAAEoM,GAAG,IAAG9S,MAAM,CAAC2S,IAAI,CAACrO,OAAO,CAACE,cAAc,CAACoG,KAAK,CAACoI,OAAO,CAAC,CAAClO,GAAG,CAAEkO,OAAO,IAAI,GAAEF,GAAI,IAAGE,OAAQ,EAAC,CAAC,CAAC,CACnH;UACL;UACA,IAAIZ,mBAAmB,KAAKzN,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACoH,gBAAgB,CAAC,EAAE;YACrGtE,OAAO,GAAG,CACN,GAAGA,OAAO,EACV,GAAGA,OAAO,CAAC3C,GAAG,CAAEgO,GAAG,IAAG,GAAG,GAAGA,GAAG,CAAC,CACnC;UACL;UACA,OAAOrL,OAAO;QAClB,CAAC,EAAE,CAAC,GAAG,CACH+K,IAAI,CACP;QACD,KAAK,IAAIA,IAAI,IAAIC,KAAK,EAAC;UACnB,KAAK,IAAI;YAAEH,OAAO;YAAGxH,QAAQ,GAAE;UAAI,CAAC,IAAI+G,MAAM,EAAC;YAC3C;YACA;YACAS,OAAO,CAACW,SAAS,GAAG,CAAC;YACrB,IAAI,CAACf,oBAAoB,CAAC/O,GAAG,CAACmP,OAAO,CAAC,EAAE;cACpCJ,oBAAoB,CAACtO,GAAG,CAAC0O,OAAO,EAAE,CAAC,CAAC;YACxC;YACA,IAAI,CAACA,OAAO,CAACY,IAAI,CAACV,IAAI,CAAC,EAAE;YACzBN,oBAAoB,CAACtO,GAAG,CAAC0O,OAAO,EAAEJ,oBAAoB,CAACzR,GAAG,CAAC6R,OAAO,CAAC,GAAG,CAAC,CAAC;YACxEhO,OAAO,CAACwN,cAAc,CAACpM,IAAI,CAAC;cACxBqM,OAAO,EAAES,IAAI;cACbR,SAAS,EAAE;YACf,CAAC,CAAC;YACF,KAAK,IAAInJ,OAAO,IAAIiC,QAAQ,EAAC;cACzBxG,OAAO,CAACwN,cAAc,CAACpM,IAAI,CAAC;gBACxBqM,OAAO,EAAElJ,OAAO,GAAGvE,OAAO,CAACE,cAAc,CAACsJ,SAAS,GAAG0E,IAAI;gBAC1DR,SAAS,EAAE;cACf,CAAC,CAAC;YACN;UACJ;QACJ;MACJ;MACA,KAAK,IAAI,CAACmB,KAAK,EAAEC,KAAK,CAAC,IAAIlB,oBAAoB,CAAC3D,OAAO,CAAC,CAAC,EAAC;QACtD,IAAI6E,KAAK,KAAK,CAAC,EAAE;QACjBlR,IAAI,CAACU,OAAO,CAACkK,IAAI,CAAC,CACb,0BAAyBqG,KAAM,4CAA2C,EAC3E,mEAAmE,EACnE,wEAAwE,CAC3E,CAAC;MACN;IACJ;EACJ;EACA,IAAIE,gCAAgC,EAAEC,QAAQ;EAC9C,IAAIC,aAAa,GAAG,CAACD,QAAQ,GAAG,EAAE,CAACzO,MAAM,CAAC,CAACwO,gCAAgC,GAAG/O,OAAO,CAACE,cAAc,CAACgP,QAAQ,MAAM,IAAI,IAAIH,gCAAgC,KAAK,KAAK,CAAC,GAAGA,gCAAgC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIC,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG,MAAM;EAC5Q;EACA;EACA;EACA;EACA,IAAIG,iBAAiB,GAAG,CACpBpP,MAAM,CAACC,OAAO,EAAEiP,aAAa,CAAC,EAC9BlP,MAAM,CAACC,OAAO,EAAE,OAAO,CAAC,EACxBD,MAAM,CAACC,OAAO,EAAE,MAAM,CAAC,CAC1B;EACDA,OAAO,CAACoP,aAAa,GAAG,SAASA,aAAaA,CAACjM,OAAO,EAAE;IACpD;IACA,IAAIkM,MAAM,GAAG,CACT,GAAGlM,OAAO,CACb,CAAC4D,IAAI,CAAC,CAACuI,CAAC,EAAEC,CAAC,KAAG;MACX,IAAID,CAAC,KAAKC,CAAC,EAAE,OAAO,CAAC;MACrB,IAAID,CAAC,GAAGC,CAAC,EAAE,OAAO,CAAC,CAAC;MACpB,OAAO,CAAC;IACZ,CAAC,CAAC;IACF;IACA,IAAIC,gBAAgB,GAAG,IAAI1L,GAAG,CAACuL,MAAM,CAAC7O,GAAG,CAAEiP,SAAS,IAAG,CAC/CA,SAAS,EACT,IAAI,CACP,CAAC,CAAC;IACP;IACA;IACA,IAAIC,KAAK,GAAG,CAAC,CAAC,EAAE3R,cAAc,CAAC4R,aAAa,EAAE,IAAI3C,GAAG,CAACqC,MAAM,CAAC,EAAErP,OAAO,CAAC;IACvE0P,KAAK,GAAG1P,OAAO,CAACsF,OAAO,CAACyB,IAAI,CAAC2I,KAAK,CAAC;IACnC,IAAIzO,GAAG,GAAG2O,MAAM,CAACT,iBAAiB,CAACjO,MAAM,CAAC;IAC1C,KAAK,MAAM,GAAGyC,IAAI,CAAC,IAAI+L,KAAK,EAAC;MACzB,IAAIG,SAAS,GAAGlM,IAAI,CAACmM,IAAI,CAACC,QAAQ,CAACF,SAAS;MAC5C,IAAIG,qBAAqB;MACzB;MACA;MACAR,gBAAgB,CAAClQ,GAAG,CAACuQ,SAAS,EAAE,CAACG,qBAAqB,GAAGR,gBAAgB,CAACrT,GAAG,CAAC0T,SAAS,CAAC,MAAM,IAAI,IAAIG,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG/O,GAAG,EAAE,CAAC;IAC3K;IACA,OAAOkC,OAAO,CAAC3C,GAAG,CAAEiP,SAAS,IAAG;MAC5B,IAAIO,qBAAqB;MACzB,IAAIC,KAAK,GAAG,CAACD,qBAAqB,GAAGR,gBAAgB,CAACrT,GAAG,CAACsT,SAAS,CAAC,MAAM,IAAI,IAAIO,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,IAAI;MACjJ,IAAIE,aAAa,GAAGf,iBAAiB,CAACrN,OAAO,CAAC2N,SAAS,CAAC;MACxD,IAAIQ,KAAK,KAAK,IAAI,IAAIC,aAAa,KAAK,CAAC,CAAC,EAAE;QACxC;QACA;QACA;QACAD,KAAK,GAAGL,MAAM,CAACM,aAAa,CAAC;MACjC;MACA,OAAO,CACHT,SAAS,EACTQ,KAAK,CACR;IACL,CAAC,CAAC;EACN,CAAC;EACD;EACA;EACAjQ,OAAO,CAACmQ,YAAY,GAAG,SAASA,YAAYA,CAAC9P,OAAO,GAAG,CAAC,CAAC,EAAE;IACvD,IAAI+P,MAAM,GAAG,EAAE;IACf,KAAK,IAAIlC,IAAI,IAAI3I,SAAS,EAAC;MACvB,IAAI9E,KAAK,CAACC,OAAO,CAACwN,IAAI,CAAC,EAAE;QACrB,IAAImC,kBAAkB;QACtB,IAAI,CAACjC,QAAQ,EAAEkC,WAAW,CAAC,GAAGpC,IAAI;QAClC,IAAIqC,eAAe,GAAG,EAAE;QACxB,IAAIC,sBAAsB;QAC1B,IAAIzI,SAAS,GAAGrM,MAAM,CAAC2S,IAAI,CAAC,CAACmC,sBAAsB,GAAGF,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACvI,SAAS,MAAM,IAAI,IAAIyI,sBAAsB,KAAK,KAAK,CAAC,GAAGA,sBAAsB,GAAG,CAAC,CAAC,CAAC;QACnN,IAAIF,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACD,kBAAkB,GAAGC,WAAW,CAAChQ,KAAK,MAAM,IAAI,IAAI+P,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAAC9H,IAAI,CAAC,CAAC;UAAEnI;QAAM,CAAC,KAAGA,IAAI,KAAK,OAAO,CAAC,EAAE;UAChN,IAAIqQ,qCAAqC;UACzC1I,SAAS,CAAC3G,IAAI,CAAC,GAAG1F,MAAM,CAAC2S,IAAI,CAAC,CAACoC,qCAAqC,GAAGzQ,OAAO,CAACE,cAAc,CAACoG,KAAK,CAACoI,OAAO,MAAM,IAAI,IAAI+B,qCAAqC,KAAK,KAAK,CAAC,GAAGA,qCAAqC,GAAG,CAAC,CAAC,CAAC,CAAC;QAC5N;QACA,IAAIC,QAAQ,GAAG;UACX3I;QACJ,CAAC;QACD,IAAI4I,eAAe,GAAGtQ,OAAO,CAACsQ,eAAe,IAAI5I,SAAS,CAAC7G,MAAM,GAAG,CAAC;QACrE,IAAI0P,mBAAmB;QACvB,KAAK,IAAI,CAAC3R,GAAG,EAAEpD,KAAK,CAAC,IAAIH,MAAM,CAACuO,OAAO,CAAC,CAAC2G,mBAAmB,GAAGN,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACpG,MAAM,MAAM,IAAI,IAAI0G,mBAAmB,KAAK,KAAK,CAAC,GAAGA,mBAAmB,GAAG,CAAC,CAAC,CAAC,EAAC;UAChN;UACA,IAAI/U,KAAK,IAAI,IAAI,EAAE;YACf;UACJ;UACA,IAAI2S,GAAG,GAAG,CAAC,CAAC,EAAElR,UAAU,CAACgR,WAAW,EAAEF,QAAQ,EAAEnP,GAAG,CAAC;UACpDmR,MAAM,CAAChP,IAAI,CAACuP,eAAe,GAAG,CAC1BnC,GAAG,EACHkC,QAAQ,CACX,GAAGlC,GAAG,CAAC;UACR,IAAI,CAAC8B,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAAC/B,sBAAsB,KAAK,CAAC,CAAC,EAAE1Q,YAAY,CAACS,OAAO,EAAEzC,KAAK,CAAC,EAAE;YACpI,IAAI2S,GAAG,GAAG,CAAC,CAAC,EAAElR,UAAU,CAACgR,WAAW,EAAEF,QAAQ,EAAG,IAAGnP,GAAI,EAAC,CAAC;YAC1DsR,eAAe,CAACnP,IAAI,CAACuP,eAAe,GAAG,CACnCnC,GAAG,EACHkC,QAAQ,CACX,GAAGlC,GAAG,CAAC;UACZ;QACJ;QACA4B,MAAM,CAAChP,IAAI,CAAC,GAAGmP,eAAe,CAAC;MACnC,CAAC,MAAM;QACHH,MAAM,CAAChP,IAAI,CAAC8M,IAAI,CAAC;MACrB;IACJ;IACA,OAAOkC,MAAM;EACjB,CAAC;EACD;EACApQ,OAAO,CAAC6Q,WAAW,GAAG,SAASA,WAAWA,CAAA,EAAG;IACzC,IAAIpH,MAAM,GAAG,EAAE;IACf,KAAK,IAAI,CAACxN,IAAI,EAAEoE,OAAO,CAAC,IAAIL,OAAO,CAAC0J,cAAc,CAACO,OAAO,CAAC,CAAC,EAAC;MACzD,IAAI5J,OAAO,CAAC8J,WAAW,KAAKvK,YAAY,CAACC,IAAI,EAAE;MAC/C,IAAImK,eAAe;MACnBP,MAAM,CAACrI,IAAI,CAAC;QACRnF,IAAI;QACJ6U,WAAW,EAAEzQ,OAAO,CAACD,IAAI,KAAKb,MAAM,CAACG,GAAG,CAAC,eAAe,CAAC;QACzDwK,MAAM,EAAExO,MAAM,CAAC2S,IAAI,CAAC,CAACrE,eAAe,GAAG3J,OAAO,CAAC6J,MAAM,MAAM,IAAI,IAAIF,eAAe,KAAK,KAAK,CAAC,GAAGA,eAAe,GAAG,CAAC,CAAC,CAAC;QACrH+G,OAAO,EAAE9U,IAAI,KAAK,GAAG;QACrByG,SAASA,CAAE;UAAEuF,QAAQ;UAAGpM;QAAO,CAAC,GAAG,CAAC,CAAC,EAAE;UACnC,IAAIgU,SAAS,GAAG,0BAA0B;UAC1C,IAAIlM,IAAI,GAAG7G,QAAQ,CAACwB,OAAO,CAACqF,IAAI,CAAC;YAC7B1D,QAAQ,EAAG,IAAG4P,SAAU;UAC5B,CAAC,CAAC;UACF,IAAItG,SAAS,GAAGzM,QAAQ,CAACwB,OAAO,CAAC0N,IAAI,CAAC;YAClCF,KAAK,EAAE,CACHnI,IAAI,CAACqN,KAAK,CAAC,CAAC;UAEpB,CAAC,CAAC;UACF,IAAIrP,MAAM,GAAG4H,SAAS,CAAC0H,QAAQ,CAAC,CAAC;UACjC,IAAIC,uBAAuB;UAC3B,IAAIzM,GAAG,GAAG,CAAC,CAACyM,uBAAuB,GAAGlR,OAAO,CAACqF,UAAU,CAAClJ,GAAG,CAACF,IAAI,CAAC,MAAM,IAAI,IAAIiV,uBAAuB,KAAK,KAAK,CAAC,GAAGA,uBAAuB,GAAG,EAAE,EAAE9O,OAAO,CAAC,CAAC,CAAC+O,CAAC,EAAEjM,EAAE,CAAC,KAAGA,EAAE,CAAC;UACzK,IAAIkM,aAAa,GAAG,EAAE;UACtB,KAAK,IAAIlM,EAAE,IAAIT,GAAG,EAAC;YACf,IAAIuF,eAAe;YACnB,IAAIqH,kBAAkB,GAAG,EAAE;YAC3B,IAAIC,qBAAqB;YACzB,IAAIrM,GAAG,GAAG;cACNoE,IAAI,EAAE;gBACFpB,QAAQ;gBACRpM,KAAK,EAAE,CAACyV,qBAAqB,GAAG,CAACtH,eAAe,GAAG3J,OAAO,CAAC6J,MAAM,MAAM,IAAI,IAAIF,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACnO,KAAK,CAAC,MAAM,IAAI,IAAIyV,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAGzV;cACxN,CAAC;cACD2N,SAAS,EAAExJ,OAAO,CAACE,cAAc,CAACsJ,SAAS;cAC3CF,eAAeA,CAAEiI,gBAAgB,EAAE;gBAC/B;gBACAhI,SAAS,CAAC2C,IAAI,CAAEvI,IAAI,IAAG;kBACnB,IAAIA,IAAI,CAACvD,IAAI,KAAK,MAAM,EAAE;oBACtB;kBACJ;kBACAuD,IAAI,CAACjB,SAAS,GAAGiB,IAAI,CAACjB,SAAS,CAAClC,GAAG,CAAEP,QAAQ,IAAG;oBAC5C,OAAOsR,gBAAgB,CAAC;sBACpB,IAAI9B,SAASA,CAAA,EAAI;wBACb,OAAO,CAAC,CAAC,EAAE1R,cAAc,CAACyT,wBAAwB,EAAEvR,QAAQ,CAAC;sBACjE,CAAC;sBACDA;oBACJ,CAAC,CAAC;kBACN,CAAC,CAAC;gBACN,CAAC,CAAC;gBACF,OAAOsJ,SAAS;cACpB,CAAC;cACDnF,MAAMA,CAAEM,GAAG,EAAE;gBACT2M,kBAAkB,CAACjQ,IAAI,CAACsD,GAAG,CAAC;cAChC,CAAC;cACDI,IAAIA,CAAE2M,OAAO,EAAE;gBACXJ,kBAAkB,CAACjQ,IAAI,CAAE,IAAGqQ,OAAO,CAACxV,IAAK,IAAGwV,OAAO,CAAC9M,MAAO,QAAO,CAAC;cACvE,CAAC;cACD4E;YACJ,CAAC;YACD,IAAImI,eAAe,GAAGxM,EAAE,CAACD,GAAG,CAAC;YAC7B,IAAIoM,kBAAkB,CAACnQ,MAAM,GAAG,CAAC,EAAE;cAC/BkQ,aAAa,CAAChQ,IAAI,CAACiQ,kBAAkB,CAAC;YAC1C;YACA,IAAI5Q,KAAK,CAACC,OAAO,CAACgR,eAAe,CAAC,EAAE;cAChC,KAAK,IAAItI,eAAe,IAAIsI,eAAe,EAAC;gBACxCL,kBAAkB,GAAG,EAAE;gBACvBjI,eAAe,CAACnE,GAAG,CAAC;gBACpBmM,aAAa,CAAChQ,IAAI,CAACiQ,kBAAkB,CAAC;cAC1C;YACJ;UACJ;UACA;UACA,IAAIM,mBAAmB,GAAG,EAAE;UAC5B,IAAIC,KAAK,GAAGrI,SAAS,CAAC0H,QAAQ,CAAC,CAAC;UAChC,IAAItP,MAAM,KAAKiQ,KAAK,EAAE;YAClB;YACArI,SAAS,CAAC7F,SAAS,CAAEC,IAAI,IAAG;cACxB,IAAIkO,QAAQ,GAAGlO,IAAI,CAAC1D,QAAQ;cAC5B;cACA;cACA;cACA;cACA,IAAI6R,WAAW,GAAG,CAAC,CAAC,EAAE9U,sBAAsB,CAACsB,OAAO,EAAGoE,SAAS,IAAG;gBAC/DA,SAAS,CAACE,WAAW,CAAEC,SAAS,IAAG;kBAC/BA,SAAS,CAAChH,KAAK,GAAI,GAAEI,IAAK,GAAE+D,OAAO,CAACE,cAAc,CAACsJ,SAAU,GAAE3G,SAAS,CAAChH,KAAM,EAAC;gBACpF,CAAC,CAAC;cACN,CAAC,CAAC,CAACkW,WAAW,CAACF,QAAQ,CAAC;cACxB;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACA;cACAF,mBAAmB,CAACvQ,IAAI,CAACyQ,QAAQ,CAACrN,OAAO,CAACsN,WAAW,EAAE,GAAG,CAAC,CAACtN,OAAO,CAACqL,SAAS,EAAE,GAAG,CAAC,CAAC;YACxF,CAAC,CAAC;YACF;YACAtG,SAAS,CAACsC,WAAW,CAAEmG,MAAM,IAAG;cAC5BL,mBAAmB,CAACvQ,IAAI,CAAE,IAAG4Q,MAAM,CAAC/V,IAAK,KAAI+V,MAAM,CAACrN,MAAO,SAAQ,CAAC;YACxE,CAAC,CAAC;UACN;UACA,IAAIyF,gBAAgB;UACpB,IAAI6H,kBAAkB,GAAG,EAAEpW,KAAK,KAAK,CAACuO,gBAAgB,GAAG/J,OAAO,CAAC6J,MAAM,MAAM,IAAI,IAAIE,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;UAC1I,IAAI8H,0BAA0B;UAC9B,IAAIC,gBAAgB,GAAG,CAACD,0BAA0B,GAAG7R,OAAO,CAACjE,iBAAiB,CAAC,MAAM,IAAI,IAAI8V,0BAA0B,KAAK,KAAK,CAAC,GAAGA,0BAA0B,GAAG,CAAC,CAAC;UACpK,IAAIpM,aAAa,GAAG,CAAC,MAAI;YACrB,IAAImM,kBAAkB,EAAE,OAAO,KAAK;YACpC,IAAIE,gBAAgB,CAACrM,aAAa,KAAK,KAAK,EAAE,OAAO,KAAK;YAC1D,OAAO,IAAI;UACf,CAAC,EAAE,CAAC;UACJsL,aAAa,GAAGA,aAAa,CAAC5Q,GAAG,CAAE4D,MAAM,IAAGA,MAAM,CAAC5D,GAAG,CAAEkE,GAAG,KAAI;YACnDN,MAAM,EAAEM,GAAG;YACXoB;UACJ,CAAC,CAAC,CAAC,CAAC;UACZ6L,mBAAmB,GAAGA,mBAAmB,CAACnR,GAAG,CAAE4D,MAAM,KAAI;YACjDA,MAAM;YACN0B;UACJ,CAAC,CAAC,CAAC;UACP,IAAIE,IAAI,GAAG;YACP6J,SAAS;YACT7P;UACJ,CAAC;UACD,IAAIyJ,MAAM,GAAG2H,aAAa,CAAC5Q,GAAG,CAAE4R,OAAO,IAAG,CAAC,CAAC,EAAEjU,sBAAsB,CAACkU,gBAAgB,EAAG,IAAGxC,SAAU,EAAC,EAAE,CAAC,CAAC,EAAE1R,sBAAsB,CAACmU,qBAAqB,EAAEF,OAAO,EAAEpM,IAAI,CAAC,EAAEA,IAAI,CAAC,CAACxB,OAAO,CAAE,IAAGqL,SAAU,EAAC,EAAE,GAAG,CAAC,CAACrL,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAACnD,IAAI,CAAC,CAAC,CAAC;UAC1O,IAAIsQ,mBAAmB,CAACzQ,MAAM,GAAG,CAAC,EAAE;YAChCuI,MAAM,CAACrI,IAAI,CAAC,CAAC,CAAC,EAAEjD,sBAAsB,CAACmU,qBAAqB,EAAEX,mBAAmB,EAAE3L,IAAI,CAAC,CAACiL,QAAQ,CAAC,CAAC,CAACzM,OAAO,CAAE,IAAGqL,SAAU,EAAC,EAAE,GAAG,CAAC,CAAC;UACtI;UACA,OAAOpG,MAAM;QACjB;MACJ,CAAC,CAAC;IACN;IACA,OAAOA,MAAM;EACjB,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAAS8I,2BAA2BA,CAACvS,OAAO,EAAE6P,SAAS,EAAE;EACzD,IAAI,CAAC7P,OAAO,CAACwS,UAAU,CAAC3T,GAAG,CAACgR,SAAS,CAAC,EAAE;IACpC;EACJ;EACA;EACA7P,OAAO,CAACyS,aAAa,CAAC9K,GAAG,CAACkI,SAAS,CAAC;EACpC;EACA7P,OAAO,CAACwS,UAAU,CAACE,MAAM,CAAC7C,SAAS,CAAC;EACpC7P,OAAO,CAAC2S,eAAe,CAACD,MAAM,CAAC7C,SAAS,CAAC;EACzC7P,OAAO,CAAC8G,gBAAgB,CAAC4L,MAAM,CAAC7C,SAAS,CAAC;EAC1C7P,OAAO,CAAC4S,kBAAkB,CAACF,MAAM,CAAC7C,SAAS,CAAC;EAC5C;EACA7P,OAAO,CAAC6S,eAAe,GAAG,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AAAI,SAASC,sBAAsBA,CAAC9S,OAAO,EAAEgD,IAAI,EAAE;EAC/C,IAAI6M,SAAS,GAAG7M,IAAI,CAAC8M,IAAI,CAACC,QAAQ,CAACF,SAAS;EAC5C,IAAI,CAACA,SAAS,EAAE;IACZ;EACJ;EACA,KAAK,MAAMkD,KAAK,IAAI/S,OAAO,CAACgT,SAAS,EAAC;IAClC,IAAID,KAAK,CAAC,CAAC,CAAC,CAACjD,IAAI,CAACC,QAAQ,CAACF,SAAS,KAAKA,SAAS,EAAE;MAChD7P,OAAO,CAACgT,SAAS,CAACN,MAAM,CAACK,KAAK,CAAC;MACnC;IACA;EACJ;;EACAR,2BAA2B,CAACvS,OAAO,EAAE6P,SAAS,CAAC;AACnD;AACA,SAASrT,aAAaA,CAAC0D,cAAc,EAAEsN,cAAc,GAAG,EAAE,EAAExB,IAAI,GAAGlP,QAAQ,CAACwB,OAAO,CAAC0N,IAAI,CAAC,CAAC,EAAE;EACxF,IAAIiH,yBAAyB;EAC7B,IAAIjT,OAAO,GAAG;IACVkT,WAAW,EAAE,EAAE;IACfF,SAAS,EAAE,IAAIhG,GAAG,CAAC,CAAC;IACpB4F,kBAAkB,EAAE,IAAI9O,GAAG,CAAC,CAAC;IAC7B0O,UAAU,EAAE,IAAI1O,GAAG,CAAC,CAAC;IACrB6O,eAAe,EAAE,IAAI7O,GAAG,CAAC,CAAC;IAC1B;IACA2O,aAAa,EAAE,IAAIzF,GAAG,CAAC,CAACiG,yBAAyB,GAAG/S,cAAc,CAACiT,SAAS,MAAM,IAAI,IAAIF,yBAAyB,KAAK,KAAK,CAAC,GAAGA,yBAAyB,GAAG,EAAE,CAAC;IAChKG,gBAAgB,EAAE,IAAItP,GAAG,CAAC,CAAC;IAC3BgD,gBAAgB,EAAE,IAAIhD,GAAG,CAAC,CAAC;IAC3B5D,cAAc;IACdsN,cAAc,EAAEA,cAAc;IAC9BnI,UAAU,EAAE,IAAIvB,GAAG,CAAC,CAAC;IACrB+O,eAAe,EAAE,IAAI;IACrBnJ,cAAc,EAAE,IAAI5F,GAAG,CAAC,CAAC;IACzByO,2BAA2B,EAAG1C,SAAS,IAAG0C,2BAA2B,CAACvS,OAAO,EAAE6P,SAAS,CAAC;IACzFiD,sBAAsB,EAAG9P,IAAI,IAAG8P,sBAAsB,CAAC9S,OAAO,EAAEgD,IAAI;EACxE,CAAC;EACD,IAAIqQ,eAAe,GAAGjH,cAAc,CAACpM,OAAO,EAAEgM,IAAI,CAAC;EACnDc,eAAe,CAACuG,eAAe,EAAErT,OAAO,CAAC;EACzC,OAAOA,OAAO;AAClB;AACA,IAAIsT,UAAU,GAAG5V,YAAY,CAAC4V,UAAU;AACxC,IAAIC,gBAAgB,GAAG7V,YAAY,CAAC6V,gBAAgB;AACpD,IAAIC,iBAAiB,GAAG9V,YAAY,CAAC8V,iBAAiB;AACtD,SAAS/W,UAAUA,CAACuP,IAAI,EAAEvC,MAAM,EAAEvJ,cAAc,EAAEuT,cAAc,EAAEC,kBAAkB,EAAEC,mBAAmB,EAAE;EACvG,IAAIC,UAAU,GAAGnK,MAAM,CAACzD,IAAI,CAAC6N,IAAI;EACjC,IAAIC,YAAY,GAAGL,cAAc,KAAK,IAAI;EAC1C/V,YAAY,CAACqW,GAAG,CAACC,KAAK,IAAIC,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEN,UAAU,CAAC;EACjE,IAAIO,eAAe;EACnB,IAAIL,YAAY,IAAIR,UAAU,CAACzU,GAAG,CAAC+U,UAAU,CAAC,EAAE;IAC5CO,eAAe,GAAGb,UAAU,CAACnX,GAAG,CAACyX,UAAU,CAAC;EAChD,CAAC,MAAM,IAAIL,gBAAgB,CAAC1U,GAAG,CAAC6U,kBAAkB,CAAC,EAAE;IACjD,IAAI1T,OAAO,GAAGuT,gBAAgB,CAACpX,GAAG,CAACuX,kBAAkB,CAAC;IACtDF,iBAAiB,CAACrX,GAAG,CAAC6D,OAAO,CAAC,CAAC2H,GAAG,CAACiM,UAAU,CAAC;IAC9CN,UAAU,CAAChU,GAAG,CAACsU,UAAU,EAAE5T,OAAO,CAAC;IACnCmU,eAAe,GAAGnU,OAAO;EAC7B;EACA,IAAIoU,YAAY,GAAG,CAAC,CAAC,EAAEpW,kBAAkB,CAACqW,iBAAiB,EAAET,UAAU,EAAE5H,IAAI,CAAC;EAC9E;EACA;EACA,IAAImI,eAAe,EAAE;IACjB,IAAI,CAACG,0BAA0B,EAAExJ,cAAc,CAAC,GAAGJ,aAAa,CAAC,CAC7D,GAAGiJ,mBAAmB,CACzB,EAAEpX,kBAAkB,CAAC4X,eAAe,CAAC,CAAC;IACvC,IAAI,CAACG,0BAA0B,IAAI,CAACF,YAAY,EAAE;MAC9C,OAAO,CACHD,eAAe,EACf,KAAK,EACLrJ,cAAc,CACjB;IACL;EACJ;EACA;EACA;EACA;EACA;EACA;EACA,IAAIwI,UAAU,CAACzU,GAAG,CAAC+U,UAAU,CAAC,EAAE;IAC5B,IAAIW,UAAU,GAAGjB,UAAU,CAACnX,GAAG,CAACyX,UAAU,CAAC;IAC3C,IAAIJ,iBAAiB,CAAC3U,GAAG,CAAC0V,UAAU,CAAC,EAAE;MACnCf,iBAAiB,CAACrX,GAAG,CAACoY,UAAU,CAAC,CAAC7B,MAAM,CAACkB,UAAU,CAAC;MACpD,IAAIJ,iBAAiB,CAACrX,GAAG,CAACoY,UAAU,CAAC,CAACC,IAAI,KAAK,CAAC,EAAE;QAC9ChB,iBAAiB,CAACd,MAAM,CAAC6B,UAAU,CAAC;QACpC,KAAK,IAAI,CAACb,kBAAkB,EAAE1T,OAAO,CAAC,IAAIuT,gBAAgB,EAAC;UACvD,IAAIvT,OAAO,KAAKuU,UAAU,EAAE;YACxBhB,gBAAgB,CAACb,MAAM,CAACgB,kBAAkB,CAAC;UAC/C;QACJ;QACA,KAAK,IAAIe,UAAU,IAAIF,UAAU,CAACrB,WAAW,CAACjR,MAAM,CAAC,CAAC,CAAC,EAAC;UACpDwS,UAAU,CAACF,UAAU,CAAC;QAC1B;MACJ;IACJ;EACJ;EACA7W,YAAY,CAACqW,GAAG,CAACC,KAAK,IAAIC,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;EAClE,IAAIlU,OAAO,GAAGxD,aAAa,CAAC0D,cAAc,EAAE,EAAE,EAAE8L,IAAI,CAAC;EACrDtQ,MAAM,CAACgM,MAAM,CAAC1H,OAAO,EAAE;IACnByT;EACJ,CAAC,CAAC;EACF,IAAI,GAAG3I,cAAc,CAAC,GAAGJ,aAAa,CAAC,CACnC,GAAGiJ,mBAAmB,CACzB,EAAEpX,kBAAkB,CAACyD,OAAO,CAAC,CAAC;EAC/B;EACA;EACAuT,gBAAgB,CAACjU,GAAG,CAACoU,kBAAkB,EAAE1T,OAAO,CAAC;EACjDsT,UAAU,CAAChU,GAAG,CAACsU,UAAU,EAAE5T,OAAO,CAAC;EACnC,IAAI,CAACwT,iBAAiB,CAAC3U,GAAG,CAACmB,OAAO,CAAC,EAAE;IACjCwT,iBAAiB,CAAClU,GAAG,CAACU,OAAO,EAAE,IAAIgN,GAAG,CAAC,CAAC,CAAC;EAC7C;EACAwG,iBAAiB,CAACrX,GAAG,CAAC6D,OAAO,CAAC,CAAC2H,GAAG,CAACiM,UAAU,CAAC;EAC9C,OAAO,CACH5T,OAAO,EACP,IAAI,EACJ8K,cAAc,CACjB;AACL"},"metadata":{},"sourceType":"script","externalDependencies":[]}