{"ast":null,"code":"import { ContextualKeyword } from \"../parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport Transformer from \"./Transformer\";\nexport default class FlowTransformer extends Transformer {\n  constructor(rootTransformer, tokens, isImportsTransformEnabled) {\n    super();\n    this.rootTransformer = rootTransformer;\n    this.tokens = tokens;\n    this.isImportsTransformEnabled = isImportsTransformEnabled;\n    ;\n  }\n  process() {\n    if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {\n      return true;\n    }\n    if (this.tokens.matches1(tt._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt._enum)) {\n      this.processNamedExportEnum();\n      return true;\n    }\n    if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {\n      this.processDefaultExportEnum();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a declaration like:\n   * export enum E ...\n   *\n   * With this imports transform, this becomes:\n   * const E = [[enum]]; exports.E = E;\n   *\n   * otherwise, it becomes:\n   * export const E = [[enum]];\n   */\n  processNamedExportEnum() {\n    if (this.isImportsTransformEnabled) {\n      // export\n      this.tokens.removeInitialToken();\n      const enumName = this.tokens.identifierNameAtRelativeIndex(1);\n      this.processEnum();\n      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);\n    } else {\n      this.tokens.copyToken();\n      this.processEnum();\n    }\n  }\n\n  /**\n   * Handle a declaration like:\n   * export default enum E\n   *\n   * With the imports transform, this becomes:\n   * const E = [[enum]]; exports.default = E;\n   *\n   * otherwise, it becomes:\n   * const E = [[enum]]; export default E;\n   */\n  processDefaultExportEnum() {\n    // export\n    this.tokens.removeInitialToken();\n    // default\n    this.tokens.removeToken();\n    const enumName = this.tokens.identifierNameAtRelativeIndex(1);\n    this.processEnum();\n    if (this.isImportsTransformEnabled) {\n      this.tokens.appendCode(` exports.default = ${enumName};`);\n    } else {\n      this.tokens.appendCode(` export default ${enumName};`);\n    }\n  }\n\n  /**\n   * Transpile flow enums to invoke the \"flow-enums-runtime\" library.\n   *\n   * Currently, the transpiled code always uses `require(\"flow-enums-runtime\")`,\n   * but if future flexibility is needed, we could expose a config option for\n   * this string (similar to configurable JSX). Even when targeting ESM, the\n   * default behavior of babel-plugin-transform-flow-enums is to use require\n   * rather than injecting an import.\n   *\n   * Flow enums are quite a bit simpler than TS enums and have some convenient\n   * constraints:\n   * - Element initializers must be either always present or always absent. That\n   *   means that we can use fixed lookahead on the first element (if any) and\n   *   assume that all elements are like that.\n   * - The right-hand side of an element initializer must be a literal value,\n   *   not a complex expression and not referencing other elements. That means\n   *   we can simply copy a single token.\n   *\n   * Enums can be broken up into three basic cases:\n   *\n   * Mirrored enums:\n   * enum E {A, B}\n   *   ->\n   * const E = require(\"flow-enums-runtime\").Mirrored([\"A\", \"B\"]);\n   *\n   * Initializer enums:\n   * enum E {A = 1, B = 2}\n   *   ->\n   * const E = require(\"flow-enums-runtime\")({A: 1, B: 2});\n   *\n   * Symbol enums:\n   * enum E of symbol {A, B}\n   *   ->\n   * const E = require(\"flow-enums-runtime\")({A: Symbol(\"A\"), B: Symbol(\"B\")});\n   *\n   * We can statically detect which of the three cases this is by looking at the\n   * \"of\" declaration (if any) and seeing if the first element has an initializer.\n   * Since the other transform details are so similar between the three cases, we\n   * use a single implementation and vary the transform within processEnumElement\n   * based on case.\n   */\n  processEnum() {\n    // enum E -> const E\n    this.tokens.replaceToken(\"const\");\n    this.tokens.copyExpectedToken(tt.name);\n    let isSymbolEnum = false;\n    if (this.tokens.matchesContextual(ContextualKeyword._of)) {\n      this.tokens.removeToken();\n      isSymbolEnum = this.tokens.matchesContextual(ContextualKeyword._symbol);\n      this.tokens.removeToken();\n    }\n    const hasInitializers = this.tokens.matches3(tt.braceL, tt.name, tt.eq);\n    this.tokens.appendCode(' = require(\"flow-enums-runtime\")');\n    const isMirrored = !isSymbolEnum && !hasInitializers;\n    this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? \".Mirrored([\" : \"({\");\n    while (!this.tokens.matches1(tt.braceR)) {\n      // ... is allowed at the end and has no runtime behavior.\n      if (this.tokens.matches1(tt.ellipsis)) {\n        this.tokens.removeToken();\n        break;\n      }\n      this.processEnumElement(isSymbolEnum, hasInitializers);\n      if (this.tokens.matches1(tt.comma)) {\n        this.tokens.copyToken();\n      }\n    }\n    this.tokens.replaceToken(isMirrored ? \"]);\" : \"});\");\n  }\n\n  /**\n   * Process an individual enum element, producing either an array element or an\n   * object element based on what type of enum this is.\n   */\n  processEnumElement(isSymbolEnum, hasInitializers) {\n    if (isSymbolEnum) {\n      // Symbol enums never have initializers and are expanded to object elements.\n      // A, -> A: Symbol(\"A\"),\n      const elementName = this.tokens.identifierName();\n      this.tokens.copyToken();\n      this.tokens.appendCode(`: Symbol(\"${elementName}\")`);\n    } else if (hasInitializers) {\n      // Initializers are expanded to object elements.\n      // A = 1, -> A: 1,\n      this.tokens.copyToken();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(\":\");\n      this.tokens.copyToken();\n    } else {\n      // Enum elements without initializers become string literal array elements.\n      // A, -> \"A\",\n      this.tokens.replaceToken(`\"${this.tokens.identifierName()}\"`);\n    }\n  }\n}","map":{"version":3,"names":["ContextualKeyword","TokenType","tt","Transformer","FlowTransformer","constructor","rootTransformer","tokens","isImportsTransformEnabled","process","processPossibleArrowParamEnd","processPossibleAsyncArrowWithTypeParams","processPossibleTypeRange","matches1","_enum","processEnum","matches2","_export","processNamedExportEnum","matches3","_default","processDefaultExportEnum","removeInitialToken","enumName","identifierNameAtRelativeIndex","appendCode","copyToken","removeToken","replaceToken","copyExpectedToken","name","isSymbolEnum","matchesContextual","_of","_symbol","hasInitializers","braceL","eq","isMirrored","replaceTokenTrimmingLeftWhitespace","braceR","ellipsis","processEnumElement","comma","elementName","identifierName"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/FlowTransformer.js"],"sourcesContent":["import {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\nimport Transformer from \"./Transformer\";\n\nexport default class FlowTransformer extends Transformer {\n  constructor(\n     rootTransformer,\n     tokens,\n     isImportsTransformEnabled,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;\n  }\n\n  process() {\n    if (\n      this.rootTransformer.processPossibleArrowParamEnd() ||\n      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||\n      this.rootTransformer.processPossibleTypeRange()\n    ) {\n      return true;\n    }\n    if (this.tokens.matches1(tt._enum)) {\n      this.processEnum();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt._enum)) {\n      this.processNamedExportEnum();\n      return true;\n    }\n    if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {\n      this.processDefaultExportEnum();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a declaration like:\n   * export enum E ...\n   *\n   * With this imports transform, this becomes:\n   * const E = [[enum]]; exports.E = E;\n   *\n   * otherwise, it becomes:\n   * export const E = [[enum]];\n   */\n  processNamedExportEnum() {\n    if (this.isImportsTransformEnabled) {\n      // export\n      this.tokens.removeInitialToken();\n      const enumName = this.tokens.identifierNameAtRelativeIndex(1);\n      this.processEnum();\n      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);\n    } else {\n      this.tokens.copyToken();\n      this.processEnum();\n    }\n  }\n\n  /**\n   * Handle a declaration like:\n   * export default enum E\n   *\n   * With the imports transform, this becomes:\n   * const E = [[enum]]; exports.default = E;\n   *\n   * otherwise, it becomes:\n   * const E = [[enum]]; export default E;\n   */\n  processDefaultExportEnum() {\n    // export\n    this.tokens.removeInitialToken();\n    // default\n    this.tokens.removeToken();\n    const enumName = this.tokens.identifierNameAtRelativeIndex(1);\n    this.processEnum();\n    if (this.isImportsTransformEnabled) {\n      this.tokens.appendCode(` exports.default = ${enumName};`);\n    } else {\n      this.tokens.appendCode(` export default ${enumName};`);\n    }\n  }\n\n  /**\n   * Transpile flow enums to invoke the \"flow-enums-runtime\" library.\n   *\n   * Currently, the transpiled code always uses `require(\"flow-enums-runtime\")`,\n   * but if future flexibility is needed, we could expose a config option for\n   * this string (similar to configurable JSX). Even when targeting ESM, the\n   * default behavior of babel-plugin-transform-flow-enums is to use require\n   * rather than injecting an import.\n   *\n   * Flow enums are quite a bit simpler than TS enums and have some convenient\n   * constraints:\n   * - Element initializers must be either always present or always absent. That\n   *   means that we can use fixed lookahead on the first element (if any) and\n   *   assume that all elements are like that.\n   * - The right-hand side of an element initializer must be a literal value,\n   *   not a complex expression and not referencing other elements. That means\n   *   we can simply copy a single token.\n   *\n   * Enums can be broken up into three basic cases:\n   *\n   * Mirrored enums:\n   * enum E {A, B}\n   *   ->\n   * const E = require(\"flow-enums-runtime\").Mirrored([\"A\", \"B\"]);\n   *\n   * Initializer enums:\n   * enum E {A = 1, B = 2}\n   *   ->\n   * const E = require(\"flow-enums-runtime\")({A: 1, B: 2});\n   *\n   * Symbol enums:\n   * enum E of symbol {A, B}\n   *   ->\n   * const E = require(\"flow-enums-runtime\")({A: Symbol(\"A\"), B: Symbol(\"B\")});\n   *\n   * We can statically detect which of the three cases this is by looking at the\n   * \"of\" declaration (if any) and seeing if the first element has an initializer.\n   * Since the other transform details are so similar between the three cases, we\n   * use a single implementation and vary the transform within processEnumElement\n   * based on case.\n   */\n  processEnum() {\n    // enum E -> const E\n    this.tokens.replaceToken(\"const\");\n    this.tokens.copyExpectedToken(tt.name);\n\n    let isSymbolEnum = false;\n    if (this.tokens.matchesContextual(ContextualKeyword._of)) {\n      this.tokens.removeToken();\n      isSymbolEnum = this.tokens.matchesContextual(ContextualKeyword._symbol);\n      this.tokens.removeToken();\n    }\n    const hasInitializers = this.tokens.matches3(tt.braceL, tt.name, tt.eq);\n    this.tokens.appendCode(' = require(\"flow-enums-runtime\")');\n\n    const isMirrored = !isSymbolEnum && !hasInitializers;\n    this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? \".Mirrored([\" : \"({\");\n\n    while (!this.tokens.matches1(tt.braceR)) {\n      // ... is allowed at the end and has no runtime behavior.\n      if (this.tokens.matches1(tt.ellipsis)) {\n        this.tokens.removeToken();\n        break;\n      }\n      this.processEnumElement(isSymbolEnum, hasInitializers);\n      if (this.tokens.matches1(tt.comma)) {\n        this.tokens.copyToken();\n      }\n    }\n\n    this.tokens.replaceToken(isMirrored ? \"]);\" : \"});\");\n  }\n\n  /**\n   * Process an individual enum element, producing either an array element or an\n   * object element based on what type of enum this is.\n   */\n  processEnumElement(isSymbolEnum, hasInitializers) {\n    if (isSymbolEnum) {\n      // Symbol enums never have initializers and are expanded to object elements.\n      // A, -> A: Symbol(\"A\"),\n      const elementName = this.tokens.identifierName();\n      this.tokens.copyToken();\n      this.tokens.appendCode(`: Symbol(\"${elementName}\")`);\n    } else if (hasInitializers) {\n      // Initializers are expanded to object elements.\n      // A = 1, -> A: 1,\n      this.tokens.copyToken();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(\":\");\n      this.tokens.copyToken();\n    } else {\n      // Enum elements without initializers become string literal array elements.\n      // A, -> \"A\",\n      this.tokens.replaceToken(`\"${this.tokens.identifierName()}\"`);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}