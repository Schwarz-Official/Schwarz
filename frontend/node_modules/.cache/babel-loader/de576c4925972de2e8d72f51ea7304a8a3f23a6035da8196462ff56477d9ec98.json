{"ast":null,"code":"import CJSImportProcessor from \"./CJSImportProcessor\";\nimport computeSourceMap from \"./computeSourceMap\";\nimport { HelperManager } from \"./HelperManager\";\nimport identifyShadowedGlobals from \"./identifyShadowedGlobals\";\nimport NameManager from \"./NameManager\";\nimport { validateOptions } from \"./Options\";\nimport { parse } from \"./parser\";\nimport TokenProcessor from \"./TokenProcessor\";\nimport RootTransformer from \"./transformers/RootTransformer\";\nimport formatTokens from \"./util/formatTokens\";\nimport getTSImportedNames from \"./util/getTSImportedNames\";\n;\nexport function getVersion() {\n  /* istanbul ignore next */\n  return \"3.34.0\";\n}\nexport function transform(code, options) {\n  validateOptions(options);\n  try {\n    const sucraseContext = getSucraseContext(code, options);\n    const transformer = new RootTransformer(sucraseContext, options.transforms, Boolean(options.enableLegacyBabel5ModuleInterop), options);\n    const transformerResult = transformer.transform();\n    let result = {\n      code: transformerResult.code\n    };\n    if (options.sourceMapOptions) {\n      if (!options.filePath) {\n        throw new Error(\"filePath must be specified when generating a source map.\");\n      }\n      result = {\n        ...result,\n        sourceMap: computeSourceMap(transformerResult, options.filePath, options.sourceMapOptions, code, sucraseContext.tokenProcessor.tokens)\n      };\n    }\n    return result;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e) {\n    if (options.filePath) {\n      e.message = `Error transforming ${options.filePath}: ${e.message}`;\n    }\n    throw e;\n  }\n}\n\n/**\n * Return a string representation of the sucrase tokens, mostly useful for\n * diagnostic purposes.\n */\nexport function getFormattedTokens(code, options) {\n  const tokens = getSucraseContext(code, options).tokenProcessor.tokens;\n  return formatTokens(code, tokens);\n}\n\n/**\n * Call into the parser/tokenizer and do some further preprocessing:\n * - Come up with a set of used names so that we can assign new names.\n * - Preprocess all import/export statements so we know which globals we are interested in.\n * - Compute situations where any of those globals are shadowed.\n *\n * In the future, some of these preprocessing steps can be skipped based on what actual work is\n * being done.\n */\nfunction getSucraseContext(code, options) {\n  const isJSXEnabled = options.transforms.includes(\"jsx\");\n  const isTypeScriptEnabled = options.transforms.includes(\"typescript\");\n  const isFlowEnabled = options.transforms.includes(\"flow\");\n  const disableESTransforms = options.disableESTransforms === true;\n  const file = parse(code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);\n  const tokens = file.tokens;\n  const scopes = file.scopes;\n  const nameManager = new NameManager(code, tokens);\n  const helperManager = new HelperManager(nameManager);\n  const tokenProcessor = new TokenProcessor(code, tokens, isFlowEnabled, disableESTransforms, helperManager);\n  const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);\n  let importProcessor = null;\n  if (options.transforms.includes(\"imports\")) {\n    importProcessor = new CJSImportProcessor(nameManager, tokenProcessor, enableLegacyTypeScriptModuleInterop, options, options.transforms.includes(\"typescript\"), Boolean(options.keepUnusedImports), helperManager);\n    importProcessor.preprocessTokens();\n    // We need to mark shadowed globals after processing imports so we know that the globals are,\n    // but before type-only import pruning, since that relies on shadowing information.\n    identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());\n    if (options.transforms.includes(\"typescript\") && !options.keepUnusedImports) {\n      importProcessor.pruneTypeOnlyImports();\n    }\n  } else if (options.transforms.includes(\"typescript\") && !options.keepUnusedImports) {\n    // Shadowed global detection is needed for TS implicit elision of imported names.\n    identifyShadowedGlobals(tokenProcessor, scopes, getTSImportedNames(tokenProcessor));\n  }\n  return {\n    tokenProcessor,\n    scopes,\n    nameManager,\n    importProcessor,\n    helperManager\n  };\n}","map":{"version":3,"names":["CJSImportProcessor","computeSourceMap","HelperManager","identifyShadowedGlobals","NameManager","validateOptions","parse","TokenProcessor","RootTransformer","formatTokens","getTSImportedNames","getVersion","transform","code","options","sucraseContext","getSucraseContext","transformer","transforms","Boolean","enableLegacyBabel5ModuleInterop","transformerResult","result","sourceMapOptions","filePath","Error","sourceMap","tokenProcessor","tokens","e","message","getFormattedTokens","isJSXEnabled","includes","isTypeScriptEnabled","isFlowEnabled","disableESTransforms","file","scopes","nameManager","helperManager","enableLegacyTypeScriptModuleInterop","importProcessor","keepUnusedImports","preprocessTokens","getGlobalNames","pruneTypeOnlyImports"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/index.js"],"sourcesContent":["import CJSImportProcessor from \"./CJSImportProcessor\";\nimport computeSourceMap, {} from \"./computeSourceMap\";\nimport {HelperManager} from \"./HelperManager\";\nimport identifyShadowedGlobals from \"./identifyShadowedGlobals\";\nimport NameManager from \"./NameManager\";\nimport {validateOptions} from \"./Options\";\n\nimport {parse} from \"./parser\";\n\nimport TokenProcessor from \"./TokenProcessor\";\nimport RootTransformer from \"./transformers/RootTransformer\";\nimport formatTokens from \"./util/formatTokens\";\nimport getTSImportedNames from \"./util/getTSImportedNames\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;\n\nexport function getVersion() {\n  /* istanbul ignore next */\n  return \"3.34.0\";\n}\n\nexport function transform(code, options) {\n  validateOptions(options);\n  try {\n    const sucraseContext = getSucraseContext(code, options);\n    const transformer = new RootTransformer(\n      sucraseContext,\n      options.transforms,\n      Boolean(options.enableLegacyBabel5ModuleInterop),\n      options,\n    );\n    const transformerResult = transformer.transform();\n    let result = {code: transformerResult.code};\n    if (options.sourceMapOptions) {\n      if (!options.filePath) {\n        throw new Error(\"filePath must be specified when generating a source map.\");\n      }\n      result = {\n        ...result,\n        sourceMap: computeSourceMap(\n          transformerResult,\n          options.filePath,\n          options.sourceMapOptions,\n          code,\n          sucraseContext.tokenProcessor.tokens,\n        ),\n      };\n    }\n    return result;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e) {\n    if (options.filePath) {\n      e.message = `Error transforming ${options.filePath}: ${e.message}`;\n    }\n    throw e;\n  }\n}\n\n/**\n * Return a string representation of the sucrase tokens, mostly useful for\n * diagnostic purposes.\n */\nexport function getFormattedTokens(code, options) {\n  const tokens = getSucraseContext(code, options).tokenProcessor.tokens;\n  return formatTokens(code, tokens);\n}\n\n/**\n * Call into the parser/tokenizer and do some further preprocessing:\n * - Come up with a set of used names so that we can assign new names.\n * - Preprocess all import/export statements so we know which globals we are interested in.\n * - Compute situations where any of those globals are shadowed.\n *\n * In the future, some of these preprocessing steps can be skipped based on what actual work is\n * being done.\n */\nfunction getSucraseContext(code, options) {\n  const isJSXEnabled = options.transforms.includes(\"jsx\");\n  const isTypeScriptEnabled = options.transforms.includes(\"typescript\");\n  const isFlowEnabled = options.transforms.includes(\"flow\");\n  const disableESTransforms = options.disableESTransforms === true;\n  const file = parse(code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);\n  const tokens = file.tokens;\n  const scopes = file.scopes;\n\n  const nameManager = new NameManager(code, tokens);\n  const helperManager = new HelperManager(nameManager);\n  const tokenProcessor = new TokenProcessor(\n    code,\n    tokens,\n    isFlowEnabled,\n    disableESTransforms,\n    helperManager,\n  );\n  const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);\n\n  let importProcessor = null;\n  if (options.transforms.includes(\"imports\")) {\n    importProcessor = new CJSImportProcessor(\n      nameManager,\n      tokenProcessor,\n      enableLegacyTypeScriptModuleInterop,\n      options,\n      options.transforms.includes(\"typescript\"),\n      Boolean(options.keepUnusedImports),\n      helperManager,\n    );\n    importProcessor.preprocessTokens();\n    // We need to mark shadowed globals after processing imports so we know that the globals are,\n    // but before type-only import pruning, since that relies on shadowing information.\n    identifyShadowedGlobals(tokenProcessor, scopes, importProcessor.getGlobalNames());\n    if (options.transforms.includes(\"typescript\") && !options.keepUnusedImports) {\n      importProcessor.pruneTypeOnlyImports();\n    }\n  } else if (options.transforms.includes(\"typescript\") && !options.keepUnusedImports) {\n    // Shadowed global detection is needed for TS implicit elision of imported names.\n    identifyShadowedGlobals(tokenProcessor, scopes, getTSImportedNames(tokenProcessor));\n  }\n  return {tokenProcessor, scopes, nameManager, importProcessor, helperManager};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}