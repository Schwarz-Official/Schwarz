{"ast":null,"code":"/**\n * @typedef {object} ScreenValue\n * @property {number|undefined} min\n * @property {number|undefined} max\n * @property {string|undefined} raw\n */ /**\n    * @typedef {object} Screen\n    * @property {string} name\n    * @property {boolean} not\n    * @property {ScreenValue[]} values\n    */ /**\n       * A function that normalizes the various forms that the screens object can be\n       * provided in.\n       *\n       * Input(s):\n       *   - ['100px', '200px'] // Raw strings\n       *   - { sm: '100px', md: '200px' } // Object with string values\n       *   - { sm: { min: '100px' }, md: { max: '100px' } } // Object with object values\n       *   - { sm: [{ min: '100px' }, { max: '200px' }] } // Object with object array (multiple values)\n       *\n       * Output(s):\n       *   - [{ name: 'sm', values: [{ min: '100px', max: '200px' }] }] // List of objects, that contains multiple values\n       *\n       * @returns {Screen[]}\n       */\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  normalizeScreens: function () {\n    return normalizeScreens;\n  },\n  isScreenSortable: function () {\n    return isScreenSortable;\n  },\n  compareScreens: function () {\n    return compareScreens;\n  },\n  toScreen: function () {\n    return toScreen;\n  }\n});\nfunction normalizeScreens(screens, root = true) {\n  if (Array.isArray(screens)) {\n    return screens.map(screen => {\n      if (root && Array.isArray(screen)) {\n        throw new Error(\"The tuple syntax is not supported for `screens`.\");\n      }\n      if (typeof screen === \"string\") {\n        return {\n          name: screen.toString(),\n          not: false,\n          values: [{\n            min: screen,\n            max: undefined\n          }]\n        };\n      }\n      let [name, options] = screen;\n      name = name.toString();\n      if (typeof options === \"string\") {\n        return {\n          name,\n          not: false,\n          values: [{\n            min: options,\n            max: undefined\n          }]\n        };\n      }\n      if (Array.isArray(options)) {\n        return {\n          name,\n          not: false,\n          values: options.map(option => resolveValue(option))\n        };\n      }\n      return {\n        name,\n        not: false,\n        values: [resolveValue(options)]\n      };\n    });\n  }\n  return normalizeScreens(Object.entries(screens !== null && screens !== void 0 ? screens : {}), false);\n}\nfunction isScreenSortable(screen) {\n  if (screen.values.length !== 1) {\n    return {\n      result: false,\n      reason: \"multiple-values\"\n    };\n  } else if (screen.values[0].raw !== undefined) {\n    return {\n      result: false,\n      reason: \"raw-values\"\n    };\n  } else if (screen.values[0].min !== undefined && screen.values[0].max !== undefined) {\n    return {\n      result: false,\n      reason: \"min-and-max\"\n    };\n  }\n  return {\n    result: true,\n    reason: null\n  };\n}\nfunction compareScreens(type, a, z) {\n  let aScreen = toScreen(a, type);\n  let zScreen = toScreen(z, type);\n  let aSorting = isScreenSortable(aScreen);\n  let bSorting = isScreenSortable(zScreen);\n  // These cases should never happen and indicate a bug in Tailwind CSS itself\n  if (aSorting.reason === \"multiple-values\" || bSorting.reason === \"multiple-values\") {\n    throw new Error(\"Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.\");\n  } else if (aSorting.reason === \"raw-values\" || bSorting.reason === \"raw-values\") {\n    throw new Error(\"Attempted to sort a screen with raw values. This should never happen. Please open a bug report.\");\n  } else if (aSorting.reason === \"min-and-max\" || bSorting.reason === \"min-and-max\") {\n    throw new Error(\"Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.\");\n  }\n  // Let the sorting begin\n  let {\n    min: aMin,\n    max: aMax\n  } = aScreen.values[0];\n  let {\n    min: zMin,\n    max: zMax\n  } = zScreen.values[0];\n  // Negating screens flip their behavior. Basically `not min-width` is `max-width`\n  if (a.not) [aMin, aMax] = [aMax, aMin];\n  if (z.not) [zMin, zMax] = [zMax, zMin];\n  aMin = aMin === undefined ? aMin : parseFloat(aMin);\n  aMax = aMax === undefined ? aMax : parseFloat(aMax);\n  zMin = zMin === undefined ? zMin : parseFloat(zMin);\n  zMax = zMax === undefined ? zMax : parseFloat(zMax);\n  let [aValue, zValue] = type === \"min\" ? [aMin, zMin] : [zMax, aMax];\n  return aValue - zValue;\n}\nfunction toScreen(value, type) {\n  if (typeof value === \"object\") {\n    return value;\n  }\n  return {\n    name: \"arbitrary-screen\",\n    values: [{\n      [type]: value\n    }]\n  };\n}\nfunction resolveValue({\n  \"min-width\": _minWidth,\n  min = _minWidth,\n  max,\n  raw\n} = {}) {\n  return {\n    min,\n    max,\n    raw\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","normalizeScreens","isScreenSortable","compareScreens","toScreen","screens","root","Array","isArray","map","screen","Error","toString","not","values","min","max","undefined","options","option","resolveValue","entries","length","result","reason","raw","type","a","z","aScreen","zScreen","aSorting","bSorting","aMin","aMax","zMin","zMax","parseFloat","aValue","zValue","_minWidth"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/util/normalizeScreens.js"],"sourcesContent":["/**\n * @typedef {object} ScreenValue\n * @property {number|undefined} min\n * @property {number|undefined} max\n * @property {string|undefined} raw\n */ /**\n * @typedef {object} Screen\n * @property {string} name\n * @property {boolean} not\n * @property {ScreenValue[]} values\n */ /**\n * A function that normalizes the various forms that the screens object can be\n * provided in.\n *\n * Input(s):\n *   - ['100px', '200px'] // Raw strings\n *   - { sm: '100px', md: '200px' } // Object with string values\n *   - { sm: { min: '100px' }, md: { max: '100px' } } // Object with object values\n *   - { sm: [{ min: '100px' }, { max: '200px' }] } // Object with object array (multiple values)\n *\n * Output(s):\n *   - [{ name: 'sm', values: [{ min: '100px', max: '200px' }] }] // List of objects, that contains multiple values\n *\n * @returns {Screen[]}\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    normalizeScreens: function() {\n        return normalizeScreens;\n    },\n    isScreenSortable: function() {\n        return isScreenSortable;\n    },\n    compareScreens: function() {\n        return compareScreens;\n    },\n    toScreen: function() {\n        return toScreen;\n    }\n});\nfunction normalizeScreens(screens, root = true) {\n    if (Array.isArray(screens)) {\n        return screens.map((screen)=>{\n            if (root && Array.isArray(screen)) {\n                throw new Error(\"The tuple syntax is not supported for `screens`.\");\n            }\n            if (typeof screen === \"string\") {\n                return {\n                    name: screen.toString(),\n                    not: false,\n                    values: [\n                        {\n                            min: screen,\n                            max: undefined\n                        }\n                    ]\n                };\n            }\n            let [name, options] = screen;\n            name = name.toString();\n            if (typeof options === \"string\") {\n                return {\n                    name,\n                    not: false,\n                    values: [\n                        {\n                            min: options,\n                            max: undefined\n                        }\n                    ]\n                };\n            }\n            if (Array.isArray(options)) {\n                return {\n                    name,\n                    not: false,\n                    values: options.map((option)=>resolveValue(option))\n                };\n            }\n            return {\n                name,\n                not: false,\n                values: [\n                    resolveValue(options)\n                ]\n            };\n        });\n    }\n    return normalizeScreens(Object.entries(screens !== null && screens !== void 0 ? screens : {}), false);\n}\nfunction isScreenSortable(screen) {\n    if (screen.values.length !== 1) {\n        return {\n            result: false,\n            reason: \"multiple-values\"\n        };\n    } else if (screen.values[0].raw !== undefined) {\n        return {\n            result: false,\n            reason: \"raw-values\"\n        };\n    } else if (screen.values[0].min !== undefined && screen.values[0].max !== undefined) {\n        return {\n            result: false,\n            reason: \"min-and-max\"\n        };\n    }\n    return {\n        result: true,\n        reason: null\n    };\n}\nfunction compareScreens(type, a, z) {\n    let aScreen = toScreen(a, type);\n    let zScreen = toScreen(z, type);\n    let aSorting = isScreenSortable(aScreen);\n    let bSorting = isScreenSortable(zScreen);\n    // These cases should never happen and indicate a bug in Tailwind CSS itself\n    if (aSorting.reason === \"multiple-values\" || bSorting.reason === \"multiple-values\") {\n        throw new Error(\"Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.\");\n    } else if (aSorting.reason === \"raw-values\" || bSorting.reason === \"raw-values\") {\n        throw new Error(\"Attempted to sort a screen with raw values. This should never happen. Please open a bug report.\");\n    } else if (aSorting.reason === \"min-and-max\" || bSorting.reason === \"min-and-max\") {\n        throw new Error(\"Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.\");\n    }\n    // Let the sorting begin\n    let { min: aMin , max: aMax  } = aScreen.values[0];\n    let { min: zMin , max: zMax  } = zScreen.values[0];\n    // Negating screens flip their behavior. Basically `not min-width` is `max-width`\n    if (a.not) [aMin, aMax] = [\n        aMax,\n        aMin\n    ];\n    if (z.not) [zMin, zMax] = [\n        zMax,\n        zMin\n    ];\n    aMin = aMin === undefined ? aMin : parseFloat(aMin);\n    aMax = aMax === undefined ? aMax : parseFloat(aMax);\n    zMin = zMin === undefined ? zMin : parseFloat(zMin);\n    zMax = zMax === undefined ? zMax : parseFloat(zMax);\n    let [aValue, zValue] = type === \"min\" ? [\n        aMin,\n        zMin\n    ] : [\n        zMax,\n        aMax\n    ];\n    return aValue - zValue;\n}\nfunction toScreen(value, type) {\n    if (typeof value === \"object\") {\n        return value;\n    }\n    return {\n        name: \"arbitrary-screen\",\n        values: [\n            {\n                [type]: value\n            }\n        ]\n    };\n}\nfunction resolveValue({ \"min-width\": _minWidth , min =_minWidth , max , raw  } = {}) {\n    return {\n        min,\n        max,\n        raw\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}