{"ast":null,"code":"import { ContextualKeyword } from \"../parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport getClassInfo from \"../util/getClassInfo\";\nimport CJSImportTransformer from \"./CJSImportTransformer\";\nimport ESMImportTransformer from \"./ESMImportTransformer\";\nimport FlowTransformer from \"./FlowTransformer\";\nimport JestHoistTransformer from \"./JestHoistTransformer\";\nimport JSXTransformer from \"./JSXTransformer\";\nimport NumericSeparatorTransformer from \"./NumericSeparatorTransformer\";\nimport OptionalCatchBindingTransformer from \"./OptionalCatchBindingTransformer\";\nimport OptionalChainingNullishTransformer from \"./OptionalChainingNullishTransformer\";\nimport ReactDisplayNameTransformer from \"./ReactDisplayNameTransformer\";\nimport ReactHotLoaderTransformer from \"./ReactHotLoaderTransformer\";\nimport TypeScriptTransformer from \"./TypeScriptTransformer\";\nexport default class RootTransformer {\n  __init() {\n    this.transformers = [];\n  }\n  __init2() {\n    this.generatedVariables = [];\n  }\n  constructor(sucraseContext, transforms, enableLegacyBabel5ModuleInterop, options) {\n    ;\n    RootTransformer.prototype.__init.call(this);\n    RootTransformer.prototype.__init2.call(this);\n    this.nameManager = sucraseContext.nameManager;\n    this.helperManager = sucraseContext.helperManager;\n    const {\n      tokenProcessor,\n      importProcessor\n    } = sucraseContext;\n    this.tokens = tokenProcessor;\n    this.isImportsTransformEnabled = transforms.includes(\"imports\");\n    this.isReactHotLoaderTransformEnabled = transforms.includes(\"react-hot-loader\");\n    this.disableESTransforms = Boolean(options.disableESTransforms);\n    if (!options.disableESTransforms) {\n      this.transformers.push(new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager));\n      this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));\n      this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));\n    }\n    if (transforms.includes(\"jsx\")) {\n      if (options.jsxRuntime !== \"preserve\") {\n        this.transformers.push(new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options));\n      }\n      this.transformers.push(new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options));\n    }\n    let reactHotLoaderTransformer = null;\n    if (transforms.includes(\"react-hot-loader\")) {\n      if (!options.filePath) {\n        throw new Error(\"filePath is required when using the react-hot-loader transform.\");\n      }\n      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);\n      this.transformers.push(reactHotLoaderTransformer);\n    }\n\n    // Note that we always want to enable the imports transformer, even when the import transform\n    // itself isn't enabled, since we need to do type-only import pruning for both Flow and\n    // TypeScript.\n    if (transforms.includes(\"imports\")) {\n      if (importProcessor === null) {\n        throw new Error(\"Expected non-null importProcessor with imports transform enabled.\");\n      }\n      this.transformers.push(new CJSImportTransformer(this, tokenProcessor, importProcessor, this.nameManager, this.helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, Boolean(options.enableLegacyTypeScriptModuleInterop), transforms.includes(\"typescript\"), transforms.includes(\"flow\"), Boolean(options.preserveDynamicImport), Boolean(options.keepUnusedImports)));\n    } else {\n      this.transformers.push(new ESMImportTransformer(tokenProcessor, this.nameManager, this.helperManager, reactHotLoaderTransformer, transforms.includes(\"typescript\"), transforms.includes(\"flow\"), Boolean(options.keepUnusedImports), options));\n    }\n    if (transforms.includes(\"flow\")) {\n      this.transformers.push(new FlowTransformer(this, tokenProcessor, transforms.includes(\"imports\")));\n    }\n    if (transforms.includes(\"typescript\")) {\n      this.transformers.push(new TypeScriptTransformer(this, tokenProcessor, transforms.includes(\"imports\")));\n    }\n    if (transforms.includes(\"jest\")) {\n      this.transformers.push(new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor));\n    }\n  }\n  transform() {\n    this.tokens.reset();\n    this.processBalancedCode();\n    const shouldAddUseStrict = this.isImportsTransformEnabled;\n    // \"use strict\" always needs to be first, so override the normal transformer order.\n    let prefix = shouldAddUseStrict ? '\"use strict\";' : \"\";\n    for (const transformer of this.transformers) {\n      prefix += transformer.getPrefixCode();\n    }\n    prefix += this.helperManager.emitHelpers();\n    prefix += this.generatedVariables.map(v => ` var ${v};`).join(\"\");\n    for (const transformer of this.transformers) {\n      prefix += transformer.getHoistedCode();\n    }\n    let suffix = \"\";\n    for (const transformer of this.transformers) {\n      suffix += transformer.getSuffixCode();\n    }\n    const result = this.tokens.finish();\n    let {\n      code\n    } = result;\n    if (code.startsWith(\"#!\")) {\n      let newlineIndex = code.indexOf(\"\\n\");\n      if (newlineIndex === -1) {\n        newlineIndex = code.length;\n        code += \"\\n\";\n      }\n      return {\n        code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,\n        // The hashbang line has no tokens, so shifting the tokens to account\n        // for prefix can happen normally.\n        mappings: this.shiftMappings(result.mappings, prefix.length)\n      };\n    } else {\n      return {\n        code: prefix + code + suffix,\n        mappings: this.shiftMappings(result.mappings, prefix.length)\n      };\n    }\n  }\n  processBalancedCode() {\n    let braceDepth = 0;\n    let parenDepth = 0;\n    while (!this.tokens.isAtEnd()) {\n      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL)) {\n        braceDepth++;\n      } else if (this.tokens.matches1(tt.braceR)) {\n        if (braceDepth === 0) {\n          return;\n        }\n        braceDepth--;\n      }\n      if (this.tokens.matches1(tt.parenL)) {\n        parenDepth++;\n      } else if (this.tokens.matches1(tt.parenR)) {\n        if (parenDepth === 0) {\n          return;\n        }\n        parenDepth--;\n      }\n      this.processToken();\n    }\n  }\n  processToken() {\n    if (this.tokens.matches1(tt._class)) {\n      this.processClass();\n      return;\n    }\n    for (const transformer of this.transformers) {\n      const wasProcessed = transformer.process();\n      if (wasProcessed) {\n        return;\n      }\n    }\n    this.tokens.copyToken();\n  }\n\n  /**\n   * Skip past a class with a name and return that name.\n   */\n  processNamedClass() {\n    if (!this.tokens.matches2(tt._class, tt.name)) {\n      throw new Error(\"Expected identifier for exported class name.\");\n    }\n    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    this.processClass();\n    return name;\n  }\n  processClass() {\n    const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);\n\n    // Both static and instance initializers need a class name to use to invoke the initializer, so\n    // assign to one if necessary.\n    const needsCommaExpression = (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) && classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;\n    let className = classInfo.headerInfo.className;\n    if (needsCommaExpression) {\n      className = this.nameManager.claimFreeName(\"_class\");\n      this.generatedVariables.push(className);\n      this.tokens.appendCode(` (${className} =`);\n    }\n    const classToken = this.tokens.currentToken();\n    const contextId = classToken.contextId;\n    if (contextId == null) {\n      throw new Error(\"Expected class to have a context ID.\");\n    }\n    this.tokens.copyExpectedToken(tt._class);\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n      this.processToken();\n    }\n    this.processClassBody(classInfo, className);\n    const staticInitializerStatements = classInfo.staticInitializerNames.map(name => `${className}.${name}()`);\n    if (needsCommaExpression) {\n      this.tokens.appendCode(`, ${staticInitializerStatements.map(s => `${s}, `).join(\"\")}${className})`);\n    } else if (classInfo.staticInitializerNames.length > 0) {\n      this.tokens.appendCode(` ${staticInitializerStatements.map(s => `${s};`).join(\" \")}`);\n    }\n  }\n\n  /**\n   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,\n   * when some JS implementations support class fields, this should be made optional.\n   */\n  processClassBody(classInfo, className) {\n    const {\n      headerInfo,\n      constructorInsertPos,\n      constructorInitializerStatements,\n      fields,\n      instanceInitializerNames,\n      rangesToRemove\n    } = classInfo;\n    let fieldIndex = 0;\n    let rangeToRemoveIndex = 0;\n    const classContextId = this.tokens.currentToken().contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected non-null context ID on class.\");\n    }\n    this.tokens.copyExpectedToken(tt.braceL);\n    if (this.isReactHotLoaderTransformEnabled) {\n      this.tokens.appendCode(\"__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}\");\n    }\n    const needsConstructorInit = constructorInitializerStatements.length + instanceInitializerNames.length > 0;\n    if (constructorInsertPos === null && needsConstructorInit) {\n      const constructorInitializersCode = this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className);\n      if (headerInfo.hasSuperclass) {\n        const argsName = this.nameManager.claimFreeName(\"args\");\n        this.tokens.appendCode(`constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`);\n      } else {\n        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);\n      }\n    }\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {\n        let needsCloseBrace = false;\n        if (this.tokens.matches1(tt.bracketL)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);\n        } else if (this.tokens.matches1(tt.string) || this.tokens.matches1(tt.num)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);\n          needsCloseBrace = true;\n        } else {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);\n        }\n        while (this.tokens.currentIndex() < fields[fieldIndex].end) {\n          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {\n            this.tokens.appendCode(\"]\");\n          }\n          this.processToken();\n        }\n        this.tokens.appendCode(\"}\");\n        fieldIndex++;\n      } else if (rangeToRemoveIndex < rangesToRemove.length && this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start) {\n        if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {\n          this.tokens.removeInitialToken();\n        }\n        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {\n          this.tokens.removeToken();\n        }\n        rangeToRemoveIndex++;\n      } else if (this.tokens.currentIndex() === constructorInsertPos) {\n        this.tokens.copyToken();\n        if (needsConstructorInit) {\n          this.tokens.appendCode(`;${this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className)};`);\n        }\n        this.processToken();\n      } else {\n        this.processToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n  }\n  makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className) {\n    return [...constructorInitializerStatements, ...instanceInitializerNames.map(name => `${className}.prototype.${name}.call(this)`)].join(\";\");\n  }\n\n  /**\n   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with\n   * arrow function return types since they can confuse the parser. In that case, we want to move\n   * the close-paren to the same line as the arrow.\n   *\n   * See https://github.com/alangpierce/sucrase/issues/391 for more details.\n   */\n  processPossibleArrowParamEnd() {\n    if (this.tokens.matches2(tt.parenR, tt.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {\n      let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n      // Look ahead to see if this is an arrow function or something else.\n      while (this.tokens.tokens[nextNonTypeIndex].isType) {\n        nextNonTypeIndex++;\n      }\n      if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.arrow)) {\n        this.tokens.removeInitialToken();\n        while (this.tokens.currentIndex() < nextNonTypeIndex) {\n          this.tokens.removeToken();\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\") =>\");\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * An async arrow function might be of the form:\n   *\n   * async <\n   *   T\n   * >() => {}\n   *\n   * in which case, removing the type parameters will cause a syntax error. Detect this case and\n   * move the open-paren earlier.\n   */\n  processPossibleAsyncArrowWithTypeParams() {\n    if (!this.tokens.matchesContextual(ContextualKeyword._async) && !this.tokens.matches1(tt._async)) {\n      return false;\n    }\n    const nextToken = this.tokens.tokenAtRelativeIndex(1);\n    if (nextToken.type !== tt.lessThan || !nextToken.isType) {\n      return false;\n    }\n    let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n    // Look ahead to see if this is an arrow function or something else.\n    while (this.tokens.tokens[nextNonTypeIndex].isType) {\n      nextNonTypeIndex++;\n    }\n    if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.parenL)) {\n      this.tokens.replaceToken(\"async (\");\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentIndex() < nextNonTypeIndex) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      // We ate a ( token, so we need to process the tokens in between and then the ) token so that\n      // we remain balanced.\n      this.processBalancedCode();\n      this.processToken();\n      return true;\n    }\n    return false;\n  }\n  processPossibleTypeRange() {\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    return false;\n  }\n  shiftMappings(mappings, prefixLength) {\n    for (let i = 0; i < mappings.length; i++) {\n      const mapping = mappings[i];\n      if (mapping !== undefined) {\n        mappings[i] = mapping + prefixLength;\n      }\n    }\n    return mappings;\n  }\n}","map":{"version":3,"names":["ContextualKeyword","TokenType","tt","getClassInfo","CJSImportTransformer","ESMImportTransformer","FlowTransformer","JestHoistTransformer","JSXTransformer","NumericSeparatorTransformer","OptionalCatchBindingTransformer","OptionalChainingNullishTransformer","ReactDisplayNameTransformer","ReactHotLoaderTransformer","TypeScriptTransformer","RootTransformer","__init","transformers","__init2","generatedVariables","constructor","sucraseContext","transforms","enableLegacyBabel5ModuleInterop","options","prototype","call","nameManager","helperManager","tokenProcessor","importProcessor","tokens","isImportsTransformEnabled","includes","isReactHotLoaderTransformEnabled","disableESTransforms","Boolean","push","jsxRuntime","reactHotLoaderTransformer","filePath","Error","enableLegacyTypeScriptModuleInterop","preserveDynamicImport","keepUnusedImports","transform","reset","processBalancedCode","shouldAddUseStrict","prefix","transformer","getPrefixCode","emitHelpers","map","v","join","getHoistedCode","suffix","getSuffixCode","result","finish","code","startsWith","newlineIndex","indexOf","length","slice","mappings","shiftMappings","braceDepth","parenDepth","isAtEnd","matches1","braceL","dollarBraceL","braceR","parenL","parenR","processToken","_class","processClass","wasProcessed","process","copyToken","processNamedClass","matches2","name","identifierNameAtIndex","currentIndex","classInfo","needsCommaExpression","headerInfo","isExpression","className","staticInitializerNames","instanceInitializerNames","claimFreeName","appendCode","classToken","currentToken","contextId","copyExpectedToken","matchesContextIdAndLabel","processClassBody","staticInitializerStatements","s","constructorInsertPos","constructorInitializerStatements","fields","rangesToRemove","fieldIndex","rangeToRemoveIndex","classContextId","needsConstructorInit","constructorInitializersCode","makeConstructorInitCode","hasSuperclass","argsName","start","needsCloseBrace","bracketL","copyTokenWithPrefix","initializerName","string","num","end","equalsIndex","removeInitialToken","removeToken","processPossibleArrowParamEnd","colon","tokenAtRelativeIndex","isType","nextNonTypeIndex","matches1AtIndex","arrow","replaceTokenTrimmingLeftWhitespace","processPossibleAsyncArrowWithTypeParams","matchesContextual","_async","nextToken","type","lessThan","replaceToken","processPossibleTypeRange","prefixLength","i","mapping","undefined"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/RootTransformer.js"],"sourcesContent":["\n\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport getClassInfo, {} from \"../util/getClassInfo\";\nimport CJSImportTransformer from \"./CJSImportTransformer\";\nimport ESMImportTransformer from \"./ESMImportTransformer\";\nimport FlowTransformer from \"./FlowTransformer\";\nimport JestHoistTransformer from \"./JestHoistTransformer\";\nimport JSXTransformer from \"./JSXTransformer\";\nimport NumericSeparatorTransformer from \"./NumericSeparatorTransformer\";\nimport OptionalCatchBindingTransformer from \"./OptionalCatchBindingTransformer\";\nimport OptionalChainingNullishTransformer from \"./OptionalChainingNullishTransformer\";\nimport ReactDisplayNameTransformer from \"./ReactDisplayNameTransformer\";\nimport ReactHotLoaderTransformer from \"./ReactHotLoaderTransformer\";\n\nimport TypeScriptTransformer from \"./TypeScriptTransformer\";\n\n\n\n\n\n\n\n\nexport default class RootTransformer {\n   __init() {this.transformers = []}\n  \n  \n   __init2() {this.generatedVariables = []}\n  \n  \n  \n  \n\n  constructor(\n    sucraseContext,\n    transforms,\n    enableLegacyBabel5ModuleInterop,\n    options,\n  ) {;RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);\n    this.nameManager = sucraseContext.nameManager;\n    this.helperManager = sucraseContext.helperManager;\n    const {tokenProcessor, importProcessor} = sucraseContext;\n    this.tokens = tokenProcessor;\n    this.isImportsTransformEnabled = transforms.includes(\"imports\");\n    this.isReactHotLoaderTransformEnabled = transforms.includes(\"react-hot-loader\");\n    this.disableESTransforms = Boolean(options.disableESTransforms);\n\n    if (!options.disableESTransforms) {\n      this.transformers.push(\n        new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager),\n      );\n      this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));\n      this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));\n    }\n\n    if (transforms.includes(\"jsx\")) {\n      if (options.jsxRuntime !== \"preserve\") {\n        this.transformers.push(\n          new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options),\n        );\n      }\n      this.transformers.push(\n        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options),\n      );\n    }\n\n    let reactHotLoaderTransformer = null;\n    if (transforms.includes(\"react-hot-loader\")) {\n      if (!options.filePath) {\n        throw new Error(\"filePath is required when using the react-hot-loader transform.\");\n      }\n      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);\n      this.transformers.push(reactHotLoaderTransformer);\n    }\n\n    // Note that we always want to enable the imports transformer, even when the import transform\n    // itself isn't enabled, since we need to do type-only import pruning for both Flow and\n    // TypeScript.\n    if (transforms.includes(\"imports\")) {\n      if (importProcessor === null) {\n        throw new Error(\"Expected non-null importProcessor with imports transform enabled.\");\n      }\n      this.transformers.push(\n        new CJSImportTransformer(\n          this,\n          tokenProcessor,\n          importProcessor,\n          this.nameManager,\n          this.helperManager,\n          reactHotLoaderTransformer,\n          enableLegacyBabel5ModuleInterop,\n          Boolean(options.enableLegacyTypeScriptModuleInterop),\n          transforms.includes(\"typescript\"),\n          transforms.includes(\"flow\"),\n          Boolean(options.preserveDynamicImport),\n          Boolean(options.keepUnusedImports),\n        ),\n      );\n    } else {\n      this.transformers.push(\n        new ESMImportTransformer(\n          tokenProcessor,\n          this.nameManager,\n          this.helperManager,\n          reactHotLoaderTransformer,\n          transforms.includes(\"typescript\"),\n          transforms.includes(\"flow\"),\n          Boolean(options.keepUnusedImports),\n          options,\n        ),\n      );\n    }\n\n    if (transforms.includes(\"flow\")) {\n      this.transformers.push(\n        new FlowTransformer(this, tokenProcessor, transforms.includes(\"imports\")),\n      );\n    }\n    if (transforms.includes(\"typescript\")) {\n      this.transformers.push(\n        new TypeScriptTransformer(this, tokenProcessor, transforms.includes(\"imports\")),\n      );\n    }\n    if (transforms.includes(\"jest\")) {\n      this.transformers.push(\n        new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor),\n      );\n    }\n  }\n\n  transform() {\n    this.tokens.reset();\n    this.processBalancedCode();\n    const shouldAddUseStrict = this.isImportsTransformEnabled;\n    // \"use strict\" always needs to be first, so override the normal transformer order.\n    let prefix = shouldAddUseStrict ? '\"use strict\";' : \"\";\n    for (const transformer of this.transformers) {\n      prefix += transformer.getPrefixCode();\n    }\n    prefix += this.helperManager.emitHelpers();\n    prefix += this.generatedVariables.map((v) => ` var ${v};`).join(\"\");\n    for (const transformer of this.transformers) {\n      prefix += transformer.getHoistedCode();\n    }\n    let suffix = \"\";\n    for (const transformer of this.transformers) {\n      suffix += transformer.getSuffixCode();\n    }\n    const result = this.tokens.finish();\n    let {code} = result;\n    if (code.startsWith(\"#!\")) {\n      let newlineIndex = code.indexOf(\"\\n\");\n      if (newlineIndex === -1) {\n        newlineIndex = code.length;\n        code += \"\\n\";\n      }\n      return {\n        code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,\n        // The hashbang line has no tokens, so shifting the tokens to account\n        // for prefix can happen normally.\n        mappings: this.shiftMappings(result.mappings, prefix.length),\n      };\n    } else {\n      return {\n        code: prefix + code + suffix,\n        mappings: this.shiftMappings(result.mappings, prefix.length),\n      };\n    }\n  }\n\n  processBalancedCode() {\n    let braceDepth = 0;\n    let parenDepth = 0;\n    while (!this.tokens.isAtEnd()) {\n      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL)) {\n        braceDepth++;\n      } else if (this.tokens.matches1(tt.braceR)) {\n        if (braceDepth === 0) {\n          return;\n        }\n        braceDepth--;\n      }\n      if (this.tokens.matches1(tt.parenL)) {\n        parenDepth++;\n      } else if (this.tokens.matches1(tt.parenR)) {\n        if (parenDepth === 0) {\n          return;\n        }\n        parenDepth--;\n      }\n      this.processToken();\n    }\n  }\n\n  processToken() {\n    if (this.tokens.matches1(tt._class)) {\n      this.processClass();\n      return;\n    }\n    for (const transformer of this.transformers) {\n      const wasProcessed = transformer.process();\n      if (wasProcessed) {\n        return;\n      }\n    }\n    this.tokens.copyToken();\n  }\n\n  /**\n   * Skip past a class with a name and return that name.\n   */\n  processNamedClass() {\n    if (!this.tokens.matches2(tt._class, tt.name)) {\n      throw new Error(\"Expected identifier for exported class name.\");\n    }\n    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    this.processClass();\n    return name;\n  }\n\n  processClass() {\n    const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);\n\n    // Both static and instance initializers need a class name to use to invoke the initializer, so\n    // assign to one if necessary.\n    const needsCommaExpression =\n      (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) &&\n      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;\n\n    let className = classInfo.headerInfo.className;\n    if (needsCommaExpression) {\n      className = this.nameManager.claimFreeName(\"_class\");\n      this.generatedVariables.push(className);\n      this.tokens.appendCode(` (${className} =`);\n    }\n\n    const classToken = this.tokens.currentToken();\n    const contextId = classToken.contextId;\n    if (contextId == null) {\n      throw new Error(\"Expected class to have a context ID.\");\n    }\n    this.tokens.copyExpectedToken(tt._class);\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n      this.processToken();\n    }\n\n    this.processClassBody(classInfo, className);\n\n    const staticInitializerStatements = classInfo.staticInitializerNames.map(\n      (name) => `${className}.${name}()`,\n    );\n    if (needsCommaExpression) {\n      this.tokens.appendCode(\n        `, ${staticInitializerStatements.map((s) => `${s}, `).join(\"\")}${className})`,\n      );\n    } else if (classInfo.staticInitializerNames.length > 0) {\n      this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(\" \")}`);\n    }\n  }\n\n  /**\n   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,\n   * when some JS implementations support class fields, this should be made optional.\n   */\n  processClassBody(classInfo, className) {\n    const {\n      headerInfo,\n      constructorInsertPos,\n      constructorInitializerStatements,\n      fields,\n      instanceInitializerNames,\n      rangesToRemove,\n    } = classInfo;\n    let fieldIndex = 0;\n    let rangeToRemoveIndex = 0;\n    const classContextId = this.tokens.currentToken().contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected non-null context ID on class.\");\n    }\n    this.tokens.copyExpectedToken(tt.braceL);\n    if (this.isReactHotLoaderTransformEnabled) {\n      this.tokens.appendCode(\n        \"__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}\",\n      );\n    }\n\n    const needsConstructorInit =\n      constructorInitializerStatements.length + instanceInitializerNames.length > 0;\n\n    if (constructorInsertPos === null && needsConstructorInit) {\n      const constructorInitializersCode = this.makeConstructorInitCode(\n        constructorInitializerStatements,\n        instanceInitializerNames,\n        className,\n      );\n      if (headerInfo.hasSuperclass) {\n        const argsName = this.nameManager.claimFreeName(\"args\");\n        this.tokens.appendCode(\n          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`,\n        );\n      } else {\n        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);\n      }\n    }\n\n    while (!this.tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {\n        let needsCloseBrace = false;\n        if (this.tokens.matches1(tt.bracketL)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);\n        } else if (this.tokens.matches1(tt.string) || this.tokens.matches1(tt.num)) {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);\n          needsCloseBrace = true;\n        } else {\n          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);\n        }\n        while (this.tokens.currentIndex() < fields[fieldIndex].end) {\n          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {\n            this.tokens.appendCode(\"]\");\n          }\n          this.processToken();\n        }\n        this.tokens.appendCode(\"}\");\n        fieldIndex++;\n      } else if (\n        rangeToRemoveIndex < rangesToRemove.length &&\n        this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start\n      ) {\n        if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {\n          this.tokens.removeInitialToken();\n        }\n        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {\n          this.tokens.removeToken();\n        }\n        rangeToRemoveIndex++;\n      } else if (this.tokens.currentIndex() === constructorInsertPos) {\n        this.tokens.copyToken();\n        if (needsConstructorInit) {\n          this.tokens.appendCode(\n            `;${this.makeConstructorInitCode(\n              constructorInitializerStatements,\n              instanceInitializerNames,\n              className,\n            )};`,\n          );\n        }\n        this.processToken();\n      } else {\n        this.processToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n  }\n\n  makeConstructorInitCode(\n    constructorInitializerStatements,\n    instanceInitializerNames,\n    className,\n  ) {\n    return [\n      ...constructorInitializerStatements,\n      ...instanceInitializerNames.map((name) => `${className}.prototype.${name}.call(this)`),\n    ].join(\";\");\n  }\n\n  /**\n   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with\n   * arrow function return types since they can confuse the parser. In that case, we want to move\n   * the close-paren to the same line as the arrow.\n   *\n   * See https://github.com/alangpierce/sucrase/issues/391 for more details.\n   */\n  processPossibleArrowParamEnd() {\n    if (this.tokens.matches2(tt.parenR, tt.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {\n      let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n      // Look ahead to see if this is an arrow function or something else.\n      while (this.tokens.tokens[nextNonTypeIndex].isType) {\n        nextNonTypeIndex++;\n      }\n      if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.arrow)) {\n        this.tokens.removeInitialToken();\n        while (this.tokens.currentIndex() < nextNonTypeIndex) {\n          this.tokens.removeToken();\n        }\n        this.tokens.replaceTokenTrimmingLeftWhitespace(\") =>\");\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * An async arrow function might be of the form:\n   *\n   * async <\n   *   T\n   * >() => {}\n   *\n   * in which case, removing the type parameters will cause a syntax error. Detect this case and\n   * move the open-paren earlier.\n   */\n  processPossibleAsyncArrowWithTypeParams() {\n    if (\n      !this.tokens.matchesContextual(ContextualKeyword._async) &&\n      !this.tokens.matches1(tt._async)\n    ) {\n      return false;\n    }\n    const nextToken = this.tokens.tokenAtRelativeIndex(1);\n    if (nextToken.type !== tt.lessThan || !nextToken.isType) {\n      return false;\n    }\n\n    let nextNonTypeIndex = this.tokens.currentIndex() + 1;\n    // Look ahead to see if this is an arrow function or something else.\n    while (this.tokens.tokens[nextNonTypeIndex].isType) {\n      nextNonTypeIndex++;\n    }\n    if (this.tokens.matches1AtIndex(nextNonTypeIndex, tt.parenL)) {\n      this.tokens.replaceToken(\"async (\");\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentIndex() < nextNonTypeIndex) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      // We ate a ( token, so we need to process the tokens in between and then the ) token so that\n      // we remain balanced.\n      this.processBalancedCode();\n      this.processToken();\n      return true;\n    }\n    return false;\n  }\n\n  processPossibleTypeRange() {\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  shiftMappings(\n    mappings,\n    prefixLength,\n  ) {\n    for (let i = 0; i < mappings.length; i++) {\n      const mapping = mappings[i];\n      if (mapping !== undefined) {\n        mappings[i] = mapping + prefixLength;\n      }\n    }\n    return mappings;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}