{"ast":null,"code":"import { ContextualKeyword } from \"../parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, { EMPTY_DECLARATION_INFO } from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport { getNonTypeIdentifiers } from \"../util/getNonTypeIdentifiers\";\nimport isExportFrom from \"../util/isExportFrom\";\nimport { removeMaybeImportAttributes } from \"../util/removeMaybeImportAttributes\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are keeping the code as ESM. We still need to remove\n * type-only imports in TypeScript and Flow.\n */\nexport default class ESMImportTransformer extends Transformer {\n  constructor(tokens, nameManager, helperManager, reactHotLoaderTransformer, isTypeScriptTransformEnabled, isFlowTransformEnabled, keepUnusedImports, options) {\n    super();\n    this.tokens = tokens;\n    this.nameManager = nameManager;\n    this.helperManager = helperManager;\n    this.reactHotLoaderTransformer = reactHotLoaderTransformer;\n    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;\n    this.isFlowTransformEnabled = isFlowTransformEnabled;\n    this.keepUnusedImports = keepUnusedImports;\n    ;\n    this.nonTypeIdentifiers = isTypeScriptTransformEnabled && !keepUnusedImports ? getNonTypeIdentifiers(tokens, options) : new Set();\n    this.declarationInfo = isTypeScriptTransformEnabled && !keepUnusedImports ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;\n    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);\n  }\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {\n      // import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.\n      for (let i = 0; i < 7; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)) {\n      // export import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.\n      for (let i = 0; i < 8; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._import)) {\n      return this.processImport();\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      return this.processExportDefault();\n    }\n    if (this.tokens.matches2(tt._export, tt.braceL)) {\n      return this.processNamedExports();\n    }\n    if (this.tokens.matches2(tt._export, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAttributes(this.tokens);\n      }\n      return true;\n    }\n    return false;\n  }\n  processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.shouldAutomaticallyElideImportedName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else if (this.injectCreateRequireForImportRequire) {\n      // We're using require in an environment (Node ESM) that doesn't provide\n      // it as a global, so generate a helper to import it.\n      // import -> const\n      this.tokens.replaceToken(\"const\");\n      // Foo\n      this.tokens.copyToken();\n      // =\n      this.tokens.copyToken();\n      // require\n      this.tokens.replaceToken(this.helperManager.getHelperName(\"require\"));\n    } else {\n      // Otherwise, just switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n  processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      // Dynamic imports don't need to be transformed.\n      return false;\n    }\n    const snapshot = this.tokens.snapshot();\n    const allImportsRemoved = this.removeImportTypeBindings();\n    if (allImportsRemoved) {\n      this.tokens.restoreToSnapshot(snapshot);\n      while (!this.tokens.matches1(tt.string)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      removeMaybeImportAttributes(this.tokens);\n      if (this.tokens.matches1(tt.semi)) {\n        this.tokens.removeToken();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove type bindings from this import, leaving the rest of the import intact.\n   *\n   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out\n   * of the replacement operation, so we can return early here.\n   */\n  removeImportTypeBindings() {\n    this.tokens.copyExpectedToken(tt._import);\n    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {\n      // This is an \"import type\" statement, so exit early.\n      return true;\n    }\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      this.tokens.copyToken();\n      return false;\n    }\n\n    // Skip the \"module\" token in import reflection.\n    if (this.tokens.matchesContextual(ContextualKeyword._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)) {\n      this.tokens.copyToken();\n    }\n    let foundNonTypeImport = false;\n    let foundAnyNamedImport = false;\n    let needsComma = false;\n\n    // Handle default import.\n    if (this.tokens.matches1(tt.name)) {\n      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyToken();\n        if (this.tokens.matches1(tt.comma)) {\n          // We're in a statement like:\n          // import A, * as B from './A';\n          // or\n          // import A, {foo} from './A';\n          // where the `A` is being kept. The comma should be removed if an only\n          // if the next part of the import statement is elided, but that's hard\n          // to determine at this point in the code. Instead, always remove it\n          // and set a flag to add it back if necessary.\n          needsComma = true;\n          this.tokens.removeToken();\n        }\n      }\n    }\n    if (this.tokens.matches1(tt.star)) {\n      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      } else {\n        if (needsComma) {\n          this.tokens.appendCode(\",\");\n        }\n        foundNonTypeImport = true;\n        this.tokens.copyExpectedToken(tt.star);\n        this.tokens.copyExpectedToken(tt.name);\n        this.tokens.copyExpectedToken(tt.name);\n      }\n    } else if (this.tokens.matches1(tt.braceL)) {\n      if (needsComma) {\n        this.tokens.appendCode(\",\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        foundAnyNamedImport = true;\n        const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n        if (specifierInfo.isType || this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)) {\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.removeToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else {\n          foundNonTypeImport = true;\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.copyToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.copyToken();\n          }\n        }\n      }\n      this.tokens.copyExpectedToken(tt.braceR);\n    }\n    if (this.keepUnusedImports) {\n      return false;\n    }\n    if (this.isTypeScriptTransformEnabled) {\n      return !foundNonTypeImport;\n    } else if (this.isFlowTransformEnabled) {\n      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.\n      return foundAnyNamedImport && !foundNonTypeImport;\n    } else {\n      return false;\n    }\n  }\n  shouldAutomaticallyElideImportedName(name) {\n    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);\n  }\n  processExportDefault() {\n    if (shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      return true;\n    }\n    const alreadyHasName = this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n    // export default async function\n    this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._async) || this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) || this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name);\n    if (!alreadyHasName && this.reactHotLoaderTransformer) {\n      // This is a plain \"export default E\" statement and we need to assign E to a variable.\n      // Change \"export default E\" to \"let _default; export default _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; export`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a statement with one of these forms:\n   * export {a, type b};\n   * export {c, type d} from 'foo';\n   *\n   * In both cases, any explicit type exports should be removed. In the first\n   * case, we also need to handle implicit export elision for names declared as\n   * types. In the second case, we must NOT do implicit named export elision,\n   * but we must remove the runtime import if all exports are type exports.\n   */\n  processNamedExports() {\n    if (!this.isTypeScriptTransformEnabled) {\n      return false;\n    }\n    this.tokens.copyExpectedToken(tt._export);\n    this.tokens.copyExpectedToken(tt.braceL);\n    const isReExport = isExportFrom(this.tokens);\n    let foundNonTypeExport = false;\n    while (!this.tokens.matches1(tt.braceR)) {\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n      if (specifierInfo.isType || !isReExport && this.shouldElideExportedName(specifierInfo.leftName)) {\n        // Type export, so remove all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.removeToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        // Non-type export, so copy all tokens, including any comma.\n        foundNonTypeExport = true;\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.copyToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n    if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {\n      // This is a type-only re-export, so skip evaluating the other module. Technically this\n      // leaves the statement as `export {}`, but that's ok since that's a no-op.\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      removeMaybeImportAttributes(this.tokens);\n    }\n    return true;\n  }\n\n  /**\n   * ESM elides all imports with the rule that we only elide if we see that it's\n   * a type and never see it as a value. This is in contrast to CJS, which\n   * elides imports that are completely unknown.\n   */\n  shouldElideExportedName(name) {\n    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(name) && !this.declarationInfo.valueDeclarations.has(name);\n  }\n}","map":{"version":3,"names":["ContextualKeyword","TokenType","tt","elideImportEquals","getDeclarationInfo","EMPTY_DECLARATION_INFO","getImportExportSpecifierInfo","getNonTypeIdentifiers","isExportFrom","removeMaybeImportAttributes","shouldElideDefaultExport","Transformer","ESMImportTransformer","constructor","tokens","nameManager","helperManager","reactHotLoaderTransformer","isTypeScriptTransformEnabled","isFlowTransformEnabled","keepUnusedImports","options","nonTypeIdentifiers","Set","declarationInfo","injectCreateRequireForImportRequire","Boolean","process","matches3","_import","name","eq","processImportEquals","matches4","matchesContextualAtIndex","currentIndex","_type","removeInitialToken","i","removeToken","matches2","_export","replaceToken","matches5","matches1","processImport","_default","processExportDefault","braceL","processNamedExports","braceR","_as","matchesContextual","_from","matches1AtIndex","string","importName","identifierNameAtIndex","shouldAutomaticallyElideImportedName","copyToken","getHelperName","parenL","snapshot","allImportsRemoved","removeImportTypeBindings","restoreToSnapshot","semi","copyExpectedToken","comma","_module","foundNonTypeImport","foundAnyNamedImport","needsComma","identifierName","star","identifierNameAtRelativeIndex","appendCode","specifierInfo","isType","rightName","endIndex","has","alreadyHasName","_function","_async","_class","_abstract","defaultVarName","claimFreeName","setExtractedDefaultExportName","isReExport","foundNonTypeExport","shouldElideExportedName","leftName","typeDeclarations","valueDeclarations"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/ESMImportTransformer.js"],"sourcesContent":["\n\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport {getNonTypeIdentifiers} from \"../util/getNonTypeIdentifiers\";\nimport isExportFrom from \"../util/isExportFrom\";\nimport {removeMaybeImportAttributes} from \"../util/removeMaybeImportAttributes\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are keeping the code as ESM. We still need to remove\n * type-only imports in TypeScript and Flow.\n */\nexport default class ESMImportTransformer extends Transformer {\n  \n  \n  \n\n  constructor(\n     tokens,\n     nameManager,\n     helperManager,\n     reactHotLoaderTransformer,\n     isTypeScriptTransformEnabled,\n     isFlowTransformEnabled,\n     keepUnusedImports,\n    options,\n  ) {\n    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;\n    this.nonTypeIdentifiers =\n      isTypeScriptTransformEnabled && !keepUnusedImports\n        ? getNonTypeIdentifiers(tokens, options)\n        : new Set();\n    this.declarationInfo =\n      isTypeScriptTransformEnabled && !keepUnusedImports\n        ? getDeclarationInfo(tokens)\n        : EMPTY_DECLARATION_INFO;\n    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (\n      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.\n      for (let i = 0; i < 7; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (\n      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)\n    ) {\n      // export import type T = require('T')\n      this.tokens.removeInitialToken();\n      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.\n      for (let i = 0; i < 8; i++) {\n        this.tokens.removeToken();\n      }\n      return true;\n    }\n    if (this.tokens.matches1(tt._import)) {\n      return this.processImport();\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      return this.processExportDefault();\n    }\n    if (this.tokens.matches2(tt._export, tt.braceL)) {\n      return this.processNamedExports();\n    }\n    if (\n      this.tokens.matches2(tt._export, tt.name) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAttributes(this.tokens);\n      }\n      return true;\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.shouldAutomaticallyElideImportedName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else if (this.injectCreateRequireForImportRequire) {\n      // We're using require in an environment (Node ESM) that doesn't provide\n      // it as a global, so generate a helper to import it.\n      // import -> const\n      this.tokens.replaceToken(\"const\");\n      // Foo\n      this.tokens.copyToken();\n      // =\n      this.tokens.copyToken();\n      // require\n      this.tokens.replaceToken(this.helperManager.getHelperName(\"require\"));\n    } else {\n      // Otherwise, just switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      // Dynamic imports don't need to be transformed.\n      return false;\n    }\n\n    const snapshot = this.tokens.snapshot();\n    const allImportsRemoved = this.removeImportTypeBindings();\n    if (allImportsRemoved) {\n      this.tokens.restoreToSnapshot(snapshot);\n      while (!this.tokens.matches1(tt.string)) {\n        this.tokens.removeToken();\n      }\n      this.tokens.removeToken();\n      removeMaybeImportAttributes(this.tokens);\n      if (this.tokens.matches1(tt.semi)) {\n        this.tokens.removeToken();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove type bindings from this import, leaving the rest of the import intact.\n   *\n   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out\n   * of the replacement operation, so we can return early here.\n   */\n   removeImportTypeBindings() {\n    this.tokens.copyExpectedToken(tt._import);\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      this.tokens.copyToken();\n      return false;\n    }\n\n    // Skip the \"module\" token in import reflection.\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._module) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)\n    ) {\n      this.tokens.copyToken();\n    }\n\n    let foundNonTypeImport = false;\n    let foundAnyNamedImport = false;\n    let needsComma = false;\n\n    // Handle default import.\n    if (this.tokens.matches1(tt.name)) {\n      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        foundNonTypeImport = true;\n        this.tokens.copyToken();\n        if (this.tokens.matches1(tt.comma)) {\n          // We're in a statement like:\n          // import A, * as B from './A';\n          // or\n          // import A, {foo} from './A';\n          // where the `A` is being kept. The comma should be removed if an only\n          // if the next part of the import statement is elided, but that's hard\n          // to determine at this point in the code. Instead, always remove it\n          // and set a flag to add it back if necessary.\n          needsComma = true;\n          this.tokens.removeToken();\n        }\n      }\n    }\n\n    if (this.tokens.matches1(tt.star)) {\n      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n      } else {\n        if (needsComma) {\n          this.tokens.appendCode(\",\");\n        }\n        foundNonTypeImport = true;\n        this.tokens.copyExpectedToken(tt.star);\n        this.tokens.copyExpectedToken(tt.name);\n        this.tokens.copyExpectedToken(tt.name);\n      }\n    } else if (this.tokens.matches1(tt.braceL)) {\n      if (needsComma) {\n        this.tokens.appendCode(\",\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matches1(tt.braceR)) {\n        foundAnyNamedImport = true;\n        const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n        if (\n          specifierInfo.isType ||\n          this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)\n        ) {\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.removeToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.removeToken();\n          }\n        } else {\n          foundNonTypeImport = true;\n          while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n            this.tokens.copyToken();\n          }\n          if (this.tokens.matches1(tt.comma)) {\n            this.tokens.copyToken();\n          }\n        }\n      }\n      this.tokens.copyExpectedToken(tt.braceR);\n    }\n\n    if (this.keepUnusedImports) {\n      return false;\n    }\n    if (this.isTypeScriptTransformEnabled) {\n      return !foundNonTypeImport;\n    } else if (this.isFlowTransformEnabled) {\n      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.\n      return foundAnyNamedImport && !foundNonTypeImport;\n    } else {\n      return false;\n    }\n  }\n\n   shouldAutomaticallyElideImportedName(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      !this.keepUnusedImports &&\n      !this.nonTypeIdentifiers.has(name)\n    );\n  }\n\n   processExportDefault() {\n    if (\n      shouldElideDefaultExport(\n        this.isTypeScriptTransformEnabled,\n        this.keepUnusedImports,\n        this.tokens,\n        this.declarationInfo,\n      )\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      return true;\n    }\n\n    const alreadyHasName =\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&\n        this.tokens.matchesContextualAtIndex(\n          this.tokens.currentIndex() + 2,\n          ContextualKeyword._async,\n        )) ||\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name);\n\n    if (!alreadyHasName && this.reactHotLoaderTransformer) {\n      // This is a plain \"export default E\" statement and we need to assign E to a variable.\n      // Change \"export default E\" to \"let _default; export default _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; export`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle a statement with one of these forms:\n   * export {a, type b};\n   * export {c, type d} from 'foo';\n   *\n   * In both cases, any explicit type exports should be removed. In the first\n   * case, we also need to handle implicit export elision for names declared as\n   * types. In the second case, we must NOT do implicit named export elision,\n   * but we must remove the runtime import if all exports are type exports.\n   */\n   processNamedExports() {\n    if (!this.isTypeScriptTransformEnabled) {\n      return false;\n    }\n    this.tokens.copyExpectedToken(tt._export);\n    this.tokens.copyExpectedToken(tt.braceL);\n\n    const isReExport = isExportFrom(this.tokens);\n    let foundNonTypeExport = false;\n    while (!this.tokens.matches1(tt.braceR)) {\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n      if (\n        specifierInfo.isType ||\n        (!isReExport && this.shouldElideExportedName(specifierInfo.leftName))\n      ) {\n        // Type export, so remove all tokens, including any comma.\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.removeToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.removeToken();\n        }\n      } else {\n        // Non-type export, so copy all tokens, including any comma.\n        foundNonTypeExport = true;\n        while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n          this.tokens.copyToken();\n        }\n        if (this.tokens.matches1(tt.comma)) {\n          this.tokens.copyToken();\n        }\n      }\n    }\n    this.tokens.copyExpectedToken(tt.braceR);\n\n    if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {\n      // This is a type-only re-export, so skip evaluating the other module. Technically this\n      // leaves the statement as `export {}`, but that's ok since that's a no-op.\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n      removeMaybeImportAttributes(this.tokens);\n    }\n\n    return true;\n  }\n\n  /**\n   * ESM elides all imports with the rule that we only elide if we see that it's\n   * a type and never see it as a value. This is in contrast to CJS, which\n   * elides imports that are completely unknown.\n   */\n   shouldElideExportedName(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      !this.keepUnusedImports &&\n      this.declarationInfo.typeDeclarations.has(name) &&\n      !this.declarationInfo.valueDeclarations.has(name)\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}