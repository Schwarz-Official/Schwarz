{"ast":null,"code":"import { eatTypeToken, lookaheadType, match } from \"../tokenizer/index\";\nimport { TokenType as tt } from \"../tokenizer/types\";\nimport { isFlowEnabled, isTypeScriptEnabled } from \"../traverser/base\";\nimport { baseParseConditional } from \"../traverser/expression\";\nimport { flowParseTypeAnnotation } from \"./flow\";\nimport { tsParseTypeAnnotation } from \"./typescript\";\n\n/**\n * Common parser code for TypeScript and Flow.\n */\n\n// An apparent conditional expression could actually be an optional parameter in an arrow function.\nexport function typedParseConditional(noIn) {\n  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called\n  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional\n  // parameters without type annotations, i.e. ?, and ?) .\n  if (match(tt.question)) {\n    const nextType = lookaheadType();\n    if (nextType === tt.colon || nextType === tt.comma || nextType === tt.parenR) {\n      return;\n    }\n  }\n  baseParseConditional(noIn);\n}\n\n// Note: These \"type casts\" are *not* valid TS expressions.\n// But we parse them here and change them when completing the arrow function.\nexport function typedParseParenItem() {\n  eatTypeToken(tt.question);\n  if (match(tt.colon)) {\n    if (isTypeScriptEnabled) {\n      tsParseTypeAnnotation();\n    } else if (isFlowEnabled) {\n      flowParseTypeAnnotation();\n    }\n  }\n}","map":{"version":3,"names":["eatTypeToken","lookaheadType","match","TokenType","tt","isFlowEnabled","isTypeScriptEnabled","baseParseConditional","flowParseTypeAnnotation","tsParseTypeAnnotation","typedParseConditional","noIn","question","nextType","colon","comma","parenR","typedParseParenItem"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/plugins/types.js"],"sourcesContent":["import {eatTypeToken, lookaheadType, match} from \"../tokenizer/index\";\nimport {TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled} from \"../traverser/base\";\nimport {baseParseConditional} from \"../traverser/expression\";\nimport {flowParseTypeAnnotation} from \"./flow\";\nimport {tsParseTypeAnnotation} from \"./typescript\";\n\n/**\n * Common parser code for TypeScript and Flow.\n */\n\n// An apparent conditional expression could actually be an optional parameter in an arrow function.\nexport function typedParseConditional(noIn) {\n  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called\n  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional\n  // parameters without type annotations, i.e. ?, and ?) .\n  if (match(tt.question)) {\n    const nextType = lookaheadType();\n    if (nextType === tt.colon || nextType === tt.comma || nextType === tt.parenR) {\n      return;\n    }\n  }\n  baseParseConditional(noIn);\n}\n\n// Note: These \"type casts\" are *not* valid TS expressions.\n// But we parse them here and change them when completing the arrow function.\nexport function typedParseParenItem() {\n  eatTypeToken(tt.question);\n  if (match(tt.colon)) {\n    if (isTypeScriptEnabled) {\n      tsParseTypeAnnotation();\n    } else if (isFlowEnabled) {\n      flowParseTypeAnnotation();\n    }\n  }\n}\n"],"mappings":"AAAA,SAAQA,YAAY,EAAEC,aAAa,EAAEC,KAAK,QAAO,oBAAoB;AACrE,SAAQC,SAAS,IAAIC,EAAE,QAAO,oBAAoB;AAClD,SAAQC,aAAa,EAAEC,mBAAmB,QAAO,mBAAmB;AACpE,SAAQC,oBAAoB,QAAO,yBAAyB;AAC5D,SAAQC,uBAAuB,QAAO,QAAQ;AAC9C,SAAQC,qBAAqB,QAAO,cAAc;;AAElD;AACA;AACA;;AAEA;AACA,OAAO,SAASC,qBAAqBA,CAACC,IAAI,EAAE;EAC1C;EACA;EACA;EACA,IAAIT,KAAK,CAACE,EAAE,CAACQ,QAAQ,CAAC,EAAE;IACtB,MAAMC,QAAQ,GAAGZ,aAAa,CAAC,CAAC;IAChC,IAAIY,QAAQ,KAAKT,EAAE,CAACU,KAAK,IAAID,QAAQ,KAAKT,EAAE,CAACW,KAAK,IAAIF,QAAQ,KAAKT,EAAE,CAACY,MAAM,EAAE;MAC5E;IACF;EACF;EACAT,oBAAoB,CAACI,IAAI,CAAC;AAC5B;;AAEA;AACA;AACA,OAAO,SAASM,mBAAmBA,CAAA,EAAG;EACpCjB,YAAY,CAACI,EAAE,CAACQ,QAAQ,CAAC;EACzB,IAAIV,KAAK,CAACE,EAAE,CAACU,KAAK,CAAC,EAAE;IACnB,IAAIR,mBAAmB,EAAE;MACvBG,qBAAqB,CAAC,CAAC;IACzB,CAAC,MAAM,IAAIJ,aAAa,EAAE;MACxBG,uBAAuB,CAAC,CAAC;IAC3B;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}