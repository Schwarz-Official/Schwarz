{"ast":null,"code":"const HELPERS = {\n  require: `\n    import {createRequire as CREATE_REQUIRE_NAME} from \"module\";\n    const require = CREATE_REQUIRE_NAME(import.meta.url);\n  `,\n  interopRequireWildcard: `\n    function interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n        newObj.default = obj;\n        return newObj;\n      }\n    }\n  `,\n  interopRequireDefault: `\n    function interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n  `,\n  createNamedExportFrom: `\n    function createNamedExportFrom(obj, localName, importedName) {\n      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});\n    }\n  `,\n  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence\n  // check in the exports object and does a plain assignment, whereas Babel uses\n  // defineProperty and builds an object of explicitly-exported names so that star exports can\n  // always take lower precedence. For now, we do the easier TypeScript thing.\n  createStarExport: `\n    function createStarExport(obj) {\n      Object.keys(obj)\n        .filter((key) => key !== \"default\" && key !== \"__esModule\")\n        .forEach((key) => {\n          if (exports.hasOwnProperty(key)) {\n            return;\n          }\n          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});\n        });\n    }\n  `,\n  nullishCoalesce: `\n    function nullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return rhsFn();\n      }\n    }\n  `,\n  asyncNullishCoalesce: `\n    async function asyncNullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return await rhsFn();\n      }\n    }\n  `,\n  optionalChain: `\n    function optionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  asyncOptionalChain: `\n    async function asyncOptionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = await fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = await fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  optionalChainDelete: `\n    function optionalChainDelete(ops) {\n      const result = OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `,\n  asyncOptionalChainDelete: `\n    async function asyncOptionalChainDelete(ops) {\n      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `\n};\nexport class HelperManager {\n  __init() {\n    this.helperNames = {};\n  }\n  __init2() {\n    this.createRequireName = null;\n  }\n  constructor(nameManager) {\n    ;\n    this.nameManager = nameManager;\n    HelperManager.prototype.__init.call(this);\n    HelperManager.prototype.__init2.call(this);\n  }\n  getHelperName(baseName) {\n    let helperName = this.helperNames[baseName];\n    if (helperName) {\n      return helperName;\n    }\n    helperName = this.nameManager.claimFreeName(`_${baseName}`);\n    this.helperNames[baseName] = helperName;\n    return helperName;\n  }\n  emitHelpers() {\n    let resultCode = \"\";\n    if (this.helperNames.optionalChainDelete) {\n      this.getHelperName(\"optionalChain\");\n    }\n    if (this.helperNames.asyncOptionalChainDelete) {\n      this.getHelperName(\"asyncOptionalChain\");\n    }\n    for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {\n      const helperName = this.helperNames[baseName];\n      let helperCode = helperCodeTemplate;\n      if (baseName === \"optionalChainDelete\") {\n        helperCode = helperCode.replace(\"OPTIONAL_CHAIN_NAME\", this.helperNames.optionalChain);\n      } else if (baseName === \"asyncOptionalChainDelete\") {\n        helperCode = helperCode.replace(\"ASYNC_OPTIONAL_CHAIN_NAME\", this.helperNames.asyncOptionalChain);\n      } else if (baseName === \"require\") {\n        if (this.createRequireName === null) {\n          this.createRequireName = this.nameManager.claimFreeName(\"_createRequire\");\n        }\n        helperCode = helperCode.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName);\n      }\n      if (helperName) {\n        resultCode += \" \";\n        resultCode += helperCode.replace(baseName, helperName).replace(/\\s+/g, \" \").trim();\n      }\n    }\n    return resultCode;\n  }\n}","map":{"version":3,"names":["HELPERS","require","interopRequireWildcard","interopRequireDefault","createNamedExportFrom","createStarExport","nullishCoalesce","asyncNullishCoalesce","optionalChain","asyncOptionalChain","optionalChainDelete","asyncOptionalChainDelete","HelperManager","__init","helperNames","__init2","createRequireName","constructor","nameManager","prototype","call","getHelperName","baseName","helperName","claimFreeName","emitHelpers","resultCode","helperCodeTemplate","Object","entries","helperCode","replace","trim"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/HelperManager.js"],"sourcesContent":["\n\nconst HELPERS = {\n  require: `\n    import {createRequire as CREATE_REQUIRE_NAME} from \"module\";\n    const require = CREATE_REQUIRE_NAME(import.meta.url);\n  `,\n  interopRequireWildcard: `\n    function interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n              newObj[key] = obj[key];\n            }\n          }\n        }\n        newObj.default = obj;\n        return newObj;\n      }\n    }\n  `,\n  interopRequireDefault: `\n    function interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n  `,\n  createNamedExportFrom: `\n    function createNamedExportFrom(obj, localName, importedName) {\n      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});\n    }\n  `,\n  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence\n  // check in the exports object and does a plain assignment, whereas Babel uses\n  // defineProperty and builds an object of explicitly-exported names so that star exports can\n  // always take lower precedence. For now, we do the easier TypeScript thing.\n  createStarExport: `\n    function createStarExport(obj) {\n      Object.keys(obj)\n        .filter((key) => key !== \"default\" && key !== \"__esModule\")\n        .forEach((key) => {\n          if (exports.hasOwnProperty(key)) {\n            return;\n          }\n          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});\n        });\n    }\n  `,\n  nullishCoalesce: `\n    function nullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return rhsFn();\n      }\n    }\n  `,\n  asyncNullishCoalesce: `\n    async function asyncNullishCoalesce(lhs, rhsFn) {\n      if (lhs != null) {\n        return lhs;\n      } else {\n        return await rhsFn();\n      }\n    }\n  `,\n  optionalChain: `\n    function optionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  asyncOptionalChain: `\n    async function asyncOptionalChain(ops) {\n      let lastAccessLHS = undefined;\n      let value = ops[0];\n      let i = 1;\n      while (i < ops.length) {\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n          return undefined;\n        }\n        if (op === 'access' || op === 'optionalAccess') {\n          lastAccessLHS = value;\n          value = await fn(value);\n        } else if (op === 'call' || op === 'optionalCall') {\n          value = await fn((...args) => value.call(lastAccessLHS, ...args));\n          lastAccessLHS = undefined;\n        }\n      }\n      return value;\n    }\n  `,\n  optionalChainDelete: `\n    function optionalChainDelete(ops) {\n      const result = OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `,\n  asyncOptionalChainDelete: `\n    async function asyncOptionalChainDelete(ops) {\n      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);\n      return result == null ? true : result;\n    }\n  `,\n};\n\nexport class HelperManager {\n  __init() {this.helperNames = {}}\n  __init2() {this.createRequireName = null}\n  constructor( nameManager) {;this.nameManager = nameManager;HelperManager.prototype.__init.call(this);HelperManager.prototype.__init2.call(this);}\n\n  getHelperName(baseName) {\n    let helperName = this.helperNames[baseName];\n    if (helperName) {\n      return helperName;\n    }\n    helperName = this.nameManager.claimFreeName(`_${baseName}`);\n    this.helperNames[baseName] = helperName;\n    return helperName;\n  }\n\n  emitHelpers() {\n    let resultCode = \"\";\n    if (this.helperNames.optionalChainDelete) {\n      this.getHelperName(\"optionalChain\");\n    }\n    if (this.helperNames.asyncOptionalChainDelete) {\n      this.getHelperName(\"asyncOptionalChain\");\n    }\n    for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)) {\n      const helperName = this.helperNames[baseName];\n      let helperCode = helperCodeTemplate;\n      if (baseName === \"optionalChainDelete\") {\n        helperCode = helperCode.replace(\"OPTIONAL_CHAIN_NAME\", this.helperNames.optionalChain);\n      } else if (baseName === \"asyncOptionalChainDelete\") {\n        helperCode = helperCode.replace(\n          \"ASYNC_OPTIONAL_CHAIN_NAME\",\n          this.helperNames.asyncOptionalChain,\n        );\n      } else if (baseName === \"require\") {\n        if (this.createRequireName === null) {\n          this.createRequireName = this.nameManager.claimFreeName(\"_createRequire\");\n        }\n        helperCode = helperCode.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName);\n      }\n      if (helperName) {\n        resultCode += \" \";\n        resultCode += helperCode.replace(baseName, helperName).replace(/\\s+/g, \" \").trim();\n      }\n    }\n    return resultCode;\n  }\n}\n"],"mappings":"AAEA,MAAMA,OAAO,GAAG;EACdC,OAAO,EAAG;AACZ;AACA;AACA,GAAG;EACDC,sBAAsB,EAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;EACDC,qBAAqB,EAAG;AAC1B;AACA;AACA;AACA,GAAG;EACDC,qBAAqB,EAAG;AAC1B;AACA;AACA;AACA,GAAG;EACD;EACA;EACA;EACA;EACAC,gBAAgB,EAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;EACDC,eAAe,EAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;EACDC,oBAAoB,EAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;EACDC,aAAa,EAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;EACDC,kBAAkB,EAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;EACDC,mBAAmB,EAAG;AACxB;AACA;AACA;AACA;AACA,GAAG;EACDC,wBAAwB,EAAG;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,OAAO,MAAMC,aAAa,CAAC;EACzBC,MAAMA,CAAA,EAAG;IAAC,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;EAAA;EAC/BC,OAAOA,CAAA,EAAG;IAAC,IAAI,CAACC,iBAAiB,GAAG,IAAI;EAAA;EACxCC,WAAWA,CAAEC,WAAW,EAAE;IAAC;IAAC,IAAI,CAACA,WAAW,GAAGA,WAAW;IAACN,aAAa,CAACO,SAAS,CAACN,MAAM,CAACO,IAAI,CAAC,IAAI,CAAC;IAACR,aAAa,CAACO,SAAS,CAACJ,OAAO,CAACK,IAAI,CAAC,IAAI,CAAC;EAAC;EAEhJC,aAAaA,CAACC,QAAQ,EAAE;IACtB,IAAIC,UAAU,GAAG,IAAI,CAACT,WAAW,CAACQ,QAAQ,CAAC;IAC3C,IAAIC,UAAU,EAAE;MACd,OAAOA,UAAU;IACnB;IACAA,UAAU,GAAG,IAAI,CAACL,WAAW,CAACM,aAAa,CAAE,IAAGF,QAAS,EAAC,CAAC;IAC3D,IAAI,CAACR,WAAW,CAACQ,QAAQ,CAAC,GAAGC,UAAU;IACvC,OAAOA,UAAU;EACnB;EAEAE,WAAWA,CAAA,EAAG;IACZ,IAAIC,UAAU,GAAG,EAAE;IACnB,IAAI,IAAI,CAACZ,WAAW,CAACJ,mBAAmB,EAAE;MACxC,IAAI,CAACW,aAAa,CAAC,eAAe,CAAC;IACrC;IACA,IAAI,IAAI,CAACP,WAAW,CAACH,wBAAwB,EAAE;MAC7C,IAAI,CAACU,aAAa,CAAC,oBAAoB,CAAC;IAC1C;IACA,KAAK,MAAM,CAACC,QAAQ,EAAEK,kBAAkB,CAAC,IAAIC,MAAM,CAACC,OAAO,CAAC7B,OAAO,CAAC,EAAE;MACpE,MAAMuB,UAAU,GAAG,IAAI,CAACT,WAAW,CAACQ,QAAQ,CAAC;MAC7C,IAAIQ,UAAU,GAAGH,kBAAkB;MACnC,IAAIL,QAAQ,KAAK,qBAAqB,EAAE;QACtCQ,UAAU,GAAGA,UAAU,CAACC,OAAO,CAAC,qBAAqB,EAAE,IAAI,CAACjB,WAAW,CAACN,aAAa,CAAC;MACxF,CAAC,MAAM,IAAIc,QAAQ,KAAK,0BAA0B,EAAE;QAClDQ,UAAU,GAAGA,UAAU,CAACC,OAAO,CAC7B,2BAA2B,EAC3B,IAAI,CAACjB,WAAW,CAACL,kBACnB,CAAC;MACH,CAAC,MAAM,IAAIa,QAAQ,KAAK,SAAS,EAAE;QACjC,IAAI,IAAI,CAACN,iBAAiB,KAAK,IAAI,EAAE;UACnC,IAAI,CAACA,iBAAiB,GAAG,IAAI,CAACE,WAAW,CAACM,aAAa,CAAC,gBAAgB,CAAC;QAC3E;QACAM,UAAU,GAAGA,UAAU,CAACC,OAAO,CAAC,sBAAsB,EAAE,IAAI,CAACf,iBAAiB,CAAC;MACjF;MACA,IAAIO,UAAU,EAAE;QACdG,UAAU,IAAI,GAAG;QACjBA,UAAU,IAAII,UAAU,CAACC,OAAO,CAACT,QAAQ,EAAEC,UAAU,CAAC,CAACQ,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACC,IAAI,CAAC,CAAC;MACpF;IACF;IACA,OAAON,UAAU;EACnB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}