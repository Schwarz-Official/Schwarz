{"ast":null,"code":"/**\n * This splits a string on a top-level character.\n *\n * Regex doesn't support recursion (at least not the JS-flavored version).\n * So we have to use a tiny state machine to keep track of paren placement.\n *\n * Expected behavior using commas:\n * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)\n *       ─┬─             ┬  ┬    ┬\n *        x              x  x    ╰──────── Split because top-level\n *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens\n *\n * @param {string} input\n * @param {string} separator\n */\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n  enumerable: true,\n  get: function () {\n    return splitAtTopLevelOnly;\n  }\n});\nfunction splitAtTopLevelOnly(input, separator) {\n  let stack = [];\n  let parts = [];\n  let lastPos = 0;\n  let isEscaped = false;\n  for (let idx = 0; idx < input.length; idx++) {\n    let char = input[idx];\n    if (stack.length === 0 && char === separator[0] && !isEscaped) {\n      if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {\n        parts.push(input.slice(lastPos, idx));\n        lastPos = idx + separator.length;\n      }\n    }\n    if (isEscaped) {\n      isEscaped = false;\n    } else if (char === \"\\\\\") {\n      isEscaped = true;\n    }\n    if (char === \"(\" || char === \"[\" || char === \"{\") {\n      stack.push(char);\n    } else if (char === \")\" && stack[stack.length - 1] === \"(\" || char === \"]\" && stack[stack.length - 1] === \"[\" || char === \"}\" && stack[stack.length - 1] === \"{\") {\n      stack.pop();\n    }\n  }\n  parts.push(input.slice(lastPos));\n  return parts;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","splitAtTopLevelOnly","input","separator","stack","parts","lastPos","isEscaped","idx","length","char","slice","push","pop"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"],"sourcesContent":["/**\n * This splits a string on a top-level character.\n *\n * Regex doesn't support recursion (at least not the JS-flavored version).\n * So we have to use a tiny state machine to keep track of paren placement.\n *\n * Expected behavior using commas:\n * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)\n *       ─┬─             ┬  ┬    ┬\n *        x              x  x    ╰──────── Split because top-level\n *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens\n *\n * @param {string} input\n * @param {string} separator\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n    enumerable: true,\n    get: function() {\n        return splitAtTopLevelOnly;\n    }\n});\nfunction splitAtTopLevelOnly(input, separator) {\n    let stack = [];\n    let parts = [];\n    let lastPos = 0;\n    let isEscaped = false;\n    for(let idx = 0; idx < input.length; idx++){\n        let char = input[idx];\n        if (stack.length === 0 && char === separator[0] && !isEscaped) {\n            if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {\n                parts.push(input.slice(lastPos, idx));\n                lastPos = idx + separator.length;\n            }\n        }\n        if (isEscaped) {\n            isEscaped = false;\n        } else if (char === \"\\\\\") {\n            isEscaped = true;\n        }\n        if (char === \"(\" || char === \"[\" || char === \"{\") {\n            stack.push(char);\n        } else if (char === \")\" && stack[stack.length - 1] === \"(\" || char === \"]\" && stack[stack.length - 1] === \"[\" || char === \"}\" && stack[stack.length - 1] === \"{\") {\n            stack.pop();\n        }\n    }\n    parts.push(input.slice(lastPos));\n    return parts;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAI,YAAY;;AAChBA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,qBAAqB,EAAE;EAClDE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,OAAOC,mBAAmB;EAC9B;AACJ,CAAC,CAAC;AACF,SAASA,mBAAmBA,CAACC,KAAK,EAAEC,SAAS,EAAE;EAC3C,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,SAAS,GAAG,KAAK;EACrB,KAAI,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGN,KAAK,CAACO,MAAM,EAAED,GAAG,EAAE,EAAC;IACvC,IAAIE,IAAI,GAAGR,KAAK,CAACM,GAAG,CAAC;IACrB,IAAIJ,KAAK,CAACK,MAAM,KAAK,CAAC,IAAIC,IAAI,KAAKP,SAAS,CAAC,CAAC,CAAC,IAAI,CAACI,SAAS,EAAE;MAC3D,IAAIJ,SAAS,CAACM,MAAM,KAAK,CAAC,IAAIP,KAAK,CAACS,KAAK,CAACH,GAAG,EAAEA,GAAG,GAAGL,SAAS,CAACM,MAAM,CAAC,KAAKN,SAAS,EAAE;QAClFE,KAAK,CAACO,IAAI,CAACV,KAAK,CAACS,KAAK,CAACL,OAAO,EAAEE,GAAG,CAAC,CAAC;QACrCF,OAAO,GAAGE,GAAG,GAAGL,SAAS,CAACM,MAAM;MACpC;IACJ;IACA,IAAIF,SAAS,EAAE;MACXA,SAAS,GAAG,KAAK;IACrB,CAAC,MAAM,IAAIG,IAAI,KAAK,IAAI,EAAE;MACtBH,SAAS,GAAG,IAAI;IACpB;IACA,IAAIG,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;MAC9CN,KAAK,CAACQ,IAAI,CAACF,IAAI,CAAC;IACpB,CAAC,MAAM,IAAIA,IAAI,KAAK,GAAG,IAAIN,KAAK,CAACA,KAAK,CAACK,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,IAAIC,IAAI,KAAK,GAAG,IAAIN,KAAK,CAACA,KAAK,CAACK,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,IAAIC,IAAI,KAAK,GAAG,IAAIN,KAAK,CAACA,KAAK,CAACK,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MAC9JL,KAAK,CAACS,GAAG,CAAC,CAAC;IACf;EACJ;EACAR,KAAK,CAACO,IAAI,CAACV,KAAK,CAACS,KAAK,CAACL,OAAO,CAAC,CAAC;EAChC,OAAOD,KAAK;AAChB"},"metadata":{},"sourceType":"script","externalDependencies":[]}