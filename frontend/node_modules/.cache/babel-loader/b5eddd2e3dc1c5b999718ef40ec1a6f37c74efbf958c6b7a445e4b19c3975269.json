{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return expandApplyAtRules;\n  }\n});\nconst _postcss = /*#__PURE__*/_interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _generateRules = require(\"./generateRules\");\nconst _escapeClassName = /*#__PURE__*/_interop_require_default(require(\"../util/escapeClassName\"));\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nconst _pseudoElements = require(\"../util/pseudoElements\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */\nfunction extractClasses(node) {\n  /** @type {Map<string, Set<string>>} */let groups = new Map();\n  let container = _postcss.default.root({\n    nodes: [node.clone()]\n  });\n  container.walkRules(rule => {\n    (0, _postcssselectorparser.default)(selectors => {\n      selectors.walkClasses(classSelector => {\n        let parentSelector = classSelector.parent.toString();\n        let classes = groups.get(parentSelector);\n        if (!classes) {\n          groups.set(parentSelector, classes = new Set());\n        }\n        classes.add(classSelector.value);\n      });\n    }).processSync(rule.selector);\n  });\n  let normalizedGroups = Array.from(groups.values(), classes => Array.from(classes));\n  let classes = normalizedGroups.flat();\n  return Object.assign(classes, {\n    groups: normalizedGroups\n  });\n}\nlet selectorExtractor = (0, _postcssselectorparser.default)();\n/**\n * @param {string} ruleSelectors\n */\nfunction extractSelectors(ruleSelectors) {\n  return selectorExtractor.astSync(ruleSelectors);\n}\nfunction extractBaseCandidates(candidates, separator) {\n  let baseClasses = new Set();\n  for (let candidate of candidates) {\n    baseClasses.add(candidate.split(separator).pop());\n  }\n  return Array.from(baseClasses);\n}\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction* pathToRoot(node) {\n  yield node;\n  while (node.parent) {\n    yield node.parent;\n    node = node.parent;\n  }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */\nfunction shallowClone(node, overrides = {}) {\n  let children = node.nodes;\n  node.nodes = [];\n  let tmp = node.clone(overrides);\n  node.nodes = children;\n  return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */\nfunction nestedClone(node) {\n  for (let parent of pathToRoot(node)) {\n    if (node === parent) {\n      continue;\n    }\n    if (parent.type === \"root\") {\n      break;\n    }\n    node = shallowClone(parent, {\n      nodes: [node]\n    });\n  }\n  return node;\n}\n/**\n * @param {import('postcss').Root} root\n */\nfunction buildLocalApplyCache(root, context) {\n  /** @type {ApplyCache} */let cache = new Map();\n  root.walkRules(rule => {\n    // Ignore rules generated by Tailwind\n    for (let node of pathToRoot(rule)) {\n      var _node_raws_tailwind;\n      if (((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.layer) !== undefined) {\n        return;\n      }\n    }\n    // Clone what's required to represent this singular rule in the tree\n    let container = nestedClone(rule);\n    let sort = context.offsets.create(\"user\");\n    for (let className of extractClasses(rule)) {\n      let list = cache.get(className) || [];\n      cache.set(className, list);\n      list.push([{\n        layer: \"user\",\n        sort,\n        important: false\n      }, container]);\n    }\n  });\n  return cache;\n}\n/**\n * @returns {ApplyCache}\n */\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue;\n    }\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()]));\n      continue;\n    }\n    let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n    context.applyClassCache.set(candidate, matches);\n  }\n  return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */\nfunction lazyCache(buildCacheFn) {\n  let cache = null;\n  return {\n    get: name => {\n      cache = cache || buildCacheFn();\n      return cache.get(name);\n    },\n    has: name => {\n      cache = cache || buildCacheFn();\n      return cache.has(name);\n    }\n  };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */\nfunction combineCaches(caches) {\n  return {\n    get: name => caches.flatMap(cache => cache.get(name) || []),\n    has: name => caches.some(cache => cache.has(name))\n  };\n}\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g);\n  if (candidates[candidates.length - 1] === \"!important\") {\n    return [candidates.slice(0, -1), true];\n  }\n  return [candidates, false];\n}\nfunction processApply(root, context, localCache) {\n  let applyCandidates = new Set();\n  // Collect all @apply rules and candidates\n  let applies = [];\n  root.walkAtRules(\"apply\", rule => {\n    let [candidates] = extractApplyCandidates(rule.params);\n    for (let util of candidates) {\n      applyCandidates.add(util);\n    }\n    applies.push(rule);\n  });\n  // Start the @apply process if we have rules with @apply in them\n  if (applies.length === 0) {\n    return;\n  }\n  // Fill up some caches!\n  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);\n  /**\n  * When we have an apply like this:\n  *\n  * .abc {\n  *    @apply hover:font-bold;\n  * }\n  *\n  * What we essentially will do is resolve to this:\n  *\n  * .abc {\n  *    @apply .hover\\:font-bold:hover {\n  *      font-weight: 500;\n  *    }\n  * }\n  *\n  * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n  * What happens in this function is that we prepend a `.` and escape the candidate.\n  * This will result in `.hover\\:font-bold`\n  * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n  *\n  * @param {string} selector\n  * @param {string} utilitySelectors\n  * @param {string} candidate\n  */\n  function replaceSelector(selector, utilitySelectors, candidate) {\n    let selectorList = extractSelectors(selector);\n    let utilitySelectorsList = extractSelectors(utilitySelectors);\n    let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);\n    let candidateClass = candidateList.nodes[0].nodes[0];\n    selectorList.each(sel => {\n      /** @type {Set<import('postcss-selector-parser').Selector>} */let replaced = new Set();\n      utilitySelectorsList.each(utilitySelector => {\n        let hasReplaced = false;\n        utilitySelector = utilitySelector.clone();\n        utilitySelector.walkClasses(node => {\n          if (node.value !== candidateClass.value) {\n            return;\n          }\n          // Don't replace multiple instances of the same class\n          // This is theoretically correct but only partially\n          // We'd need to generate every possible permutation of the replacement\n          // For example with `.foo + .foo { … }` and `section { @apply foo; }`\n          // We'd need to generate all of these:\n          // - `.foo + .foo`\n          // - `.foo + section`\n          // - `section + .foo`\n          // - `section + section`\n          if (hasReplaced) {\n            return;\n          }\n          // Since you can only `@apply` class names this is sufficient\n          // We want to replace the matched class name with the selector the user is using\n          // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`\n          node.replaceWith(...sel.nodes.map(node => node.clone()));\n          // Record that we did something and we want to use this new selector\n          replaced.add(utilitySelector);\n          hasReplaced = true;\n        });\n      });\n      // Sort tag names before class names (but only sort each group (separated by a combinator)\n      // separately and not in total)\n      // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`\n      for (let sel of replaced) {\n        let groups = [[]];\n        for (let node of sel.nodes) {\n          if (node.type === \"combinator\") {\n            groups.push(node);\n            groups.push([]);\n          } else {\n            let last = groups[groups.length - 1];\n            last.push(node);\n          }\n        }\n        sel.nodes = [];\n        for (let group of groups) {\n          if (Array.isArray(group)) {\n            group.sort((a, b) => {\n              if (a.type === \"tag\" && b.type === \"class\") {\n                return -1;\n              } else if (a.type === \"class\" && b.type === \"tag\") {\n                return 1;\n              } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n                return -1;\n              } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n                return 1;\n              }\n              return 0;\n            });\n          }\n          sel.nodes = sel.nodes.concat(group);\n        }\n      }\n      sel.replaceWith(...replaced);\n    });\n    return selectorList.toString();\n  }\n  let perParentApplies = new Map();\n  // Collect all apply candidates and their rules\n  for (let apply of applies) {\n    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];\n    perParentApplies.set(apply.parent, [candidates, apply.source]);\n    let [applyCandidates, important] = extractApplyCandidates(apply.params);\n    if (apply.parent.type === \"atrule\") {\n      if (apply.parent.name === \"screen\") {\n        let screenType = apply.parent.params;\n        throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map(c => `${screenType}:${c}`).join(\" \")} instead.`);\n      }\n      throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n    }\n    for (let applyCandidate of applyCandidates) {\n      if ([prefix(context, \"group\"), prefix(context, \"peer\")].includes(applyCandidate)) {\n        // TODO: Link to specific documentation page with error code.\n        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n      }\n      if (!applyClassCache.has(applyCandidate)) {\n        throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n      }\n      let rules = applyClassCache.get(applyCandidate);\n      candidates.push([applyCandidate, important, rules]);\n    }\n  }\n  for (let [parent, [candidates, atApplySource]] of perParentApplies) {\n    let siblings = [];\n    for (let [applyCandidate, important, rules] of candidates) {\n      let potentialApplyCandidates = [applyCandidate, ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator)];\n      for (let [meta, node] of rules) {\n        let parentClasses = extractClasses(parent);\n        let nodeClasses = extractClasses(node);\n        // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n        // So we've split them into groups\n        nodeClasses = nodeClasses.groups.filter(classList => classList.some(className => potentialApplyCandidates.includes(className))).flat();\n        // Add base utility classes from the @apply node to the list of\n        // classes to check whether it intersects and therefore results in a\n        // circular dependency or not.\n        //\n        // E.g.:\n        // .foo {\n        //   @apply hover:a; // This applies \"a\" but with a modifier\n        // }\n        //\n        // We only have to do that with base classes of the `node`, not of the `parent`\n        // E.g.:\n        // .hover\\:foo {\n        //   @apply bar;\n        // }\n        // .bar {\n        //   @apply foo;\n        // }\n        //\n        // This should not result in a circular dependency because we are\n        // just applying `.foo` and the rule above is `.hover\\:foo` which is\n        // unrelated. However, if we were to apply `hover:foo` then we _did_\n        // have to include this one.\n        nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n        let intersects = parentClasses.some(selector => nodeClasses.includes(selector));\n        if (intersects) {\n          throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate}\\` utility here because it creates a circular dependency.`);\n        }\n        let root = _postcss.default.root({\n          nodes: [node.clone()]\n        });\n        // Make sure every node in the entire tree points back at the @apply rule that generated it\n        root.walk(node => {\n          node.source = atApplySource;\n        });\n        let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n        if (canRewriteSelector) {\n          root.walkRules(rule => {\n            // Let's imagine you have the following structure:\n            //\n            // .foo {\n            //   @apply bar;\n            // }\n            //\n            // @supports (a: b) {\n            //   .bar {\n            //     color: blue\n            //   }\n            //\n            //   .something-unrelated {}\n            // }\n            //\n            // In this case we want to apply `.bar` but it happens to be in\n            // an atrule node. We clone that node instead of the nested one\n            // because we still want that @supports rule to be there once we\n            // applied everything.\n            //\n            // However it happens to be that the `.something-unrelated` is\n            // also in that same shared @supports atrule. This is not good,\n            // and this should not be there. The good part is that this is\n            // a clone already and it can be safely removed. The question is\n            // how do we know we can remove it. Basically what we can do is\n            // match it against the applyCandidate that you want to apply. If\n            // it doesn't match the we can safely delete it.\n            //\n            // If we didn't do this, then the `replaceSelector` function\n            // would have replaced this with something that didn't exist and\n            // therefore it removed the selector altogether. In this specific\n            // case it would result in `{}` instead of `.something-unrelated {}`\n            if (!extractClasses(rule).some(candidate => candidate === applyCandidate)) {\n              rule.remove();\n              return;\n            }\n            // Strip the important selector from the parent selector if at the beginning\n            let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null;\n            // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n            // We do *not* want to do this for user CSS that happens to be structured the same\n            let isGenerated = parent.raws.tailwind !== undefined;\n            let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n            rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate);\n            // And then re-add it if it was removed\n            if (importantSelector && parentSelector !== parent.selector) {\n              rule.selector = (0, _applyImportantSelector.applyImportantSelector)(rule.selector, importantSelector);\n            }\n            rule.walkDecls(d => {\n              d.important = meta.important || important;\n            });\n            // Move pseudo elements to the end of the selector (if necessary)\n            let selector = (0, _postcssselectorparser.default)().astSync(rule.selector);\n            selector.each(sel => (0, _pseudoElements.movePseudos)(sel));\n            rule.selector = selector.toString();\n          });\n        }\n        // It could be that the node we were inserted was removed because the class didn't match\n        // If that was the *only* rule in the parent, then we have nothing add so we skip it\n        if (!root.nodes[0]) {\n          continue;\n        }\n        // Insert it\n        siblings.push([meta.sort, root.nodes[0]]);\n      }\n    }\n    // Inject the rules, sorted, correctly\n    let nodes = context.offsets.sort(siblings).map(s => s[1]);\n    // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n    parent.after(nodes);\n  }\n  for (let apply of applies) {\n    // If there are left-over declarations, just remove the @apply\n    if (apply.parent.nodes.length > 1) {\n      apply.remove();\n    } else {\n      // The node is empty, drop the full node\n      apply.parent.remove();\n    }\n  }\n  // Do it again, in case we have other `@apply` rules\n  processApply(root, context, localCache);\n}\nfunction expandApplyAtRules(context) {\n  return root => {\n    // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n    let localCache = lazyCache(() => buildLocalApplyCache(root, context));\n    processApply(root, context, localCache);\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","expandApplyAtRules","_postcss","_interop_require_default","require","_postcssselectorparser","_generateRules","_escapeClassName","_applyImportantSelector","_pseudoElements","obj","__esModule","default","extractClasses","node","groups","Map","container","root","nodes","clone","walkRules","rule","selectors","walkClasses","classSelector","parentSelector","parent","toString","classes","set","Set","add","processSync","selector","normalizedGroups","Array","from","values","flat","assign","selectorExtractor","extractSelectors","ruleSelectors","astSync","extractBaseCandidates","candidates","separator","baseClasses","candidate","split","pop","prefix","context","tailwindConfig","pathToRoot","shallowClone","overrides","children","tmp","nestedClone","type","buildLocalApplyCache","cache","_node_raws_tailwind","raws","tailwind","layer","undefined","sort","offsets","create","className","list","push","important","buildApplyCache","applyCandidates","notClassCache","has","applyClassCache","classCache","map","meta","matches","resolveMatches","length","lazyCache","buildCacheFn","name","combineCaches","caches","flatMap","some","extractApplyCandidates","params","slice","processApply","localCache","applies","walkAtRules","util","replaceSelector","utilitySelectors","selectorList","utilitySelectorsList","candidateList","candidateClass","each","sel","replaced","utilitySelector","hasReplaced","replaceWith","last","group","isArray","a","b","startsWith","concat","perParentApplies","apply","source","screenType","error","c","join","applyCandidate","includes","rules","atApplySource","siblings","potentialApplyCandidates","parentClasses","nodeClasses","filter","classList","intersects","walk","canRewriteSelector","remove","importantSelector","isGenerated","indexOf","applyImportantSelector","walkDecls","d","movePseudos","s","after"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/lib/expandApplyAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return expandApplyAtRules;\n    }\n});\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _generateRules = require(\"./generateRules\");\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _applyImportantSelector = require(\"../util/applyImportantSelector\");\nconst _pseudoElements = require(\"../util/pseudoElements\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */ function extractClasses(node) {\n    /** @type {Map<string, Set<string>>} */ let groups = new Map();\n    let container = _postcss.default.root({\n        nodes: [\n            node.clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        (0, _postcssselectorparser.default)((selectors)=>{\n            selectors.walkClasses((classSelector)=>{\n                let parentSelector = classSelector.parent.toString();\n                let classes = groups.get(parentSelector);\n                if (!classes) {\n                    groups.set(parentSelector, classes = new Set());\n                }\n                classes.add(classSelector.value);\n            });\n        }).processSync(rule.selector);\n    });\n    let normalizedGroups = Array.from(groups.values(), (classes)=>Array.from(classes));\n    let classes = normalizedGroups.flat();\n    return Object.assign(classes, {\n        groups: normalizedGroups\n    });\n}\nlet selectorExtractor = (0, _postcssselectorparser.default)();\n/**\n * @param {string} ruleSelectors\n */ function extractSelectors(ruleSelectors) {\n    return selectorExtractor.astSync(ruleSelectors);\n}\nfunction extractBaseCandidates(candidates, separator) {\n    let baseClasses = new Set();\n    for (let candidate of candidates){\n        baseClasses.add(candidate.split(separator).pop());\n    }\n    return Array.from(baseClasses);\n}\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction* pathToRoot(node) {\n    yield node;\n    while(node.parent){\n        yield node.parent;\n        node = node.parent;\n    }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */ function shallowClone(node, overrides = {}) {\n    let children = node.nodes;\n    node.nodes = [];\n    let tmp = node.clone(overrides);\n    node.nodes = children;\n    return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */ function nestedClone(node) {\n    for (let parent of pathToRoot(node)){\n        if (node === parent) {\n            continue;\n        }\n        if (parent.type === \"root\") {\n            break;\n        }\n        node = shallowClone(parent, {\n            nodes: [\n                node\n            ]\n        });\n    }\n    return node;\n}\n/**\n * @param {import('postcss').Root} root\n */ function buildLocalApplyCache(root, context) {\n    /** @type {ApplyCache} */ let cache = new Map();\n    root.walkRules((rule)=>{\n        // Ignore rules generated by Tailwind\n        for (let node of pathToRoot(rule)){\n            var _node_raws_tailwind;\n            if (((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.layer) !== undefined) {\n                return;\n            }\n        }\n        // Clone what's required to represent this singular rule in the tree\n        let container = nestedClone(rule);\n        let sort = context.offsets.create(\"user\");\n        for (let className of extractClasses(rule)){\n            let list = cache.get(className) || [];\n            cache.set(className, list);\n            list.push([\n                {\n                    layer: \"user\",\n                    sort,\n                    important: false\n                },\n                container\n            ]);\n        }\n    });\n    return cache;\n}\n/**\n * @returns {ApplyCache}\n */ function buildApplyCache(applyCandidates, context) {\n    for (let candidate of applyCandidates){\n        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.classCache.has(candidate)) {\n            context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule])=>[\n                    meta,\n                    rule.clone()\n                ]));\n            continue;\n        }\n        let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.applyClassCache.set(candidate, matches);\n    }\n    return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */ function lazyCache(buildCacheFn) {\n    let cache = null;\n    return {\n        get: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.get(name);\n        },\n        has: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.has(name);\n        }\n    };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */ function combineCaches(caches) {\n    return {\n        get: (name)=>caches.flatMap((cache)=>cache.get(name) || []),\n        has: (name)=>caches.some((cache)=>cache.has(name))\n    };\n}\nfunction extractApplyCandidates(params) {\n    let candidates = params.split(/[\\s\\t\\n]+/g);\n    if (candidates[candidates.length - 1] === \"!important\") {\n        return [\n            candidates.slice(0, -1),\n            true\n        ];\n    }\n    return [\n        candidates,\n        false\n    ];\n}\nfunction processApply(root, context, localCache) {\n    let applyCandidates = new Set();\n    // Collect all @apply rules and candidates\n    let applies = [];\n    root.walkAtRules(\"apply\", (rule)=>{\n        let [candidates] = extractApplyCandidates(rule.params);\n        for (let util of candidates){\n            applyCandidates.add(util);\n        }\n        applies.push(rule);\n    });\n    // Start the @apply process if we have rules with @apply in them\n    if (applies.length === 0) {\n        return;\n    }\n    // Fill up some caches!\n    let applyClassCache = combineCaches([\n        localCache,\n        buildApplyCache(applyCandidates, context)\n    ]);\n    /**\n   * When we have an apply like this:\n   *\n   * .abc {\n   *    @apply hover:font-bold;\n   * }\n   *\n   * What we essentially will do is resolve to this:\n   *\n   * .abc {\n   *    @apply .hover\\:font-bold:hover {\n   *      font-weight: 500;\n   *    }\n   * }\n   *\n   * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n   * What happens in this function is that we prepend a `.` and escape the candidate.\n   * This will result in `.hover\\:font-bold`\n   * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n   *\n   * @param {string} selector\n   * @param {string} utilitySelectors\n   * @param {string} candidate\n   */ function replaceSelector(selector, utilitySelectors, candidate) {\n        let selectorList = extractSelectors(selector);\n        let utilitySelectorsList = extractSelectors(utilitySelectors);\n        let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);\n        let candidateClass = candidateList.nodes[0].nodes[0];\n        selectorList.each((sel)=>{\n            /** @type {Set<import('postcss-selector-parser').Selector>} */ let replaced = new Set();\n            utilitySelectorsList.each((utilitySelector)=>{\n                let hasReplaced = false;\n                utilitySelector = utilitySelector.clone();\n                utilitySelector.walkClasses((node)=>{\n                    if (node.value !== candidateClass.value) {\n                        return;\n                    }\n                    // Don't replace multiple instances of the same class\n                    // This is theoretically correct but only partially\n                    // We'd need to generate every possible permutation of the replacement\n                    // For example with `.foo + .foo { … }` and `section { @apply foo; }`\n                    // We'd need to generate all of these:\n                    // - `.foo + .foo`\n                    // - `.foo + section`\n                    // - `section + .foo`\n                    // - `section + section`\n                    if (hasReplaced) {\n                        return;\n                    }\n                    // Since you can only `@apply` class names this is sufficient\n                    // We want to replace the matched class name with the selector the user is using\n                    // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`\n                    node.replaceWith(...sel.nodes.map((node)=>node.clone()));\n                    // Record that we did something and we want to use this new selector\n                    replaced.add(utilitySelector);\n                    hasReplaced = true;\n                });\n            });\n            // Sort tag names before class names (but only sort each group (separated by a combinator)\n            // separately and not in total)\n            // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`\n            for (let sel of replaced){\n                let groups = [\n                    []\n                ];\n                for (let node of sel.nodes){\n                    if (node.type === \"combinator\") {\n                        groups.push(node);\n                        groups.push([]);\n                    } else {\n                        let last = groups[groups.length - 1];\n                        last.push(node);\n                    }\n                }\n                sel.nodes = [];\n                for (let group of groups){\n                    if (Array.isArray(group)) {\n                        group.sort((a, b)=>{\n                            if (a.type === \"tag\" && b.type === \"class\") {\n                                return -1;\n                            } else if (a.type === \"class\" && b.type === \"tag\") {\n                                return 1;\n                            } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n                                return -1;\n                            } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n                                return 1;\n                            }\n                            return 0;\n                        });\n                    }\n                    sel.nodes = sel.nodes.concat(group);\n                }\n            }\n            sel.replaceWith(...replaced);\n        });\n        return selectorList.toString();\n    }\n    let perParentApplies = new Map();\n    // Collect all apply candidates and their rules\n    for (let apply of applies){\n        let [candidates] = perParentApplies.get(apply.parent) || [\n            [],\n            apply.source\n        ];\n        perParentApplies.set(apply.parent, [\n            candidates,\n            apply.source\n        ]);\n        let [applyCandidates, important] = extractApplyCandidates(apply.params);\n        if (apply.parent.type === \"atrule\") {\n            if (apply.parent.name === \"screen\") {\n                let screenType = apply.parent.params;\n                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map((c)=>`${screenType}:${c}`).join(\" \")} instead.`);\n            }\n            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n        }\n        for (let applyCandidate of applyCandidates){\n            if ([\n                prefix(context, \"group\"),\n                prefix(context, \"peer\")\n            ].includes(applyCandidate)) {\n                // TODO: Link to specific documentation page with error code.\n                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n            }\n            if (!applyClassCache.has(applyCandidate)) {\n                throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n            }\n            let rules = applyClassCache.get(applyCandidate);\n            candidates.push([\n                applyCandidate,\n                important,\n                rules\n            ]);\n        }\n    }\n    for (let [parent, [candidates, atApplySource]] of perParentApplies){\n        let siblings = [];\n        for (let [applyCandidate, important, rules] of candidates){\n            let potentialApplyCandidates = [\n                applyCandidate,\n                ...extractBaseCandidates([\n                    applyCandidate\n                ], context.tailwindConfig.separator)\n            ];\n            for (let [meta, node] of rules){\n                let parentClasses = extractClasses(parent);\n                let nodeClasses = extractClasses(node);\n                // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n                // So we've split them into groups\n                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();\n                // Add base utility classes from the @apply node to the list of\n                // classes to check whether it intersects and therefore results in a\n                // circular dependency or not.\n                //\n                // E.g.:\n                // .foo {\n                //   @apply hover:a; // This applies \"a\" but with a modifier\n                // }\n                //\n                // We only have to do that with base classes of the `node`, not of the `parent`\n                // E.g.:\n                // .hover\\:foo {\n                //   @apply bar;\n                // }\n                // .bar {\n                //   @apply foo;\n                // }\n                //\n                // This should not result in a circular dependency because we are\n                // just applying `.foo` and the rule above is `.hover\\:foo` which is\n                // unrelated. However, if we were to apply `hover:foo` then we _did_\n                // have to include this one.\n                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));\n                if (intersects) {\n                    throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate}\\` utility here because it creates a circular dependency.`);\n                }\n                let root = _postcss.default.root({\n                    nodes: [\n                        node.clone()\n                    ]\n                });\n                // Make sure every node in the entire tree points back at the @apply rule that generated it\n                root.walk((node)=>{\n                    node.source = atApplySource;\n                });\n                let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n                if (canRewriteSelector) {\n                    root.walkRules((rule)=>{\n                        // Let's imagine you have the following structure:\n                        //\n                        // .foo {\n                        //   @apply bar;\n                        // }\n                        //\n                        // @supports (a: b) {\n                        //   .bar {\n                        //     color: blue\n                        //   }\n                        //\n                        //   .something-unrelated {}\n                        // }\n                        //\n                        // In this case we want to apply `.bar` but it happens to be in\n                        // an atrule node. We clone that node instead of the nested one\n                        // because we still want that @supports rule to be there once we\n                        // applied everything.\n                        //\n                        // However it happens to be that the `.something-unrelated` is\n                        // also in that same shared @supports atrule. This is not good,\n                        // and this should not be there. The good part is that this is\n                        // a clone already and it can be safely removed. The question is\n                        // how do we know we can remove it. Basically what we can do is\n                        // match it against the applyCandidate that you want to apply. If\n                        // it doesn't match the we can safely delete it.\n                        //\n                        // If we didn't do this, then the `replaceSelector` function\n                        // would have replaced this with something that didn't exist and\n                        // therefore it removed the selector altogether. In this specific\n                        // case it would result in `{}` instead of `.something-unrelated {}`\n                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate)) {\n                            rule.remove();\n                            return;\n                        }\n                        // Strip the important selector from the parent selector if at the beginning\n                        let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null;\n                        // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n                        // We do *not* want to do this for user CSS that happens to be structured the same\n                        let isGenerated = parent.raws.tailwind !== undefined;\n                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate);\n                        // And then re-add it if it was removed\n                        if (importantSelector && parentSelector !== parent.selector) {\n                            rule.selector = (0, _applyImportantSelector.applyImportantSelector)(rule.selector, importantSelector);\n                        }\n                        rule.walkDecls((d)=>{\n                            d.important = meta.important || important;\n                        });\n                        // Move pseudo elements to the end of the selector (if necessary)\n                        let selector = (0, _postcssselectorparser.default)().astSync(rule.selector);\n                        selector.each((sel)=>(0, _pseudoElements.movePseudos)(sel));\n                        rule.selector = selector.toString();\n                    });\n                }\n                // It could be that the node we were inserted was removed because the class didn't match\n                // If that was the *only* rule in the parent, then we have nothing add so we skip it\n                if (!root.nodes[0]) {\n                    continue;\n                }\n                // Insert it\n                siblings.push([\n                    meta.sort,\n                    root.nodes[0]\n                ]);\n            }\n        }\n        // Inject the rules, sorted, correctly\n        let nodes = context.offsets.sort(siblings).map((s)=>s[1]);\n        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n        parent.after(nodes);\n    }\n    for (let apply of applies){\n        // If there are left-over declarations, just remove the @apply\n        if (apply.parent.nodes.length > 1) {\n            apply.remove();\n        } else {\n            // The node is empty, drop the full node\n            apply.parent.remove();\n        }\n    }\n    // Do it again, in case we have other `@apply` rules\n    processApply(root, context, localCache);\n}\nfunction expandApplyAtRules(context) {\n    return (root)=>{\n        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));\n        processApply(root, context, localCache);\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}