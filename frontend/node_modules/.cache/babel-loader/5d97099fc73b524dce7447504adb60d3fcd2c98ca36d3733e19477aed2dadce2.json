{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n  args.sort();\n  const value = `[${args.join('-')}]`;\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  input = REPLACEMENTS[input] || input;\n  const opts = {\n    ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n  const bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  const tokens = [bos];\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n  const negate = () => {\n    let count = 1;\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n    if (count % 2 === 0) {\n      return false;\n    }\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n  const extglobOpen = (type, value) => {\n    const token = {\n      ...EXTGLOB_CHARS[value],\n      conditions: 1,\n      inner: ''\n    };\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    extglobs.push(token);\n  };\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n    if (token.type === 'negate') {\n      let extglobStar = star;\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, {\n          ...options,\n          fastpaths: false\n        }).output;\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n      if (next === '.' || next === ';') {\n        continue;\n      }\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = `\\\\${value}`;\n      }\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value\n      });\n      continue;\n    }\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n      decrement('brackets');\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n      prev.value += value;\n      append({\n        value\n      });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value,\n          output: value\n        });\n        continue;\n      }\n      let output = ')';\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += t.output || t.value;\n        }\n      }\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          output = `\\\\${value}`;\n        }\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value,\n          output: ''\n        });\n        continue;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    const token = {\n      type: 'star',\n      value,\n      output: star\n    };\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n    push(token);\n  }\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = {\n    ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = {\n    negated: false,\n    prefix: ''\n  };\n  let star = opts.bash === true ? '.*?' : STAR;\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n      case '**':\n        return nodot + globstar(opts);\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n      default:\n        {\n          const match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          const source = create(match[1]);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n  return source;\n};\nmodule.exports = parse;","map":{"version":3,"names":["constants","require","utils","MAX_LENGTH","POSIX_REGEX_SOURCE","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REPLACEMENTS","expandRange","args","options","sort","value","join","RegExp","ex","map","v","escapeRegex","syntaxError","type","char","parse","input","TypeError","opts","max","maxLength","Math","min","len","length","SyntaxError","bos","output","prepend","tokens","capture","win32","isWindows","PLATFORM_CHARS","globChars","EXTGLOB_CHARS","extglobChars","DOT_LITERAL","PLUS_LITERAL","SLASH_LITERAL","ONE_CHAR","DOTS_SLASH","NO_DOT","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK","QMARK_NO_DOT","STAR","START_ANCHOR","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","state","index","start","consumed","prefix","backtrack","negated","brackets","braces","parens","quotes","removePrefix","extglobs","stack","prev","eos","peek","n","advance","remaining","slice","consume","num","append","token","negate","count","increment","push","decrement","pop","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","open","extglobClose","close","rest","extglobStar","includes","test","expression","fastpaths","negatedExtglob","backslashes","replace","m","esc","chars","first","repeat","unescape","contains","wrapOutput","next","match","exec","slashes","posix","idx","lastIndexOf","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","i","unshift","comma","out","toks","t","isGroup","supportsLookbehinds","Error","nonegate","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","escapeLast","suffix","NO_DOTS","slashDot","create","str","source","module","exports"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/picomatch/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}