{"ast":null,"code":"import { ContextualKeyword } from \"../parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\n\n/**\n * Get information about the class fields for this class, given a token processor pointing to the\n * open-brace at the start of the class.\n */\nexport default function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms) {\n  const snapshot = tokens.snapshot();\n  const headerInfo = processClassHeader(tokens);\n  let constructorInitializerStatements = [];\n  const instanceInitializerNames = [];\n  const staticInitializerNames = [];\n  let constructorInsertPos = null;\n  const fields = [];\n  const rangesToRemove = [];\n  const classContextId = tokens.currentToken().contextId;\n  if (classContextId == null) {\n    throw new Error(\"Expected non-null class context ID on class open-brace.\");\n  }\n  tokens.nextToken();\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n    if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {\n      ({\n        constructorInitializerStatements,\n        constructorInsertPos\n      } = processConstructor(tokens));\n    } else if (tokens.matches1(tt.semi)) {\n      if (!disableESTransforms) {\n        rangesToRemove.push({\n          start: tokens.currentIndex(),\n          end: tokens.currentIndex() + 1\n        });\n      }\n      tokens.nextToken();\n    } else if (tokens.currentToken().isType) {\n      tokens.nextToken();\n    } else {\n      // Either a method or a field. Skip to the identifier part.\n      const statementStartIndex = tokens.currentIndex();\n      let isStatic = false;\n      let isESPrivate = false;\n      let isDeclareOrAbstract = false;\n      while (isAccessModifier(tokens.currentToken())) {\n        if (tokens.matches1(tt._static)) {\n          isStatic = true;\n        }\n        if (tokens.matches1(tt.hash)) {\n          isESPrivate = true;\n        }\n        if (tokens.matches1(tt._declare) || tokens.matches1(tt._abstract)) {\n          isDeclareOrAbstract = true;\n        }\n        tokens.nextToken();\n      }\n      if (isStatic && tokens.matches1(tt.braceL)) {\n        // This is a static block, so don't process it in any special way.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      if (isESPrivate) {\n        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {\n        ({\n          constructorInitializerStatements,\n          constructorInsertPos\n        } = processConstructor(tokens));\n        continue;\n      }\n      const nameStartIndex = tokens.currentIndex();\n      skipFieldName(tokens);\n      if (tokens.matches1(tt.lessThan) || tokens.matches1(tt.parenL)) {\n        // This is a method, so nothing to process.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      // There might be a type annotation that we need to skip.\n      while (tokens.currentToken().isType) {\n        tokens.nextToken();\n      }\n      if (tokens.matches1(tt.eq)) {\n        const equalsIndex = tokens.currentIndex();\n        // This is an initializer, so we need to wrap in an initializer method.\n        const valueEnd = tokens.currentToken().rhsEndIndex;\n        if (valueEnd == null) {\n          throw new Error(\"Expected rhsEndIndex on class field assignment.\");\n        }\n        tokens.nextToken();\n        while (tokens.currentIndex() < valueEnd) {\n          rootTransformer.processToken();\n        }\n        let initializerName;\n        if (isStatic) {\n          initializerName = nameManager.claimFreeName(\"__initStatic\");\n          staticInitializerNames.push(initializerName);\n        } else {\n          initializerName = nameManager.claimFreeName(\"__init\");\n          instanceInitializerNames.push(initializerName);\n        }\n        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.\n        fields.push({\n          initializerName,\n          equalsIndex,\n          start: nameStartIndex,\n          end: tokens.currentIndex()\n        });\n      } else if (!disableESTransforms || isDeclareOrAbstract) {\n        // This is a regular field declaration, like `x;`. With the class transform enabled, we just\n        // remove the line so that no output is produced. With the class transform disabled, we\n        // usually want to preserve the declaration (but still strip types), but if the `declare`\n        // or `abstract` keyword is specified, we should remove the line to avoid initializing the\n        // value to undefined.\n        rangesToRemove.push({\n          start: statementStartIndex,\n          end: tokens.currentIndex()\n        });\n      }\n    }\n  }\n  tokens.restoreToSnapshot(snapshot);\n  if (disableESTransforms) {\n    // With ES transforms disabled, we don't want to transform regular class\n    // field declarations, and we don't need to do any additional tricks to\n    // reference the constructor for static init, but we still need to transform\n    // TypeScript field initializers defined as constructor parameters and we\n    // still need to remove `declare` fields. For now, we run the same code\n    // path but omit any field information, as if the class had no field\n    // declarations. In the future, when we fully drop the class fields\n    // transform, we can simplify this code significantly.\n    return {\n      headerInfo,\n      constructorInitializerStatements,\n      instanceInitializerNames: [],\n      staticInitializerNames: [],\n      constructorInsertPos,\n      fields: [],\n      rangesToRemove\n    };\n  } else {\n    return {\n      headerInfo,\n      constructorInitializerStatements,\n      instanceInitializerNames,\n      staticInitializerNames,\n      constructorInsertPos,\n      fields,\n      rangesToRemove\n    };\n  }\n}\n\n/**\n * Move the token processor to the next method/field in the class.\n *\n * To do that, we seek forward to the next start of a class name (either an open\n * bracket or an identifier, or the closing curly brace), then seek backward to\n * include any access modifiers.\n */\nfunction skipToNextClassElement(tokens, classContextId) {\n  tokens.nextToken();\n  while (tokens.currentToken().contextId !== classContextId) {\n    tokens.nextToken();\n  }\n  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {\n    tokens.previousToken();\n  }\n}\nfunction processClassHeader(tokens) {\n  const classToken = tokens.currentToken();\n  const contextId = classToken.contextId;\n  if (contextId == null) {\n    throw new Error(\"Expected context ID on class token.\");\n  }\n  const isExpression = classToken.isExpression;\n  if (isExpression == null) {\n    throw new Error(\"Expected isExpression on class token.\");\n  }\n  let className = null;\n  let hasSuperclass = false;\n  tokens.nextToken();\n  if (tokens.matches1(tt.name)) {\n    className = tokens.identifierName();\n  }\n  while (!tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n    // If this has a superclass, there will always be an `extends` token. If it doesn't have a\n    // superclass, only type parameters and `implements` clauses can show up here, all of which\n    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count\n    // as having a superclass.\n    if (tokens.matches1(tt._extends) && !tokens.currentToken().isType) {\n      hasSuperclass = true;\n    }\n    tokens.nextToken();\n  }\n  return {\n    isExpression,\n    className,\n    hasSuperclass\n  };\n}\n\n/**\n * Extract useful information out of a constructor, starting at the \"constructor\" name.\n */\nfunction processConstructor(tokens) {\n  const constructorInitializerStatements = [];\n  tokens.nextToken();\n  const constructorContextId = tokens.currentToken().contextId;\n  if (constructorContextId == null) {\n    throw new Error(\"Expected context ID on open-paren starting constructor params.\");\n  }\n  // Advance through parameters looking for access modifiers.\n  while (!tokens.matchesContextIdAndLabel(tt.parenR, constructorContextId)) {\n    if (tokens.currentToken().contextId === constructorContextId) {\n      // Current token is an open paren or comma just before a param, so check\n      // that param for access modifiers.\n      tokens.nextToken();\n      if (isAccessModifier(tokens.currentToken())) {\n        tokens.nextToken();\n        while (isAccessModifier(tokens.currentToken())) {\n          tokens.nextToken();\n        }\n        const token = tokens.currentToken();\n        if (token.type !== tt.name) {\n          throw new Error(\"Expected identifier after access modifiers in constructor arg.\");\n        }\n        const name = tokens.identifierNameForToken(token);\n        constructorInitializerStatements.push(`this.${name} = ${name}`);\n      }\n    } else {\n      tokens.nextToken();\n    }\n  }\n  // )\n  tokens.nextToken();\n  // Constructor type annotations are invalid, but skip them anyway since\n  // they're easy to skip.\n  while (tokens.currentToken().isType) {\n    tokens.nextToken();\n  }\n  let constructorInsertPos = tokens.currentIndex();\n\n  // Advance through body looking for a super call.\n  let foundSuperCall = false;\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, constructorContextId)) {\n    if (!foundSuperCall && tokens.matches2(tt._super, tt.parenL)) {\n      tokens.nextToken();\n      const superCallContextId = tokens.currentToken().contextId;\n      if (superCallContextId == null) {\n        throw new Error(\"Expected a context ID on the super call\");\n      }\n      while (!tokens.matchesContextIdAndLabel(tt.parenR, superCallContextId)) {\n        tokens.nextToken();\n      }\n      constructorInsertPos = tokens.currentIndex();\n      foundSuperCall = true;\n    }\n    tokens.nextToken();\n  }\n  // }\n  tokens.nextToken();\n  return {\n    constructorInitializerStatements,\n    constructorInsertPos\n  };\n}\n\n/**\n * Determine if this is any token that can go before the name in a method/field.\n */\nfunction isAccessModifier(token) {\n  return [tt._async, tt._get, tt._set, tt.plus, tt.minus, tt._readonly, tt._static, tt._public, tt._private, tt._protected, tt._override, tt._abstract, tt.star, tt._declare, tt.hash].includes(token.type);\n}\n\n/**\n * The next token or set of tokens is either an identifier or an expression in square brackets, for\n * a method or field name.\n */\nfunction skipFieldName(tokens) {\n  if (tokens.matches1(tt.bracketL)) {\n    const startToken = tokens.currentToken();\n    const classContextId = startToken.contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected class context ID on computed name open bracket.\");\n    }\n    while (!tokens.matchesContextIdAndLabel(tt.bracketR, classContextId)) {\n      tokens.nextToken();\n    }\n    tokens.nextToken();\n  } else {\n    tokens.nextToken();\n  }\n}","map":{"version":3,"names":["ContextualKeyword","TokenType","tt","getClassInfo","rootTransformer","tokens","nameManager","disableESTransforms","snapshot","headerInfo","processClassHeader","constructorInitializerStatements","instanceInitializerNames","staticInitializerNames","constructorInsertPos","fields","rangesToRemove","classContextId","currentToken","contextId","Error","nextToken","matchesContextIdAndLabel","braceR","matchesContextual","_constructor","isType","processConstructor","matches1","semi","push","start","currentIndex","end","statementStartIndex","isStatic","isESPrivate","isDeclareOrAbstract","isAccessModifier","_static","hash","_declare","_abstract","braceL","skipToNextClassElement","nameStartIndex","skipFieldName","lessThan","parenL","eq","equalsIndex","valueEnd","rhsEndIndex","processToken","initializerName","claimFreeName","restoreToSnapshot","tokenAtRelativeIndex","previousToken","classToken","isExpression","className","hasSuperclass","name","identifierName","_extends","constructorContextId","parenR","token","type","identifierNameForToken","foundSuperCall","matches2","_super","superCallContextId","_async","_get","_set","plus","minus","_readonly","_public","_private","_protected","_override","star","includes","bracketL","startToken","bracketR"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/util/getClassInfo.js"],"sourcesContent":["\n\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Get information about the class fields for this class, given a token processor pointing to the\n * open-brace at the start of the class.\n */\nexport default function getClassInfo(\n  rootTransformer,\n  tokens,\n  nameManager,\n  disableESTransforms,\n) {\n  const snapshot = tokens.snapshot();\n\n  const headerInfo = processClassHeader(tokens);\n\n  let constructorInitializerStatements = [];\n  const instanceInitializerNames = [];\n  const staticInitializerNames = [];\n  let constructorInsertPos = null;\n  const fields = [];\n  const rangesToRemove = [];\n\n  const classContextId = tokens.currentToken().contextId;\n  if (classContextId == null) {\n    throw new Error(\"Expected non-null class context ID on class open-brace.\");\n  }\n\n  tokens.nextToken();\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {\n    if (tokens.matchesContextual(ContextualKeyword._constructor) && !tokens.currentToken().isType) {\n      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n    } else if (tokens.matches1(tt.semi)) {\n      if (!disableESTransforms) {\n        rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});\n      }\n      tokens.nextToken();\n    } else if (tokens.currentToken().isType) {\n      tokens.nextToken();\n    } else {\n      // Either a method or a field. Skip to the identifier part.\n      const statementStartIndex = tokens.currentIndex();\n      let isStatic = false;\n      let isESPrivate = false;\n      let isDeclareOrAbstract = false;\n      while (isAccessModifier(tokens.currentToken())) {\n        if (tokens.matches1(tt._static)) {\n          isStatic = true;\n        }\n        if (tokens.matches1(tt.hash)) {\n          isESPrivate = true;\n        }\n        if (tokens.matches1(tt._declare) || tokens.matches1(tt._abstract)) {\n          isDeclareOrAbstract = true;\n        }\n        tokens.nextToken();\n      }\n      if (isStatic && tokens.matches1(tt.braceL)) {\n        // This is a static block, so don't process it in any special way.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      if (isESPrivate) {\n        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      if (\n        tokens.matchesContextual(ContextualKeyword._constructor) &&\n        !tokens.currentToken().isType\n      ) {\n        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));\n        continue;\n      }\n\n      const nameStartIndex = tokens.currentIndex();\n      skipFieldName(tokens);\n      if (tokens.matches1(tt.lessThan) || tokens.matches1(tt.parenL)) {\n        // This is a method, so nothing to process.\n        skipToNextClassElement(tokens, classContextId);\n        continue;\n      }\n      // There might be a type annotation that we need to skip.\n      while (tokens.currentToken().isType) {\n        tokens.nextToken();\n      }\n      if (tokens.matches1(tt.eq)) {\n        const equalsIndex = tokens.currentIndex();\n        // This is an initializer, so we need to wrap in an initializer method.\n        const valueEnd = tokens.currentToken().rhsEndIndex;\n        if (valueEnd == null) {\n          throw new Error(\"Expected rhsEndIndex on class field assignment.\");\n        }\n        tokens.nextToken();\n        while (tokens.currentIndex() < valueEnd) {\n          rootTransformer.processToken();\n        }\n        let initializerName;\n        if (isStatic) {\n          initializerName = nameManager.claimFreeName(\"__initStatic\");\n          staticInitializerNames.push(initializerName);\n        } else {\n          initializerName = nameManager.claimFreeName(\"__init\");\n          instanceInitializerNames.push(initializerName);\n        }\n        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.\n        fields.push({\n          initializerName,\n          equalsIndex,\n          start: nameStartIndex,\n          end: tokens.currentIndex(),\n        });\n      } else if (!disableESTransforms || isDeclareOrAbstract) {\n        // This is a regular field declaration, like `x;`. With the class transform enabled, we just\n        // remove the line so that no output is produced. With the class transform disabled, we\n        // usually want to preserve the declaration (but still strip types), but if the `declare`\n        // or `abstract` keyword is specified, we should remove the line to avoid initializing the\n        // value to undefined.\n        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});\n      }\n    }\n  }\n\n  tokens.restoreToSnapshot(snapshot);\n  if (disableESTransforms) {\n    // With ES transforms disabled, we don't want to transform regular class\n    // field declarations, and we don't need to do any additional tricks to\n    // reference the constructor for static init, but we still need to transform\n    // TypeScript field initializers defined as constructor parameters and we\n    // still need to remove `declare` fields. For now, we run the same code\n    // path but omit any field information, as if the class had no field\n    // declarations. In the future, when we fully drop the class fields\n    // transform, we can simplify this code significantly.\n    return {\n      headerInfo,\n      constructorInitializerStatements,\n      instanceInitializerNames: [],\n      staticInitializerNames: [],\n      constructorInsertPos,\n      fields: [],\n      rangesToRemove,\n    };\n  } else {\n    return {\n      headerInfo,\n      constructorInitializerStatements,\n      instanceInitializerNames,\n      staticInitializerNames,\n      constructorInsertPos,\n      fields,\n      rangesToRemove,\n    };\n  }\n}\n\n/**\n * Move the token processor to the next method/field in the class.\n *\n * To do that, we seek forward to the next start of a class name (either an open\n * bracket or an identifier, or the closing curly brace), then seek backward to\n * include any access modifiers.\n */\nfunction skipToNextClassElement(tokens, classContextId) {\n  tokens.nextToken();\n  while (tokens.currentToken().contextId !== classContextId) {\n    tokens.nextToken();\n  }\n  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {\n    tokens.previousToken();\n  }\n}\n\nfunction processClassHeader(tokens) {\n  const classToken = tokens.currentToken();\n  const contextId = classToken.contextId;\n  if (contextId == null) {\n    throw new Error(\"Expected context ID on class token.\");\n  }\n  const isExpression = classToken.isExpression;\n  if (isExpression == null) {\n    throw new Error(\"Expected isExpression on class token.\");\n  }\n  let className = null;\n  let hasSuperclass = false;\n  tokens.nextToken();\n  if (tokens.matches1(tt.name)) {\n    className = tokens.identifierName();\n  }\n  while (!tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {\n    // If this has a superclass, there will always be an `extends` token. If it doesn't have a\n    // superclass, only type parameters and `implements` clauses can show up here, all of which\n    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count\n    // as having a superclass.\n    if (tokens.matches1(tt._extends) && !tokens.currentToken().isType) {\n      hasSuperclass = true;\n    }\n    tokens.nextToken();\n  }\n  return {isExpression, className, hasSuperclass};\n}\n\n/**\n * Extract useful information out of a constructor, starting at the \"constructor\" name.\n */\nfunction processConstructor(tokens)\n\n\n {\n  const constructorInitializerStatements = [];\n\n  tokens.nextToken();\n  const constructorContextId = tokens.currentToken().contextId;\n  if (constructorContextId == null) {\n    throw new Error(\"Expected context ID on open-paren starting constructor params.\");\n  }\n  // Advance through parameters looking for access modifiers.\n  while (!tokens.matchesContextIdAndLabel(tt.parenR, constructorContextId)) {\n    if (tokens.currentToken().contextId === constructorContextId) {\n      // Current token is an open paren or comma just before a param, so check\n      // that param for access modifiers.\n      tokens.nextToken();\n      if (isAccessModifier(tokens.currentToken())) {\n        tokens.nextToken();\n        while (isAccessModifier(tokens.currentToken())) {\n          tokens.nextToken();\n        }\n        const token = tokens.currentToken();\n        if (token.type !== tt.name) {\n          throw new Error(\"Expected identifier after access modifiers in constructor arg.\");\n        }\n        const name = tokens.identifierNameForToken(token);\n        constructorInitializerStatements.push(`this.${name} = ${name}`);\n      }\n    } else {\n      tokens.nextToken();\n    }\n  }\n  // )\n  tokens.nextToken();\n  // Constructor type annotations are invalid, but skip them anyway since\n  // they're easy to skip.\n  while (tokens.currentToken().isType) {\n    tokens.nextToken();\n  }\n  let constructorInsertPos = tokens.currentIndex();\n\n  // Advance through body looking for a super call.\n  let foundSuperCall = false;\n  while (!tokens.matchesContextIdAndLabel(tt.braceR, constructorContextId)) {\n    if (!foundSuperCall && tokens.matches2(tt._super, tt.parenL)) {\n      tokens.nextToken();\n      const superCallContextId = tokens.currentToken().contextId;\n      if (superCallContextId == null) {\n        throw new Error(\"Expected a context ID on the super call\");\n      }\n      while (!tokens.matchesContextIdAndLabel(tt.parenR, superCallContextId)) {\n        tokens.nextToken();\n      }\n      constructorInsertPos = tokens.currentIndex();\n      foundSuperCall = true;\n    }\n    tokens.nextToken();\n  }\n  // }\n  tokens.nextToken();\n\n  return {constructorInitializerStatements, constructorInsertPos};\n}\n\n/**\n * Determine if this is any token that can go before the name in a method/field.\n */\nfunction isAccessModifier(token) {\n  return [\n    tt._async,\n    tt._get,\n    tt._set,\n    tt.plus,\n    tt.minus,\n    tt._readonly,\n    tt._static,\n    tt._public,\n    tt._private,\n    tt._protected,\n    tt._override,\n    tt._abstract,\n    tt.star,\n    tt._declare,\n    tt.hash,\n  ].includes(token.type);\n}\n\n/**\n * The next token or set of tokens is either an identifier or an expression in square brackets, for\n * a method or field name.\n */\nfunction skipFieldName(tokens) {\n  if (tokens.matches1(tt.bracketL)) {\n    const startToken = tokens.currentToken();\n    const classContextId = startToken.contextId;\n    if (classContextId == null) {\n      throw new Error(\"Expected class context ID on computed name open bracket.\");\n    }\n    while (!tokens.matchesContextIdAndLabel(tt.bracketR, classContextId)) {\n      tokens.nextToken();\n    }\n    tokens.nextToken();\n  } else {\n    tokens.nextToken();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}