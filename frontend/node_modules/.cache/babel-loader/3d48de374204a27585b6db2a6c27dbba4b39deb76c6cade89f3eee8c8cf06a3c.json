{"ast":null,"code":"// @ts-check\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  parseCandidateFiles: function () {\n    return parseCandidateFiles;\n  },\n  resolvedChangedContent: function () {\n    return resolvedChangedContent;\n  }\n});\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"path\"));\nconst _isglob = /*#__PURE__*/_interop_require_default(require(\"is-glob\"));\nconst _fastglob = /*#__PURE__*/_interop_require_default(require(\"fast-glob\"));\nconst _normalizepath = /*#__PURE__*/_interop_require_default(require(\"normalize-path\"));\nconst _parseGlob = require(\"../util/parseGlob\");\nconst _sharedState = require(\"./sharedState\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction parseCandidateFiles(context, tailwindConfig) {\n  let files = tailwindConfig.content.files;\n  // Normalize the file globs\n  files = files.filter(filePath => typeof filePath === \"string\");\n  files = files.map(_normalizepath.default);\n  // Split into included and excluded globs\n  let tasks = _fastglob.default.generateTasks(files);\n  /** @type {ContentPath[]} */\n  let included = [];\n  /** @type {ContentPath[]} */\n  let excluded = [];\n  for (const task of tasks) {\n    included.push(...task.positive.map(filePath => parseFilePath(filePath, false)));\n    excluded.push(...task.negative.map(filePath => parseFilePath(filePath, true)));\n  }\n  let paths = [...included, ...excluded];\n  // Resolve paths relative to the config file or cwd\n  paths = resolveRelativePaths(context, paths);\n  // Resolve symlinks if possible\n  paths = paths.flatMap(resolvePathSymlinks);\n  // Update cached patterns\n  paths = paths.map(resolveGlobPattern);\n  return paths;\n}\n/**\n *\n * @param {string} filePath\n * @param {boolean} ignore\n * @returns {ContentPath}\n */\nfunction parseFilePath(filePath, ignore) {\n  let contentPath = {\n    original: filePath,\n    base: filePath,\n    ignore,\n    pattern: filePath,\n    glob: null\n  };\n  if ((0, _isglob.default)(filePath)) {\n    Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));\n  }\n  return contentPath;\n}\n/**\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath}\n */\nfunction resolveGlobPattern(contentPath) {\n  // This is required for Windows support to properly pick up Glob paths.\n  // Afaik, this technically shouldn't be needed but there's probably\n  // some internal, direct path matching with a normalized path in\n  // a package which can't handle mixed directory separators\n  let base = (0, _normalizepath.default)(contentPath.base);\n  // If the user's file path contains any special characters (like parens) for instance fast-glob\n  // is like \"OOOH SHINY\" and treats them as such. So we have to escape the base path to fix this\n  base = _fastglob.default.escapePath(base);\n  contentPath.pattern = contentPath.glob ? `${base}/${contentPath.glob}` : base;\n  contentPath.pattern = contentPath.ignore ? `!${contentPath.pattern}` : contentPath.pattern;\n  return contentPath;\n}\n/**\n * Resolve each path relative to the config file (when possible) if the experimental flag is enabled\n * Otherwise, resolve relative to the current working directory\n *\n * @param {any} context\n * @param {ContentPath[]} contentPaths\n * @returns {ContentPath[]}\n */\nfunction resolveRelativePaths(context, contentPaths) {\n  let resolveFrom = [];\n  // Resolve base paths relative to the config file (when possible) if the experimental flag is enabled\n  if (context.userConfigPath && context.tailwindConfig.content.relative) {\n    resolveFrom = [_path.default.dirname(context.userConfigPath)];\n  }\n  return contentPaths.map(contentPath => {\n    contentPath.base = _path.default.resolve(...resolveFrom, contentPath.base);\n    return contentPath;\n  });\n}\n/**\n * Resolve the symlink for the base directory / file in each path\n * These are added as additional dependencies to watch for changes because\n * some tools (like webpack) will only watch the actual file or directory\n * but not the symlink itself even in projects that use monorepos.\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath[]}\n */\nfunction resolvePathSymlinks(contentPath) {\n  let paths = [contentPath];\n  try {\n    let resolvedPath = _fs.default.realpathSync(contentPath.base);\n    if (resolvedPath !== contentPath.base) {\n      paths.push({\n        ...contentPath,\n        base: resolvedPath\n      });\n    }\n  } catch {\n    // TODO: log this?\n  }\n  return paths;\n}\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n  let changedContent = context.tailwindConfig.content.files.filter(item => typeof item.raw === \"string\").map(({\n    raw,\n    extension = \"html\"\n  }) => ({\n    content: raw,\n    extension\n  }));\n  let [changedFiles, mTimesToCommit] = resolveChangedFiles(candidateFiles, fileModifiedMap);\n  for (let changedFile of changedFiles) {\n    let extension = _path.default.extname(changedFile).slice(1);\n    changedContent.push({\n      file: changedFile,\n      extension\n    });\n  }\n  return [changedContent, mTimesToCommit];\n}\n/**\n *\n * @param {ContentPath[]} candidateFiles\n * @param {Map<string, number>} fileModifiedMap\n * @returns {[Set<string>, Map<string, number>]}\n */\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n  let paths = candidateFiles.map(contentPath => contentPath.pattern);\n  let mTimesToCommit = new Map();\n  let changedFiles = new Set();\n  _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n  let files = _fastglob.default.sync(paths, {\n    absolute: true\n  });\n  for (let file of files) {\n    let prevModified = fileModifiedMap.get(file) || -Infinity;\n    let modified = _fs.default.statSync(file).mtimeMs;\n    if (modified > prevModified) {\n      changedFiles.add(file);\n      mTimesToCommit.set(file, modified);\n    }\n  }\n  _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n  return [changedFiles, mTimesToCommit];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","parseCandidateFiles","resolvedChangedContent","_fs","_interop_require_default","require","_path","_isglob","_fastglob","_normalizepath","_parseGlob","_sharedState","obj","__esModule","default","context","tailwindConfig","files","content","filter","filePath","map","tasks","generateTasks","included","excluded","task","push","positive","parseFilePath","negative","paths","resolveRelativePaths","flatMap","resolvePathSymlinks","resolveGlobPattern","ignore","contentPath","original","base","pattern","glob","assign","parseGlob","escapePath","contentPaths","resolveFrom","userConfigPath","relative","dirname","resolve","resolvedPath","realpathSync","candidateFiles","fileModifiedMap","changedContent","item","raw","extension","changedFiles","mTimesToCommit","resolveChangedFiles","changedFile","extname","slice","file","Map","Set","env","DEBUG","console","time","sync","absolute","prevModified","Infinity","modified","statSync","mtimeMs","add","set","timeEnd"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/lib/content.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    parseCandidateFiles: function() {\n        return parseCandidateFiles;\n    },\n    resolvedChangedContent: function() {\n        return resolvedChangedContent;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _isglob = /*#__PURE__*/ _interop_require_default(require(\"is-glob\"));\nconst _fastglob = /*#__PURE__*/ _interop_require_default(require(\"fast-glob\"));\nconst _normalizepath = /*#__PURE__*/ _interop_require_default(require(\"normalize-path\"));\nconst _parseGlob = require(\"../util/parseGlob\");\nconst _sharedState = require(\"./sharedState\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction parseCandidateFiles(context, tailwindConfig) {\n    let files = tailwindConfig.content.files;\n    // Normalize the file globs\n    files = files.filter((filePath)=>typeof filePath === \"string\");\n    files = files.map(_normalizepath.default);\n    // Split into included and excluded globs\n    let tasks = _fastglob.default.generateTasks(files);\n    /** @type {ContentPath[]} */ let included = [];\n    /** @type {ContentPath[]} */ let excluded = [];\n    for (const task of tasks){\n        included.push(...task.positive.map((filePath)=>parseFilePath(filePath, false)));\n        excluded.push(...task.negative.map((filePath)=>parseFilePath(filePath, true)));\n    }\n    let paths = [\n        ...included,\n        ...excluded\n    ];\n    // Resolve paths relative to the config file or cwd\n    paths = resolveRelativePaths(context, paths);\n    // Resolve symlinks if possible\n    paths = paths.flatMap(resolvePathSymlinks);\n    // Update cached patterns\n    paths = paths.map(resolveGlobPattern);\n    return paths;\n}\n/**\n *\n * @param {string} filePath\n * @param {boolean} ignore\n * @returns {ContentPath}\n */ function parseFilePath(filePath, ignore) {\n    let contentPath = {\n        original: filePath,\n        base: filePath,\n        ignore,\n        pattern: filePath,\n        glob: null\n    };\n    if ((0, _isglob.default)(filePath)) {\n        Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));\n    }\n    return contentPath;\n}\n/**\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath}\n */ function resolveGlobPattern(contentPath) {\n    // This is required for Windows support to properly pick up Glob paths.\n    // Afaik, this technically shouldn't be needed but there's probably\n    // some internal, direct path matching with a normalized path in\n    // a package which can't handle mixed directory separators\n    let base = (0, _normalizepath.default)(contentPath.base);\n    // If the user's file path contains any special characters (like parens) for instance fast-glob\n    // is like \"OOOH SHINY\" and treats them as such. So we have to escape the base path to fix this\n    base = _fastglob.default.escapePath(base);\n    contentPath.pattern = contentPath.glob ? `${base}/${contentPath.glob}` : base;\n    contentPath.pattern = contentPath.ignore ? `!${contentPath.pattern}` : contentPath.pattern;\n    return contentPath;\n}\n/**\n * Resolve each path relative to the config file (when possible) if the experimental flag is enabled\n * Otherwise, resolve relative to the current working directory\n *\n * @param {any} context\n * @param {ContentPath[]} contentPaths\n * @returns {ContentPath[]}\n */ function resolveRelativePaths(context, contentPaths) {\n    let resolveFrom = [];\n    // Resolve base paths relative to the config file (when possible) if the experimental flag is enabled\n    if (context.userConfigPath && context.tailwindConfig.content.relative) {\n        resolveFrom = [\n            _path.default.dirname(context.userConfigPath)\n        ];\n    }\n    return contentPaths.map((contentPath)=>{\n        contentPath.base = _path.default.resolve(...resolveFrom, contentPath.base);\n        return contentPath;\n    });\n}\n/**\n * Resolve the symlink for the base directory / file in each path\n * These are added as additional dependencies to watch for changes because\n * some tools (like webpack) will only watch the actual file or directory\n * but not the symlink itself even in projects that use monorepos.\n *\n * @param {ContentPath} contentPath\n * @returns {ContentPath[]}\n */ function resolvePathSymlinks(contentPath) {\n    let paths = [\n        contentPath\n    ];\n    try {\n        let resolvedPath = _fs.default.realpathSync(contentPath.base);\n        if (resolvedPath !== contentPath.base) {\n            paths.push({\n                ...contentPath,\n                base: resolvedPath\n            });\n        }\n    } catch  {\n    // TODO: log this?\n    }\n    return paths;\n}\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n    let changedContent = context.tailwindConfig.content.files.filter((item)=>typeof item.raw === \"string\").map(({ raw , extension =\"html\"  })=>({\n            content: raw,\n            extension\n        }));\n    let [changedFiles, mTimesToCommit] = resolveChangedFiles(candidateFiles, fileModifiedMap);\n    for (let changedFile of changedFiles){\n        let extension = _path.default.extname(changedFile).slice(1);\n        changedContent.push({\n            file: changedFile,\n            extension\n        });\n    }\n    return [\n        changedContent,\n        mTimesToCommit\n    ];\n}\n/**\n *\n * @param {ContentPath[]} candidateFiles\n * @param {Map<string, number>} fileModifiedMap\n * @returns {[Set<string>, Map<string, number>]}\n */ function resolveChangedFiles(candidateFiles, fileModifiedMap) {\n    let paths = candidateFiles.map((contentPath)=>contentPath.pattern);\n    let mTimesToCommit = new Map();\n    let changedFiles = new Set();\n    _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n    let files = _fastglob.default.sync(paths, {\n        absolute: true\n    });\n    for (let file of files){\n        let prevModified = fileModifiedMap.get(file) || -Infinity;\n        let modified = _fs.default.statSync(file).mtimeMs;\n        if (modified > prevModified) {\n            changedFiles.add(file);\n            mTimesToCommit.set(file, modified);\n        }\n    }\n    _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n    return [\n        changedFiles,\n        mTimesToCommit\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}