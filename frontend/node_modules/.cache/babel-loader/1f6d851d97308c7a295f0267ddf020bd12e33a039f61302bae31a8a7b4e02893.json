{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.FIELDS = void 0;\nexports[\"default\"] = tokenize;\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\nvar _unescapable, _wordDelimiters;\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n  do {\n    code = css.charCodeAt(next);\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n  return next - 1;\n}\n\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n  if (unescapable[code]) {\n    // just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0;\n    // consume up to 6 hex chars\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6);\n    // if fewer than 6 hex chars, a trailing space ends the escape\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n  return next;\n}\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n    length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n  while (start < length) {\n    code = css.charCodeAt(start);\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n\n      // Consume these characters as single tokens.\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n          escapePos = next;\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n        end = next + 1;\n        break;\n    }\n\n    // Ensure that the token structure remains consistent\n    tokens.push([tokenType,\n    // [0] Token type\n    line,\n    // [1] Starting line\n    start - offset,\n    // [2] Starting column\n    endLine,\n    // [3] Ending line\n    endColumn,\n    // [4] Ending column\n    start,\n    // [5] Start position / Source index\n    end // [6] End position\n    ]);\n\n    // Reset offset for the next token\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n    start = end;\n  }\n  return tokens;\n}","map":{"version":3,"names":["exports","__esModule","FIELDS","tokenize","t","_interopRequireWildcard","require","_unescapable","_wordDelimiters","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","unescapable","tab","newline","cr","feed","wordDelimiters","space","ampersand","asterisk","bang","comma","colon","semicolon","openParenthesis","closeParenthesis","openSquare","closeSquare","singleQuote","doubleQuote","plus","pipe","tilde","greaterThan","equals","dollar","caret","slash","hex","hexChars","i","length","charCodeAt","consumeWord","css","start","next","code","backslash","consumeEscape","hexDigits","TYPE","START_LINE","START_COL","END_LINE","END_COL","START_POS","END_POS","input","tokens","valueOf","_css","offset","line","end","content","endColumn","endLine","escaped","escapePos","last","lines","nextLine","nextOffset","quote","tokenType","unclosed","what","fix","safe","error","combinator","indexOf","str","slice","split","comment","word","push"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/postcss-selector-parser/dist/tokenize.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.FIELDS = void 0;\nexports[\"default\"] = tokenize;\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\nvar _unescapable, _wordDelimiters;\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n  do {\n    code = css.charCodeAt(next);\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n  return next - 1;\n}\n\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n  if (unescapable[code]) {\n    // just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0;\n    // consume up to 6 hex chars\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6);\n    // if fewer than 6 hex chars, a trailing space ends the escape\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n  return next;\n}\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n    length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n  while (start < length) {\n    code = css.charCodeAt(start);\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n\n      // Consume these characters as single tokens.\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n          escapePos = next;\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n        end = next + 1;\n        break;\n    }\n\n    // Ensure that the token structure remains consistent\n    tokens.push([tokenType,\n    // [0] Token type\n    line,\n    // [1] Starting line\n    start - offset,\n    // [2] Starting column\n    endLine,\n    // [3] Ending line\n    endColumn,\n    // [4] Ending column\n    start,\n    // [5] Start position / Source index\n    end // [6] End position\n    ]);\n\n    // Reset offset for the next token\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n    start = end;\n  }\n  return tokens;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}