{"ast":null,"code":"const {\n  Rule,\n  AtRule\n} = require('postcss');\nlet parser = require('postcss-selector-parser');\n\n/**\n * Run a selector string through postcss-selector-parser\n */\nfunction parse(rawSelector, rule) {\n  let nodes;\n  try {\n    parser(parsed => {\n      nodes = parsed;\n    }).processSync(rawSelector);\n  } catch (e) {\n    if (rawSelector.includes(':')) {\n      throw rule ? rule.error('Missed semicolon') : e;\n    } else {\n      throw rule ? rule.error(e.message) : e;\n    }\n  }\n  return nodes.at(0);\n}\n\n/**\n * Replaces the \"&\" token in a node's selector with the parent selector\n * similar to what SCSS does.\n *\n * Mutates the nodes list\n */\nfunction interpolateAmpInSelector(nodes, parent) {\n  let replaced = false;\n  nodes.each(node => {\n    if (node.type === 'nesting') {\n      let clonedParent = parent.clone({});\n      if (node.value !== '&') {\n        node.replaceWith(parse(node.value.replace('&', clonedParent.toString())));\n      } else {\n        node.replaceWith(clonedParent);\n      }\n      replaced = true;\n    } else if ('nodes' in node && node.nodes) {\n      if (interpolateAmpInSelector(node, parent)) {\n        replaced = true;\n      }\n    }\n  });\n  return replaced;\n}\n\n/**\n * Combines parent and child selectors, in a SCSS-like way\n */\nfunction mergeSelectors(parent, child) {\n  let merged = [];\n  parent.selectors.forEach(sel => {\n    let parentNode = parse(sel, parent);\n    child.selectors.forEach(selector => {\n      if (!selector) {\n        return;\n      }\n      let node = parse(selector, child);\n      let replaced = interpolateAmpInSelector(node, parentNode);\n      if (!replaced) {\n        node.prepend(parser.combinator({\n          value: ' '\n        }));\n        node.prepend(parentNode.clone({}));\n      }\n      merged.push(node.toString());\n    });\n  });\n  return merged;\n}\n\n/**\n * Move a child and its preceeding comment(s) to after \"after\"\n */\nfunction breakOut(child, after) {\n  let prev = child.prev();\n  after.after(child);\n  while (prev && prev.type === 'comment') {\n    let nextPrev = prev.prev();\n    after.after(prev);\n    prev = nextPrev;\n  }\n  return child;\n}\nfunction createFnAtruleChilds(bubble) {\n  return function atruleChilds(rule, atrule, bubbling, mergeSels = bubbling) {\n    let children = [];\n    atrule.each(child => {\n      if (child.type === 'rule' && bubbling) {\n        if (mergeSels) {\n          child.selectors = mergeSelectors(rule, child);\n        }\n      } else if (child.type === 'atrule' && child.nodes) {\n        if (bubble[child.name]) {\n          atruleChilds(rule, child, mergeSels);\n        } else if (atrule[rootRuleMergeSel] !== false) {\n          children.push(child);\n        }\n      } else {\n        children.push(child);\n      }\n    });\n    if (bubbling) {\n      if (children.length) {\n        let clone = rule.clone({\n          nodes: []\n        });\n        for (let child of children) {\n          clone.append(child);\n        }\n        atrule.prepend(clone);\n      }\n    }\n  };\n}\nfunction pickDeclarations(selector, declarations, after) {\n  let parent = new Rule({\n    selector,\n    nodes: []\n  });\n  parent.append(declarations);\n  after.after(parent);\n  return parent;\n}\nfunction atruleNames(defaults, custom) {\n  let list = {};\n  for (let name of defaults) {\n    list[name] = true;\n  }\n  if (custom) {\n    for (let name of custom) {\n      list[name.replace(/^@/, '')] = true;\n    }\n  }\n  return list;\n}\nfunction parseRootRuleParams(params) {\n  params = params.trim();\n  let braceBlock = params.match(/^\\((.*)\\)$/);\n  if (!braceBlock) {\n    return {\n      type: 'basic',\n      selector: params\n    };\n  }\n  let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/);\n  if (bits) {\n    let allowlist = bits[1] === 'with';\n    let rules = Object.fromEntries(bits[2].trim().split(/\\s+/).map(name => [name, true]));\n    if (allowlist && rules.all) {\n      return {\n        type: 'noop'\n      };\n    }\n    let escapes = rule => !!rules[rule];\n    if (rules.all) {\n      escapes = () => true;\n    } else if (allowlist) {\n      escapes = rule => rule === 'all' ? false : !rules[rule];\n    }\n    return {\n      type: 'withrules',\n      escapes\n    };\n  }\n  // Unrecognized brace block\n  return {\n    type: 'unknown'\n  };\n}\nfunction getAncestorRules(leaf) {\n  let lineage = [];\n  let parent = leaf.parent;\n  while (parent && parent instanceof AtRule) {\n    lineage.push(parent);\n    parent = parent.parent;\n  }\n  return lineage;\n}\nfunction unwrapRootRule(rule) {\n  let escapes = rule[rootRuleEscapes];\n  if (!escapes) {\n    rule.after(rule.nodes);\n  } else {\n    let nodes = rule.nodes;\n    let topEscaped;\n    let topEscapedIdx = -1;\n    let breakoutLeaf;\n    let breakoutRoot;\n    let clone;\n    let lineage = getAncestorRules(rule);\n    lineage.forEach((parent, i) => {\n      if (escapes(parent.name)) {\n        topEscaped = parent;\n        topEscapedIdx = i;\n        breakoutRoot = clone;\n      } else {\n        let oldClone = clone;\n        clone = parent.clone({\n          nodes: []\n        });\n        oldClone && clone.append(oldClone);\n        breakoutLeaf = breakoutLeaf || clone;\n      }\n    });\n    if (!topEscaped) {\n      rule.after(nodes);\n    } else if (!breakoutRoot) {\n      topEscaped.after(nodes);\n    } else {\n      let leaf = breakoutLeaf;\n      leaf.append(nodes);\n      topEscaped.after(breakoutRoot);\n    }\n    if (rule.next() && topEscaped) {\n      let restRoot;\n      lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {\n        let oldRoot = restRoot;\n        restRoot = parent.clone({\n          nodes: []\n        });\n        oldRoot && restRoot.append(oldRoot);\n        let nextSibs = [];\n        let _child = arr[i - 1] || rule;\n        let next = _child.next();\n        while (next) {\n          nextSibs.push(next);\n          next = next.next();\n        }\n        restRoot.append(nextSibs);\n      });\n      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot);\n    }\n  }\n  rule.remove();\n}\nconst rootRuleMergeSel = Symbol('rootRuleMergeSel');\nconst rootRuleEscapes = Symbol('rootRuleEscapes');\nfunction normalizeRootRule(rule) {\n  let {\n    params\n  } = rule;\n  let {\n    type,\n    selector,\n    escapes\n  } = parseRootRuleParams(params);\n  if (type === 'unknown') {\n    throw rule.error(`Unknown @${rule.name} parameter ${JSON.stringify(params)}`);\n  }\n  if (type === 'basic' && selector) {\n    let selectorBlock = new Rule({\n      selector,\n      nodes: rule.nodes\n    });\n    rule.removeAll();\n    rule.append(selectorBlock);\n  }\n  rule[rootRuleEscapes] = escapes;\n  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop';\n}\nconst hasRootRule = Symbol('hasRootRule');\nmodule.exports = (opts = {}) => {\n  let bubble = atruleNames(['media', 'supports', 'layer', 'container'], opts.bubble);\n  let atruleChilds = createFnAtruleChilds(bubble);\n  let unwrap = atruleNames(['document', 'font-face', 'keyframes', '-webkit-keyframes', '-moz-keyframes'], opts.unwrap);\n  let rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '');\n  let preserveEmpty = opts.preserveEmpty;\n  return {\n    postcssPlugin: 'postcss-nested',\n    Once(root) {\n      root.walkAtRules(rootRuleName, node => {\n        normalizeRootRule(node);\n        root[hasRootRule] = true;\n      });\n    },\n    Rule(rule) {\n      let unwrapped = false;\n      let after = rule;\n      let copyDeclarations = false;\n      let declarations = [];\n      rule.each(child => {\n        if (child.type === 'rule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after);\n            declarations = [];\n          }\n          copyDeclarations = true;\n          unwrapped = true;\n          child.selectors = mergeSelectors(rule, child);\n          after = breakOut(child, after);\n        } else if (child.type === 'atrule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after);\n            declarations = [];\n          }\n          if (child.name === rootRuleName) {\n            unwrapped = true;\n            atruleChilds(rule, child, true, child[rootRuleMergeSel]);\n            after = breakOut(child, after);\n          } else if (bubble[child.name]) {\n            copyDeclarations = true;\n            unwrapped = true;\n            atruleChilds(rule, child, true);\n            after = breakOut(child, after);\n          } else if (unwrap[child.name]) {\n            copyDeclarations = true;\n            unwrapped = true;\n            atruleChilds(rule, child, false);\n            after = breakOut(child, after);\n          } else if (copyDeclarations) {\n            declarations.push(child);\n          }\n        } else if (child.type === 'decl' && copyDeclarations) {\n          declarations.push(child);\n        }\n      });\n      if (declarations.length) {\n        after = pickDeclarations(rule.selector, declarations, after);\n      }\n      if (unwrapped && preserveEmpty !== true) {\n        rule.raws.semicolon = true;\n        if (rule.nodes.length === 0) rule.remove();\n      }\n    },\n    RootExit(root) {\n      if (root[hasRootRule]) {\n        root.walkAtRules(rootRuleName, unwrapRootRule);\n        root[hasRootRule] = false;\n      }\n    }\n  };\n};\nmodule.exports.postcss = true;","map":{"version":3,"names":["Rule","AtRule","require","parser","parse","rawSelector","rule","nodes","parsed","processSync","e","includes","error","message","at","interpolateAmpInSelector","parent","replaced","each","node","type","clonedParent","clone","value","replaceWith","replace","toString","mergeSelectors","child","merged","selectors","forEach","sel","parentNode","selector","prepend","combinator","push","breakOut","after","prev","nextPrev","createFnAtruleChilds","bubble","atruleChilds","atrule","bubbling","mergeSels","children","name","rootRuleMergeSel","length","append","pickDeclarations","declarations","atruleNames","defaults","custom","list","parseRootRuleParams","params","trim","braceBlock","match","bits","allowlist","rules","Object","fromEntries","split","map","all","escapes","getAncestorRules","leaf","lineage","unwrapRootRule","rootRuleEscapes","topEscaped","topEscapedIdx","breakoutLeaf","breakoutRoot","i","oldClone","next","restRoot","slice","arr","oldRoot","nextSibs","_child","remove","Symbol","normalizeRootRule","JSON","stringify","selectorBlock","removeAll","hasRootRule","module","exports","opts","unwrap","rootRuleName","preserveEmpty","postcssPlugin","Once","root","walkAtRules","unwrapped","copyDeclarations","raws","semicolon","RootExit","postcss"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/postcss-nested/index.js"],"sourcesContent":["const { Rule, AtRule } = require('postcss')\nlet parser = require('postcss-selector-parser')\n\n/**\n * Run a selector string through postcss-selector-parser\n */\nfunction parse(rawSelector, rule) {\n  let nodes\n  try {\n    parser(parsed => {\n      nodes = parsed\n    }).processSync(rawSelector)\n  } catch (e) {\n    if (rawSelector.includes(':')) {\n      throw rule ? rule.error('Missed semicolon') : e\n    } else {\n      throw rule ? rule.error(e.message) : e\n    }\n  }\n  return nodes.at(0)\n}\n\n/**\n * Replaces the \"&\" token in a node's selector with the parent selector\n * similar to what SCSS does.\n *\n * Mutates the nodes list\n */\nfunction interpolateAmpInSelector(nodes, parent) {\n  let replaced = false\n  nodes.each(node => {\n    if (node.type === 'nesting') {\n      let clonedParent = parent.clone({})\n      if (node.value !== '&') {\n        node.replaceWith(\n          parse(node.value.replace('&', clonedParent.toString()))\n        )\n      } else {\n        node.replaceWith(clonedParent)\n      }\n      replaced = true\n    } else if ('nodes' in node && node.nodes) {\n      if (interpolateAmpInSelector(node, parent)) {\n        replaced = true\n      }\n    }\n  })\n  return replaced\n}\n\n/**\n * Combines parent and child selectors, in a SCSS-like way\n */\nfunction mergeSelectors(parent, child) {\n  let merged = []\n  parent.selectors.forEach(sel => {\n    let parentNode = parse(sel, parent)\n\n    child.selectors.forEach(selector => {\n      if (!selector) {\n        return\n      }\n      let node = parse(selector, child)\n      let replaced = interpolateAmpInSelector(node, parentNode)\n      if (!replaced) {\n        node.prepend(parser.combinator({ value: ' ' }))\n        node.prepend(parentNode.clone({}))\n      }\n      merged.push(node.toString())\n    })\n  })\n  return merged\n}\n\n/**\n * Move a child and its preceeding comment(s) to after \"after\"\n */\nfunction breakOut(child, after) {\n  let prev = child.prev()\n  after.after(child)\n  while (prev && prev.type === 'comment') {\n    let nextPrev = prev.prev()\n    after.after(prev)\n    prev = nextPrev\n  }\n  return child\n}\n\nfunction createFnAtruleChilds(bubble) {\n  return function atruleChilds(rule, atrule, bubbling, mergeSels = bubbling) {\n    let children = []\n    atrule.each(child => {\n      if (child.type === 'rule' && bubbling) {\n        if (mergeSels) {\n          child.selectors = mergeSelectors(rule, child)\n        }\n      } else if (child.type === 'atrule' && child.nodes) {\n        if (bubble[child.name]) {\n          atruleChilds(rule, child, mergeSels)\n        } else if (atrule[rootRuleMergeSel] !== false) {\n          children.push(child)\n        }\n      } else {\n        children.push(child)\n      }\n    })\n    if (bubbling) {\n      if (children.length) {\n        let clone = rule.clone({ nodes: [] })\n        for (let child of children) {\n          clone.append(child)\n        }\n        atrule.prepend(clone)\n      }\n    }\n  }\n}\n\nfunction pickDeclarations(selector, declarations, after) {\n  let parent = new Rule({\n    selector,\n    nodes: []\n  })\n  parent.append(declarations)\n  after.after(parent)\n  return parent\n}\n\nfunction atruleNames(defaults, custom) {\n  let list = {}\n  for (let name of defaults) {\n    list[name] = true\n  }\n  if (custom) {\n    for (let name of custom) {\n      list[name.replace(/^@/, '')] = true\n    }\n  }\n  return list\n}\n\nfunction parseRootRuleParams(params) {\n  params = params.trim()\n  let braceBlock = params.match(/^\\((.*)\\)$/)\n  if (!braceBlock) {\n    return { type: 'basic', selector: params }\n  }\n  let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/)\n  if (bits) {\n    let allowlist = bits[1] === 'with'\n    let rules = Object.fromEntries(\n      bits[2]\n        .trim()\n        .split(/\\s+/)\n        .map(name => [name, true])\n    )\n    if (allowlist && rules.all) {\n      return { type: 'noop' }\n    }\n    let escapes = rule => !!rules[rule]\n    if (rules.all) {\n      escapes = () => true\n    } else if (allowlist) {\n      escapes = rule => (rule === 'all' ? false : !rules[rule])\n    }\n\n    return {\n      type: 'withrules',\n      escapes\n    }\n  }\n  // Unrecognized brace block\n  return { type: 'unknown' }\n}\n\nfunction getAncestorRules(leaf) {\n  let lineage = []\n  let parent = leaf.parent\n\n  while (parent && parent instanceof AtRule) {\n    lineage.push(parent)\n    parent = parent.parent\n  }\n  return lineage\n}\n\nfunction unwrapRootRule(rule) {\n  let escapes = rule[rootRuleEscapes]\n\n  if (!escapes) {\n    rule.after(rule.nodes)\n  } else {\n    let nodes = rule.nodes\n\n    let topEscaped\n    let topEscapedIdx = -1\n    let breakoutLeaf\n    let breakoutRoot\n    let clone\n\n    let lineage = getAncestorRules(rule)\n    lineage.forEach((parent, i) => {\n      if (escapes(parent.name)) {\n        topEscaped = parent\n        topEscapedIdx = i\n        breakoutRoot = clone\n      } else {\n        let oldClone = clone\n        clone = parent.clone({ nodes: [] })\n        oldClone && clone.append(oldClone)\n        breakoutLeaf = breakoutLeaf || clone\n      }\n    })\n\n    if (!topEscaped) {\n      rule.after(nodes)\n    } else if (!breakoutRoot) {\n      topEscaped.after(nodes)\n    } else {\n      let leaf = breakoutLeaf\n      leaf.append(nodes)\n      topEscaped.after(breakoutRoot)\n    }\n\n    if (rule.next() && topEscaped) {\n      let restRoot\n      lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {\n        let oldRoot = restRoot\n        restRoot = parent.clone({ nodes: [] })\n        oldRoot && restRoot.append(oldRoot)\n\n        let nextSibs = []\n        let _child = arr[i - 1] || rule\n        let next = _child.next()\n        while (next) {\n          nextSibs.push(next)\n          next = next.next()\n        }\n        restRoot.append(nextSibs)\n      })\n      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot)\n    }\n  }\n\n  rule.remove()\n}\n\nconst rootRuleMergeSel = Symbol('rootRuleMergeSel')\nconst rootRuleEscapes = Symbol('rootRuleEscapes')\n\nfunction normalizeRootRule(rule) {\n  let { params } = rule\n  let { type, selector, escapes } = parseRootRuleParams(params)\n  if (type === 'unknown') {\n    throw rule.error(\n      `Unknown @${rule.name} parameter ${JSON.stringify(params)}`\n    )\n  }\n  if (type === 'basic' && selector) {\n    let selectorBlock = new Rule({ selector, nodes: rule.nodes })\n    rule.removeAll()\n    rule.append(selectorBlock)\n  }\n  rule[rootRuleEscapes] = escapes\n  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop'\n}\n\nconst hasRootRule = Symbol('hasRootRule')\n\nmodule.exports = (opts = {}) => {\n  let bubble = atruleNames(\n    ['media', 'supports', 'layer', 'container'],\n    opts.bubble\n  )\n  let atruleChilds = createFnAtruleChilds(bubble)\n  let unwrap = atruleNames(\n    [\n      'document',\n      'font-face',\n      'keyframes',\n      '-webkit-keyframes',\n      '-moz-keyframes'\n    ],\n    opts.unwrap\n  )\n  let rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '')\n  let preserveEmpty = opts.preserveEmpty\n\n  return {\n    postcssPlugin: 'postcss-nested',\n\n    Once(root) {\n      root.walkAtRules(rootRuleName, node => {\n        normalizeRootRule(node)\n        root[hasRootRule] = true\n      })\n    },\n\n    Rule(rule) {\n      let unwrapped = false\n      let after = rule\n      let copyDeclarations = false\n      let declarations = []\n\n      rule.each(child => {\n        if (child.type === 'rule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after)\n            declarations = []\n          }\n\n          copyDeclarations = true\n          unwrapped = true\n          child.selectors = mergeSelectors(rule, child)\n          after = breakOut(child, after)\n        } else if (child.type === 'atrule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after)\n            declarations = []\n          }\n          if (child.name === rootRuleName) {\n            unwrapped = true\n            atruleChilds(rule, child, true, child[rootRuleMergeSel])\n            after = breakOut(child, after)\n          } else if (bubble[child.name]) {\n            copyDeclarations = true\n            unwrapped = true\n            atruleChilds(rule, child, true)\n            after = breakOut(child, after)\n          } else if (unwrap[child.name]) {\n            copyDeclarations = true\n            unwrapped = true\n            atruleChilds(rule, child, false)\n            after = breakOut(child, after)\n          } else if (copyDeclarations) {\n            declarations.push(child)\n          }\n        } else if (child.type === 'decl' && copyDeclarations) {\n          declarations.push(child)\n        }\n      })\n\n      if (declarations.length) {\n        after = pickDeclarations(rule.selector, declarations, after)\n      }\n\n      if (unwrapped && preserveEmpty !== true) {\n        rule.raws.semicolon = true\n        if (rule.nodes.length === 0) rule.remove()\n      }\n    },\n\n    RootExit(root) {\n      if (root[hasRootRule]) {\n        root.walkAtRules(rootRuleName, unwrapRootRule)\n        root[hasRootRule] = false\n      }\n    }\n  }\n}\nmodule.exports.postcss = true\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}