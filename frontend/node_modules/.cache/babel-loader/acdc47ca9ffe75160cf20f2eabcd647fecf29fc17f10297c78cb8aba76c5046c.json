{"ast":null,"code":"import { TokenType as tt } from \"../parser/tokenizer/types\";\nimport getImportExportSpecifierInfo from \"./getImportExportSpecifierInfo\";\n\n/**\n * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can\n * properly get globals so we can compute shadowed globals.\n *\n * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS\n * replacement and flow type imports.\n */\nexport default function getTSImportedNames(tokens) {\n  const importedNames = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    if (tokens.matches1AtIndex(i, tt._import) && !tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)) {\n      collectNamesForImport(tokens, i, importedNames);\n    }\n  }\n  return importedNames;\n}\nfunction collectNamesForImport(tokens, index, importedNames) {\n  index++;\n  if (tokens.matches1AtIndex(index, tt.parenL)) {\n    // Dynamic import, so nothing to do\n    return;\n  }\n  if (tokens.matches1AtIndex(index, tt.name)) {\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n    if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    }\n  }\n  if (tokens.matches1AtIndex(index, tt.star)) {\n    // * as\n    index += 2;\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n  }\n  if (tokens.matches1AtIndex(index, tt.braceL)) {\n    index++;\n    collectNamesForNamedImport(tokens, index, importedNames);\n  }\n}\nfunction collectNamesForNamedImport(tokens, index, importedNames) {\n  while (true) {\n    if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    }\n    const specifierInfo = getImportExportSpecifierInfo(tokens, index);\n    index = specifierInfo.endIndex;\n    if (!specifierInfo.isType) {\n      importedNames.add(specifierInfo.rightName);\n    }\n    if (tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    } else {\n      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);\n    }\n  }\n}","map":{"version":3,"names":["TokenType","tt","getImportExportSpecifierInfo","getTSImportedNames","tokens","importedNames","Set","i","length","matches1AtIndex","_import","matches3AtIndex","name","eq","collectNamesForImport","index","parenL","add","identifierNameAtIndex","comma","star","braceL","collectNamesForNamedImport","braceR","specifierInfo","endIndex","isType","rightName","matches2AtIndex","Error","JSON","stringify"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/util/getTSImportedNames.js"],"sourcesContent":["import {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport getImportExportSpecifierInfo from \"./getImportExportSpecifierInfo\";\n\n/**\n * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can\n * properly get globals so we can compute shadowed globals.\n *\n * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS\n * replacement and flow type imports.\n */\nexport default function getTSImportedNames(tokens) {\n  const importedNames = new Set();\n  for (let i = 0; i < tokens.tokens.length; i++) {\n    if (\n      tokens.matches1AtIndex(i, tt._import) &&\n      !tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)\n    ) {\n      collectNamesForImport(tokens, i, importedNames);\n    }\n  }\n  return importedNames;\n}\n\nfunction collectNamesForImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  index++;\n\n  if (tokens.matches1AtIndex(index, tt.parenL)) {\n    // Dynamic import, so nothing to do\n    return;\n  }\n\n  if (tokens.matches1AtIndex(index, tt.name)) {\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n    if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    }\n  }\n\n  if (tokens.matches1AtIndex(index, tt.star)) {\n    // * as\n    index += 2;\n    importedNames.add(tokens.identifierNameAtIndex(index));\n    index++;\n  }\n\n  if (tokens.matches1AtIndex(index, tt.braceL)) {\n    index++;\n    collectNamesForNamedImport(tokens, index, importedNames);\n  }\n}\n\nfunction collectNamesForNamedImport(\n  tokens,\n  index,\n  importedNames,\n) {\n  while (true) {\n    if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    }\n\n    const specifierInfo = getImportExportSpecifierInfo(tokens, index);\n    index = specifierInfo.endIndex;\n    if (!specifierInfo.isType) {\n      importedNames.add(specifierInfo.rightName);\n    }\n\n    if (tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.braceR)) {\n      return;\n    } else if (tokens.matches1AtIndex(index, tt.comma)) {\n      index++;\n    } else {\n      throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}