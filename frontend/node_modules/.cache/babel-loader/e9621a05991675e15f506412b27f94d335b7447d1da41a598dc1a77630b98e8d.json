{"ast":null,"code":"import { TokenType as tt } from \"../parser/tokenizer/types\";\n\n/**\n * Determine information about this named import or named export specifier.\n *\n * This syntax is the `a` from statements like these:\n * import {A} from \"./foo\";\n * export {A};\n * export {A} from \"./foo\";\n *\n * As it turns out, we can exactly characterize the syntax meaning by simply\n * counting the number of tokens, which can be from 1 to 4:\n * {A}\n * {type A}\n * {A as B}\n * {type A as B}\n *\n * In the type case, we never actually need the names in practice, so don't get\n * them.\n *\n * TODO: There's some redundancy with the type detection here and the isType\n * flag that's already present on tokens in TS mode. This function could\n * potentially be simplified and/or pushed to the call sites to avoid the object\n * allocation.\n */\nexport default function getImportExportSpecifierInfo(tokens, index = tokens.currentIndex()) {\n  let endIndex = index + 1;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A}\n    const name = tokens.identifierNameAtIndex(index);\n    return {\n      isType: false,\n      leftName: name,\n      rightName: name,\n      endIndex\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A as B}\n    return {\n      isType: false,\n      leftName: tokens.identifierNameAtIndex(index),\n      rightName: tokens.identifierNameAtIndex(index + 2),\n      endIndex\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A as B}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex\n    };\n  }\n  throw new Error(`Unexpected import/export specifier at ${index}`);\n}\nfunction isSpecifierEnd(tokens, index) {\n  const token = tokens.tokens[index];\n  return token.type === tt.braceR || token.type === tt.comma;\n}","map":{"version":3,"names":["TokenType","tt","getImportExportSpecifierInfo","tokens","index","currentIndex","endIndex","isSpecifierEnd","name","identifierNameAtIndex","isType","leftName","rightName","Error","token","type","braceR","comma"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js"],"sourcesContent":["import {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Determine information about this named import or named export specifier.\n *\n * This syntax is the `a` from statements like these:\n * import {A} from \"./foo\";\n * export {A};\n * export {A} from \"./foo\";\n *\n * As it turns out, we can exactly characterize the syntax meaning by simply\n * counting the number of tokens, which can be from 1 to 4:\n * {A}\n * {type A}\n * {A as B}\n * {type A as B}\n *\n * In the type case, we never actually need the names in practice, so don't get\n * them.\n *\n * TODO: There's some redundancy with the type detection here and the isType\n * flag that's already present on tokens in TS mode. This function could\n * potentially be simplified and/or pushed to the call sites to avoid the object\n * allocation.\n */\nexport default function getImportExportSpecifierInfo(\n  tokens,\n  index = tokens.currentIndex(),\n) {\n  let endIndex = index + 1;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A}\n    const name = tokens.identifierNameAtIndex(index);\n    return {\n      isType: false,\n      leftName: name,\n      rightName: name,\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {A as B}\n    return {\n      isType: false,\n      leftName: tokens.identifierNameAtIndex(index),\n      rightName: tokens.identifierNameAtIndex(index + 2),\n      endIndex,\n    };\n  }\n  endIndex++;\n  if (isSpecifierEnd(tokens, endIndex)) {\n    // import {type A as B}\n    return {\n      isType: true,\n      leftName: null,\n      rightName: null,\n      endIndex,\n    };\n  }\n  throw new Error(`Unexpected import/export specifier at ${index}`);\n}\n\nfunction isSpecifierEnd(tokens, index) {\n  const token = tokens.tokens[index];\n  return token.type === tt.braceR || token.type === tt.comma;\n}\n"],"mappings":"AAAA,SAAQA,SAAS,IAAIC,EAAE,QAAO,2BAA2B;;AAiBzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,4BAA4BA,CAClDC,MAAM,EACNC,KAAK,GAAGD,MAAM,CAACE,YAAY,CAAC,CAAC,EAC7B;EACA,IAAIC,QAAQ,GAAGF,KAAK,GAAG,CAAC;EACxB,IAAIG,cAAc,CAACJ,MAAM,EAAEG,QAAQ,CAAC,EAAE;IACpC;IACA,MAAME,IAAI,GAAGL,MAAM,CAACM,qBAAqB,CAACL,KAAK,CAAC;IAChD,OAAO;MACLM,MAAM,EAAE,KAAK;MACbC,QAAQ,EAAEH,IAAI;MACdI,SAAS,EAAEJ,IAAI;MACfF;IACF,CAAC;EACH;EACAA,QAAQ,EAAE;EACV,IAAIC,cAAc,CAACJ,MAAM,EAAEG,QAAQ,CAAC,EAAE;IACpC;IACA,OAAO;MACLI,MAAM,EAAE,IAAI;MACZC,QAAQ,EAAE,IAAI;MACdC,SAAS,EAAE,IAAI;MACfN;IACF,CAAC;EACH;EACAA,QAAQ,EAAE;EACV,IAAIC,cAAc,CAACJ,MAAM,EAAEG,QAAQ,CAAC,EAAE;IACpC;IACA,OAAO;MACLI,MAAM,EAAE,KAAK;MACbC,QAAQ,EAAER,MAAM,CAACM,qBAAqB,CAACL,KAAK,CAAC;MAC7CQ,SAAS,EAAET,MAAM,CAACM,qBAAqB,CAACL,KAAK,GAAG,CAAC,CAAC;MAClDE;IACF,CAAC;EACH;EACAA,QAAQ,EAAE;EACV,IAAIC,cAAc,CAACJ,MAAM,EAAEG,QAAQ,CAAC,EAAE;IACpC;IACA,OAAO;MACLI,MAAM,EAAE,IAAI;MACZC,QAAQ,EAAE,IAAI;MACdC,SAAS,EAAE,IAAI;MACfN;IACF,CAAC;EACH;EACA,MAAM,IAAIO,KAAK,CAAE,yCAAwCT,KAAM,EAAC,CAAC;AACnE;AAEA,SAASG,cAAcA,CAACJ,MAAM,EAAEC,KAAK,EAAE;EACrC,MAAMU,KAAK,GAAGX,MAAM,CAACA,MAAM,CAACC,KAAK,CAAC;EAClC,OAAOU,KAAK,CAACC,IAAI,KAAKd,EAAE,CAACe,MAAM,IAAIF,KAAK,CAACC,IAAI,KAAKd,EAAE,CAACgB,KAAK;AAC5D"},"metadata":{},"sourceType":"module","externalDependencies":[]}