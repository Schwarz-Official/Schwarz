{"ast":null,"code":"import { input, state } from \"../traverser/base\";\nimport { charCodes } from \"../util/charcodes\";\nimport { IS_IDENTIFIER_CHAR } from \"../util/identifier\";\nimport { finishToken } from \"./index\";\nimport { READ_WORD_TREE } from \"./readWordTree\";\nimport { TokenType as tt } from \"./types\";\n\n/**\n * Read an identifier, producing either a name token or matching on one of the existing keywords.\n * For performance, we pre-generate big decision tree that we traverse. Each node represents a\n * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if\n * not), and the other 26 values are the transitions to other nodes, or -1 to stop.\n */\nexport default function readWord() {\n  let treePos = 0;\n  let code = 0;\n  let pos = state.pos;\n  while (pos < input.length) {\n    code = input.charCodeAt(pos);\n    if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {\n      break;\n    }\n    const next = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];\n    if (next === -1) {\n      break;\n    } else {\n      treePos = next;\n      pos++;\n    }\n  }\n  const keywordValue = READ_WORD_TREE[treePos];\n  if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {\n    state.pos = pos;\n    if (keywordValue & 1) {\n      finishToken(keywordValue >>> 1);\n    } else {\n      finishToken(tt.name, keywordValue >>> 1);\n    }\n    return;\n  }\n  while (pos < input.length) {\n    const ch = input.charCodeAt(pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      pos += 2;\n      if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {\n        while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {\n          pos++;\n        }\n        pos++;\n      }\n    } else if (ch === charCodes.atSign && input.charCodeAt(pos + 1) === charCodes.atSign) {\n      pos += 2;\n    } else {\n      break;\n    }\n  }\n  state.pos = pos;\n  finishToken(tt.name);\n}","map":{"version":3,"names":["input","state","charCodes","IS_IDENTIFIER_CHAR","finishToken","READ_WORD_TREE","TokenType","tt","readWord","treePos","code","pos","length","charCodeAt","lowercaseA","lowercaseZ","next","keywordValue","name","ch","backslash","leftCurlyBrace","rightCurlyBrace","atSign"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/tokenizer/readWord.js"],"sourcesContent":["import {input, state} from \"../traverser/base\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR} from \"../util/identifier\";\nimport {finishToken} from \"./index\";\nimport {READ_WORD_TREE} from \"./readWordTree\";\nimport {TokenType as tt} from \"./types\";\n\n/**\n * Read an identifier, producing either a name token or matching on one of the existing keywords.\n * For performance, we pre-generate big decision tree that we traverse. Each node represents a\n * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if\n * not), and the other 26 values are the transitions to other nodes, or -1 to stop.\n */\nexport default function readWord() {\n  let treePos = 0;\n  let code = 0;\n  let pos = state.pos;\n  while (pos < input.length) {\n    code = input.charCodeAt(pos);\n    if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {\n      break;\n    }\n    const next = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];\n    if (next === -1) {\n      break;\n    } else {\n      treePos = next;\n      pos++;\n    }\n  }\n\n  const keywordValue = READ_WORD_TREE[treePos];\n  if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {\n    state.pos = pos;\n    if (keywordValue & 1) {\n      finishToken(keywordValue >>> 1);\n    } else {\n      finishToken(tt.name, keywordValue >>> 1);\n    }\n    return;\n  }\n\n  while (pos < input.length) {\n    const ch = input.charCodeAt(pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      pos += 2;\n      if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {\n        while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {\n          pos++;\n        }\n        pos++;\n      }\n    } else if (ch === charCodes.atSign && input.charCodeAt(pos + 1) === charCodes.atSign) {\n      pos += 2;\n    } else {\n      break;\n    }\n  }\n  state.pos = pos;\n  finishToken(tt.name);\n}\n"],"mappings":"AAAA,SAAQA,KAAK,EAAEC,KAAK,QAAO,mBAAmB;AAC9C,SAAQC,SAAS,QAAO,mBAAmB;AAC3C,SAAQC,kBAAkB,QAAO,oBAAoB;AACrD,SAAQC,WAAW,QAAO,SAAS;AACnC,SAAQC,cAAc,QAAO,gBAAgB;AAC7C,SAAQC,SAAS,IAAIC,EAAE,QAAO,SAAS;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,QAAQA,CAAA,EAAG;EACjC,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,GAAG,GAAGV,KAAK,CAACU,GAAG;EACnB,OAAOA,GAAG,GAAGX,KAAK,CAACY,MAAM,EAAE;IACzBF,IAAI,GAAGV,KAAK,CAACa,UAAU,CAACF,GAAG,CAAC;IAC5B,IAAID,IAAI,GAAGR,SAAS,CAACY,UAAU,IAAIJ,IAAI,GAAGR,SAAS,CAACa,UAAU,EAAE;MAC9D;IACF;IACA,MAAMC,IAAI,GAAGX,cAAc,CAACI,OAAO,IAAIC,IAAI,GAAGR,SAAS,CAACY,UAAU,CAAC,GAAG,CAAC,CAAC;IACxE,IAAIE,IAAI,KAAK,CAAC,CAAC,EAAE;MACf;IACF,CAAC,MAAM;MACLP,OAAO,GAAGO,IAAI;MACdL,GAAG,EAAE;IACP;EACF;EAEA,MAAMM,YAAY,GAAGZ,cAAc,CAACI,OAAO,CAAC;EAC5C,IAAIQ,YAAY,GAAG,CAAC,CAAC,IAAI,CAACd,kBAAkB,CAACO,IAAI,CAAC,EAAE;IAClDT,KAAK,CAACU,GAAG,GAAGA,GAAG;IACf,IAAIM,YAAY,GAAG,CAAC,EAAE;MACpBb,WAAW,CAACa,YAAY,KAAK,CAAC,CAAC;IACjC,CAAC,MAAM;MACLb,WAAW,CAACG,EAAE,CAACW,IAAI,EAAED,YAAY,KAAK,CAAC,CAAC;IAC1C;IACA;EACF;EAEA,OAAON,GAAG,GAAGX,KAAK,CAACY,MAAM,EAAE;IACzB,MAAMO,EAAE,GAAGnB,KAAK,CAACa,UAAU,CAACF,GAAG,CAAC;IAChC,IAAIR,kBAAkB,CAACgB,EAAE,CAAC,EAAE;MAC1BR,GAAG,EAAE;IACP,CAAC,MAAM,IAAIQ,EAAE,KAAKjB,SAAS,CAACkB,SAAS,EAAE;MACrC;MACAT,GAAG,IAAI,CAAC;MACR,IAAIX,KAAK,CAACa,UAAU,CAACF,GAAG,CAAC,KAAKT,SAAS,CAACmB,cAAc,EAAE;QACtD,OAAOV,GAAG,GAAGX,KAAK,CAACY,MAAM,IAAIZ,KAAK,CAACa,UAAU,CAACF,GAAG,CAAC,KAAKT,SAAS,CAACoB,eAAe,EAAE;UAChFX,GAAG,EAAE;QACP;QACAA,GAAG,EAAE;MACP;IACF,CAAC,MAAM,IAAIQ,EAAE,KAAKjB,SAAS,CAACqB,MAAM,IAAIvB,KAAK,CAACa,UAAU,CAACF,GAAG,GAAG,CAAC,CAAC,KAAKT,SAAS,CAACqB,MAAM,EAAE;MACpFZ,GAAG,IAAI,CAAC;IACV,CAAC,MAAM;MACL;IACF;EACF;EACAV,KAAK,CAACU,GAAG,GAAGA,GAAG;EACfP,WAAW,CAACG,EAAE,CAACW,IAAI,CAAC;AACtB"},"metadata":{},"sourceType":"module","externalDependencies":[]}