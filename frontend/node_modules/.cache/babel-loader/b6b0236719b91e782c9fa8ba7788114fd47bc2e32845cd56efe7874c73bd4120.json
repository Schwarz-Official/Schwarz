{"ast":null,"code":"import { isBlockScopedDeclaration, isFunctionScopedDeclaration, isNonTopLevelDeclaration } from \"./parser/tokenizer\";\nimport { TokenType as tt } from \"./parser/tokenizer/types\";\n\n/**\n * Traverse the given tokens and modify them if necessary to indicate that some names shadow global\n * variables.\n */\nexport default function identifyShadowedGlobals(tokens, scopes, globalNames) {\n  if (!hasShadowedGlobals(tokens, globalNames)) {\n    return;\n  }\n  markShadowedGlobals(tokens, scopes, globalNames);\n}\n\n/**\n * We can do a fast up-front check to see if there are any declarations to global names. If not,\n * then there's no point in computing scope assignments.\n */\n// Exported for testing.\nexport function hasShadowedGlobals(tokens, globalNames) {\n  for (const token of tokens.tokens) {\n    if (token.type === tt.name && !token.isType && isNonTopLevelDeclaration(token) && globalNames.has(tokens.identifierNameForToken(token))) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction markShadowedGlobals(tokens, scopes, globalNames) {\n  const scopeStack = [];\n  let scopeIndex = scopes.length - 1;\n  // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a\n  // good stack by going backwards through them.\n  for (let i = tokens.tokens.length - 1;; i--) {\n    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1) {\n      scopeStack.pop();\n    }\n    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i + 1) {\n      scopeStack.push(scopes[scopeIndex]);\n      scopeIndex--;\n    }\n    // Process scopes after the last iteration so we can make sure we pop all of them.\n    if (i < 0) {\n      break;\n    }\n    const token = tokens.tokens[i];\n    const name = tokens.identifierNameForToken(token);\n    if (scopeStack.length > 1 && !token.isType && token.type === tt.name && globalNames.has(name)) {\n      if (isBlockScopedDeclaration(token)) {\n        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);\n      } else if (isFunctionScopedDeclaration(token)) {\n        let stackIndex = scopeStack.length - 1;\n        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {\n          stackIndex--;\n        }\n        if (stackIndex < 0) {\n          throw new Error(\"Did not find parent function scope.\");\n        }\n        markShadowedForScope(scopeStack[stackIndex], tokens, name);\n      }\n    }\n  }\n  if (scopeStack.length > 0) {\n    throw new Error(\"Expected empty scope stack after processing file.\");\n  }\n}\nfunction markShadowedForScope(scope, tokens, name) {\n  for (let i = scope.startTokenIndex; i < scope.endTokenIndex; i++) {\n    const token = tokens.tokens[i];\n    if ((token.type === tt.name || token.type === tt.jsxName) && tokens.identifierNameForToken(token) === name) {\n      token.shadowsGlobal = true;\n    }\n  }\n}","map":{"version":3,"names":["isBlockScopedDeclaration","isFunctionScopedDeclaration","isNonTopLevelDeclaration","TokenType","tt","identifyShadowedGlobals","tokens","scopes","globalNames","hasShadowedGlobals","markShadowedGlobals","token","type","name","isType","has","identifierNameForToken","scopeStack","scopeIndex","length","i","startTokenIndex","pop","endTokenIndex","push","markShadowedForScope","stackIndex","isFunctionScope","Error","scope","jsxName","shadowsGlobal"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/identifyShadowedGlobals.js"],"sourcesContent":["import {\n  isBlockScopedDeclaration,\n  isFunctionScopedDeclaration,\n  isNonTopLevelDeclaration,\n} from \"./parser/tokenizer\";\n\nimport {TokenType as tt} from \"./parser/tokenizer/types\";\n\n\n/**\n * Traverse the given tokens and modify them if necessary to indicate that some names shadow global\n * variables.\n */\nexport default function identifyShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  if (!hasShadowedGlobals(tokens, globalNames)) {\n    return;\n  }\n  markShadowedGlobals(tokens, scopes, globalNames);\n}\n\n/**\n * We can do a fast up-front check to see if there are any declarations to global names. If not,\n * then there's no point in computing scope assignments.\n */\n// Exported for testing.\nexport function hasShadowedGlobals(tokens, globalNames) {\n  for (const token of tokens.tokens) {\n    if (\n      token.type === tt.name &&\n      !token.isType &&\n      isNonTopLevelDeclaration(token) &&\n      globalNames.has(tokens.identifierNameForToken(token))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction markShadowedGlobals(\n  tokens,\n  scopes,\n  globalNames,\n) {\n  const scopeStack = [];\n  let scopeIndex = scopes.length - 1;\n  // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a\n  // good stack by going backwards through them.\n  for (let i = tokens.tokens.length - 1; ; i--) {\n    while (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1) {\n      scopeStack.pop();\n    }\n    while (scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i + 1) {\n      scopeStack.push(scopes[scopeIndex]);\n      scopeIndex--;\n    }\n    // Process scopes after the last iteration so we can make sure we pop all of them.\n    if (i < 0) {\n      break;\n    }\n\n    const token = tokens.tokens[i];\n    const name = tokens.identifierNameForToken(token);\n    if (scopeStack.length > 1 && !token.isType && token.type === tt.name && globalNames.has(name)) {\n      if (isBlockScopedDeclaration(token)) {\n        markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);\n      } else if (isFunctionScopedDeclaration(token)) {\n        let stackIndex = scopeStack.length - 1;\n        while (stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope) {\n          stackIndex--;\n        }\n        if (stackIndex < 0) {\n          throw new Error(\"Did not find parent function scope.\");\n        }\n        markShadowedForScope(scopeStack[stackIndex], tokens, name);\n      }\n    }\n  }\n  if (scopeStack.length > 0) {\n    throw new Error(\"Expected empty scope stack after processing file.\");\n  }\n}\n\nfunction markShadowedForScope(scope, tokens, name) {\n  for (let i = scope.startTokenIndex; i < scope.endTokenIndex; i++) {\n    const token = tokens.tokens[i];\n    if (\n      (token.type === tt.name || token.type === tt.jsxName) &&\n      tokens.identifierNameForToken(token) === name\n    ) {\n      token.shadowsGlobal = true;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}