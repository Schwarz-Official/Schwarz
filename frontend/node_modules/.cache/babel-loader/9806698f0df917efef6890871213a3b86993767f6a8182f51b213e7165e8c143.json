{"ast":null,"code":"import { IdentifierRole, isDeclaration, isObjectShorthandDeclaration } from \"../parser/tokenizer\";\nimport { ContextualKeyword } from \"../parser/tokenizer/keywords\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, { EMPTY_DECLARATION_INFO } from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport isExportFrom from \"../util/isExportFrom\";\nimport { removeMaybeImportAttributes } from \"../util/removeMaybeImportAttributes\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are transforming to commonjs.\n */\nexport default class CJSImportTransformer extends Transformer {\n  __init() {\n    this.hadExport = false;\n  }\n  __init2() {\n    this.hadNamedExport = false;\n  }\n  __init3() {\n    this.hadDefaultExport = false;\n  }\n  constructor(rootTransformer, tokens, importProcessor, nameManager, helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, enableLegacyTypeScriptModuleInterop, isTypeScriptTransformEnabled, isFlowTransformEnabled, preserveDynamicImport, keepUnusedImports) {\n    super();\n    this.rootTransformer = rootTransformer;\n    this.tokens = tokens;\n    this.importProcessor = importProcessor;\n    this.nameManager = nameManager;\n    this.helperManager = helperManager;\n    this.reactHotLoaderTransformer = reactHotLoaderTransformer;\n    this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;\n    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;\n    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;\n    this.isFlowTransformEnabled = isFlowTransformEnabled;\n    this.preserveDynamicImport = preserveDynamicImport;\n    this.keepUnusedImports = keepUnusedImports;\n    CJSImportTransformer.prototype.__init.call(this);\n    CJSImportTransformer.prototype.__init2.call(this);\n    CJSImportTransformer.prototype.__init3.call(this);\n    ;\n    this.declarationInfo = isTypeScriptTransformEnabled ? getDeclarationInfo(tokens) : EMPTY_DECLARATION_INFO;\n  }\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.hadExport) {\n      prefix += 'Object.defineProperty(exports, \"__esModule\", {value: true});';\n    }\n    return prefix;\n  }\n  getSuffixCode() {\n    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {\n      return \"\\nmodule.exports = exports.default;\\n\";\n    }\n    return \"\";\n  }\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches1(tt._import)) {\n      this.processImport();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {\n      this.hadExport = true;\n      return this.processExport();\n    }\n    if (this.tokens.matches2(tt.name, tt.postIncDec)) {\n      // Fall through to normal identifier matching if this doesn't apply.\n      if (this.processPostIncDec()) {\n        return true;\n      }\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {\n      return this.processIdentifier();\n    }\n    if (this.tokens.matches1(tt.eq)) {\n      return this.processAssignment();\n    }\n    if (this.tokens.matches1(tt.assign)) {\n      return this.processComplexAssignment();\n    }\n    if (this.tokens.matches1(tt.preIncDec)) {\n      return this.processPreIncDec();\n    }\n    return false;\n  }\n  processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n  /**\n   * Transform this:\n   * import foo, {bar} from 'baz';\n   * into\n   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);\n   *\n   * The import code was already generated in the import preprocessing step, so\n   * we just need to look it up.\n   */\n  processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      if (this.preserveDynamicImport) {\n        // Bail out, only making progress for this one token.\n        this.tokens.copyToken();\n        return;\n      }\n      const requireWrapper = this.enableLegacyTypeScriptModuleInterop ? \"\" : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(`;\n      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);\n      const contextId = this.tokens.currentToken().contextId;\n      if (contextId == null) {\n        throw new Error(\"Expected context ID on dynamic import invocation.\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.replaceToken(requireWrapper ? \")))\" : \"))\");\n      return;\n    }\n    const shouldElideImport = this.removeImportAndDetectIfShouldElide();\n    if (shouldElideImport) {\n      this.tokens.removeToken();\n    } else {\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      this.tokens.appendCode(this.importProcessor.claimImportCode(path));\n    }\n    removeMaybeImportAttributes(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n  /**\n   * Erase this import (since any CJS output would be completely different), and\n   * return true if this import is should be elided due to being a type-only\n   * import. Such imports will not be emitted at all to avoid side effects.\n   *\n   * Import elision only happens with the TypeScript or Flow transforms enabled.\n   *\n   * TODO: This function has some awkward overlap with\n   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.\n   *  That function handles TypeScript implicit import name elision, and removes\n   *  an import if all typical imported names (without `type`) are removed due\n   *  to being type-only imports. This function handles Flow import removal and\n   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS\n   *  purposes.\n   *\n   * The position should end at the import string.\n   */\n  removeImportAndDetectIfShouldElide() {\n    this.tokens.removeInitialToken();\n    if (this.tokens.matchesContextual(ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)) {\n      // This is an \"import type\" statement, so exit early.\n      this.removeRemainingImport();\n      return true;\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {\n      // We have a default import or namespace import, so there must be some\n      // non-type import.\n      this.removeRemainingImport();\n      return false;\n    }\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      return false;\n    }\n    let foundNonTypeImport = false;\n    let foundAnyNamedImport = false;\n    while (!this.tokens.matches1(tt.string)) {\n      // Check if any named imports are of the form \"foo\" or \"foo as bar\", with\n      // no leading \"type\".\n      if (!foundNonTypeImport && this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n        if (!this.tokens.matches1(tt.braceR)) {\n          foundAnyNamedImport = true;\n        }\n        if (this.tokens.matches2(tt.name, tt.comma) || this.tokens.matches2(tt.name, tt.braceR) || this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) || this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)) {\n          foundNonTypeImport = true;\n        }\n      }\n      this.tokens.removeToken();\n    }\n    if (this.keepUnusedImports) {\n      return false;\n    }\n    if (this.isTypeScriptTransformEnabled) {\n      return !foundNonTypeImport;\n    } else if (this.isFlowTransformEnabled) {\n      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.\n      return foundAnyNamedImport && !foundNonTypeImport;\n    } else {\n      return false;\n    }\n  }\n  removeRemainingImport() {\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n  }\n  processIdentifier() {\n    const token = this.tokens.currentToken();\n    if (token.shadowsGlobal) {\n      return false;\n    }\n    if (token.identifierRole === IdentifierRole.ObjectShorthand) {\n      return this.processObjectShorthand();\n    }\n    if (token.identifierRole !== IdentifierRole.Access) {\n      return false;\n    }\n    const replacement = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(token));\n    if (!replacement) {\n      return false;\n    }\n    // Tolerate any number of closing parens while looking for an opening paren\n    // that indicates a function call.\n    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;\n    while (possibleOpenParenIndex < this.tokens.tokens.length && this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR) {\n      possibleOpenParenIndex++;\n    }\n    // Avoid treating imported functions as methods of their `exports` object\n    // by using `(0, f)` when the identifier is in a paren expression. Else\n    // use `Function.prototype.call` when the identifier is a guaranteed\n    // function call. When using `call`, pass undefined as the context.\n    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {\n      if (this.tokens.tokenAtRelativeIndex(1).type === tt.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== tt._new) {\n        this.tokens.replaceToken(`${replacement}.call(void 0, `);\n        // Remove the old paren.\n        this.tokens.removeToken();\n        // Balance out the new paren.\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        // See here: http://2ality.com/2015/12/references.html\n        this.tokens.replaceToken(`(0, ${replacement})`);\n      }\n    } else {\n      this.tokens.replaceToken(replacement);\n    }\n    return true;\n  }\n  processObjectShorthand() {\n    const identifier = this.tokens.identifierName();\n    const replacement = this.importProcessor.getIdentifierReplacement(identifier);\n    if (!replacement) {\n      return false;\n    }\n    this.tokens.replaceToken(`${identifier}: ${replacement}`);\n    return true;\n  }\n  processExport() {\n    if (this.tokens.matches2(tt._export, tt._enum) || this.tokens.matches3(tt._export, tt._const, tt._enum)) {\n      this.hadNamedExport = true;\n      // Let the TypeScript transform handle it.\n      return false;\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {\n        this.hadDefaultExport = true;\n        // Flow export default enums need some special handling, so handle them\n        // in that tranform rather than this one.\n        return false;\n      }\n      this.processExportDefault();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.braceL)) {\n      this.processExportBindings();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (this.tokens.matchesContextual(ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAttributes(this.tokens);\n      }\n      return true;\n    }\n    this.hadNamedExport = true;\n    if (this.tokens.matches2(tt._export, tt._var) || this.tokens.matches2(tt._export, tt._let) || this.tokens.matches2(tt._export, tt._const)) {\n      this.processExportVar();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt._function) ||\n    // export async function\n    this.tokens.matches3(tt._export, tt.name, tt._function)) {\n      this.processExportFunction();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt._class) || this.tokens.matches3(tt._export, tt._abstract, tt._class) || this.tokens.matches2(tt._export, tt.at)) {\n      this.processExportClass();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.star)) {\n      this.processExportStar();\n      return true;\n    } else {\n      throw new Error(\"Unrecognized export syntax.\");\n    }\n  }\n  processAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,\n    // with `b` as the identifier, so nothing needs to be done in that case.\n    if (identifierToken.isType || identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {\n      // Declarations don't need an extra assignment. This doesn't avoid the\n      // assignment for comma-separated declarations, but it's still correct\n      // since the assignment is just redundant.\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.copyToken();\n    this.tokens.appendCode(` ${assignmentSnippet} =`);\n    return true;\n  }\n\n  /**\n   * Process something like `a += 3`, where `a` might be an exported value.\n   */\n  processComplexAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(` = ${assignmentSnippet}`);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `++a`, where `a` might be an exported value.\n   */\n  processPreIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    // Ignore things like ++a.b and ++a[b] and ++a().b.\n    if (index + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(index + 2, tt.dot) || this.tokens.matches1AtIndex(index + 2, tt.bracketL) || this.tokens.matches1AtIndex(index + 2, tt.parenL))) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(`${assignmentSnippet} = `);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `a++`, where `a` might be an exported value.\n   * This starts at the `a`, not at the `++`.\n   */\n  processPostIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index];\n    const operatorToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    const operatorCode = this.tokens.rawCodeForToken(operatorToken);\n    // We might also replace the identifier with something like exports.x, so\n    // do that replacement here as well.\n    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;\n    if (operatorCode === \"++\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);\n    } else if (operatorCode === \"--\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);\n    } else {\n      throw new Error(`Unexpected operator: ${operatorCode}`);\n    }\n    this.tokens.removeToken();\n    return true;\n  }\n  processExportDefault() {\n    let exportedRuntimeValue = true;\n    if (this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n    // export default async function\n    this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._async)) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      // Named function export case: change it to a top-level function\n      // declaration followed by exports statement.\n      const name = this.processNamedFunction();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) || this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) || this.tokens.matches3(tt._export, tt._default, tt.at)) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.copyDecorators();\n      if (this.tokens.matches1(tt._abstract)) {\n        this.tokens.removeToken();\n      }\n      const name = this.rootTransformer.processNamedClass();\n      this.tokens.appendCode(` exports.default = ${name};`);\n      // After this point, this is a plain \"export default E\" statement.\n    } else if (shouldElideDefaultExport(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      exportedRuntimeValue = false;\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n    } else if (this.reactHotLoaderTransformer) {\n      // We need to assign E to a variable. Change \"export default E\" to\n      // \"let _default; exports.default = _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` = ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n    } else {\n      // Change \"export default E\" to \"exports.default = E\"\n      this.tokens.replaceToken(\"exports.\");\n      this.tokens.copyToken();\n      this.tokens.appendCode(\" =\");\n    }\n    if (exportedRuntimeValue) {\n      this.hadDefaultExport = true;\n    }\n  }\n  copyDecorators() {\n    while (this.tokens.matches1(tt.at)) {\n      this.tokens.copyToken();\n      if (this.tokens.matches1(tt.parenL)) {\n        this.tokens.copyExpectedToken(tt.parenL);\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        this.tokens.copyExpectedToken(tt.name);\n        while (this.tokens.matches1(tt.dot)) {\n          this.tokens.copyExpectedToken(tt.dot);\n          this.tokens.copyExpectedToken(tt.name);\n        }\n        if (this.tokens.matches1(tt.parenL)) {\n          this.tokens.copyExpectedToken(tt.parenL);\n          this.rootTransformer.processBalancedCode();\n          this.tokens.copyExpectedToken(tt.parenR);\n        }\n      }\n    }\n  }\n\n  /**\n   * Transform a declaration like `export var`, `export let`, or `export const`.\n   */\n  processExportVar() {\n    if (this.isSimpleExportVar()) {\n      this.processSimpleExportVar();\n    } else {\n      this.processComplexExportVar();\n    }\n  }\n\n  /**\n   * Determine if the export is of the form:\n   * export var/let/const [varName] = [expr];\n   * In other words, determine if function name inference might apply.\n   */\n  isSimpleExportVar() {\n    let tokenIndex = this.tokens.currentIndex();\n    // export\n    tokenIndex++;\n    // var/let/const\n    tokenIndex++;\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.name)) {\n      return false;\n    }\n    tokenIndex++;\n    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {\n      tokenIndex++;\n    }\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.eq)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Transform an `export var` declaration initializing a single variable.\n   *\n   * For example, this:\n   * export const f = () => {};\n   * becomes this:\n   * const f = () => {}; exports.f = f;\n   *\n   * The variable is unused (e.g. exports.f has the true value of the export).\n   * We need to produce an assignment of this form so that the function will\n   * have an inferred name of \"f\", which wouldn't happen in the more general\n   * case below.\n   */\n  processSimpleExportVar() {\n    // export\n    this.tokens.removeInitialToken();\n    // var/let/const\n    this.tokens.copyToken();\n    const varName = this.tokens.identifierName();\n    // x: number  ->  x\n    while (!this.tokens.matches1(tt.eq)) {\n      this.rootTransformer.processToken();\n    }\n    const endIndex = this.tokens.currentToken().rhsEndIndex;\n    if (endIndex == null) {\n      throw new Error(\"Expected = token with an end index.\");\n    }\n    while (this.tokens.currentIndex() < endIndex) {\n      this.rootTransformer.processToken();\n    }\n    this.tokens.appendCode(`; exports.${varName} = ${varName}`);\n  }\n\n  /**\n   * Transform normal declaration exports, including handling destructuring.\n   * For example, this:\n   * export const {x: [a = 2, b], c} = d;\n   * becomes this:\n   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)\n   */\n  processComplexExportVar() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const needsParens = this.tokens.matches1(tt.braceL);\n    if (needsParens) {\n      this.tokens.appendCode(\"(\");\n    }\n    let depth = 0;\n    while (true) {\n      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL) || this.tokens.matches1(tt.bracketL)) {\n        depth++;\n        this.tokens.copyToken();\n      } else if (this.tokens.matches1(tt.braceR) || this.tokens.matches1(tt.bracketR)) {\n        depth--;\n        this.tokens.copyToken();\n      } else if (depth === 0 && !this.tokens.matches1(tt.name) && !this.tokens.currentToken().isType) {\n        break;\n      } else if (this.tokens.matches1(tt.eq)) {\n        // Default values might have assignments in the RHS that we want to ignore, so skip past\n        // them.\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        while (this.tokens.currentIndex() < endIndex) {\n          this.rootTransformer.processToken();\n        }\n      } else {\n        const token = this.tokens.currentToken();\n        if (isDeclaration(token)) {\n          const name = this.tokens.identifierName();\n          let replacement = this.importProcessor.getIdentifierReplacement(name);\n          if (replacement === null) {\n            throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`);\n          }\n          if (isObjectShorthandDeclaration(token)) {\n            replacement = `${name}: ${replacement}`;\n          }\n          this.tokens.replaceToken(replacement);\n        } else {\n          this.rootTransformer.processToken();\n        }\n      }\n    }\n    if (needsParens) {\n      // Seek to the end of the RHS.\n      const endIndex = this.tokens.currentToken().rhsEndIndex;\n      if (endIndex == null) {\n        throw new Error(\"Expected = token with an end index.\");\n      }\n      while (this.tokens.currentIndex() < endIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\")\");\n    }\n  }\n\n  /**\n   * Transform this:\n   * export function foo() {}\n   * into this:\n   * function foo() {} exports.foo = foo;\n   */\n  processExportFunction() {\n    this.tokens.replaceToken(\"\");\n    const name = this.processNamedFunction();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Skip past a function with a name and return that name.\n   */\n  processNamedFunction() {\n    if (this.tokens.matches1(tt._function)) {\n      this.tokens.copyToken();\n    } else if (this.tokens.matches2(tt.name, tt._function)) {\n      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {\n        throw new Error(\"Expected async keyword in function export.\");\n      }\n      this.tokens.copyToken();\n      this.tokens.copyToken();\n    }\n    if (this.tokens.matches1(tt.star)) {\n      this.tokens.copyToken();\n    }\n    if (!this.tokens.matches1(tt.name)) {\n      throw new Error(\"Expected identifier for exported function name.\");\n    }\n    const name = this.tokens.identifierName();\n    this.tokens.copyToken();\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.parenL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.parenR);\n    this.rootTransformer.processPossibleTypeRange();\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.braceR);\n    return name;\n  }\n\n  /**\n   * Transform this:\n   * export class A {}\n   * into this:\n   * class A {} exports.A = A;\n   */\n  processExportClass() {\n    this.tokens.removeInitialToken();\n    this.copyDecorators();\n    if (this.tokens.matches1(tt._abstract)) {\n      this.tokens.removeToken();\n    }\n    const name = this.rootTransformer.processNamedClass();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Transform this:\n   * export {a, b as c};\n   * into this:\n   * exports.a = a; exports.c = b;\n   *\n   * OR\n   *\n   * Transform this:\n   * export {a, b as c} from './foo';\n   * into the pre-generated Object.defineProperty code from the ImportProcessor.\n   *\n   * For the first case, if the TypeScript transform is enabled, we need to skip\n   * exports that are only defined as types.\n   */\n  processExportBindings() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const isReExport = isExportFrom(this.tokens);\n    const exportStatements = [];\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n      while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n        this.tokens.removeToken();\n      }\n      const shouldRemoveExport = specifierInfo.isType || !isReExport && this.shouldElideExportedIdentifier(specifierInfo.leftName);\n      if (!shouldRemoveExport) {\n        const exportedName = specifierInfo.rightName;\n        if (exportedName === \"default\") {\n          this.hadDefaultExport = true;\n        } else {\n          this.hadNamedExport = true;\n        }\n        const localName = specifierInfo.leftName;\n        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);\n        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);\n      }\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      if (this.tokens.matches2(tt.comma, tt.braceR)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        break;\n      } else if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);\n      }\n    }\n    if (this.tokens.matchesContextual(ContextualKeyword._from)) {\n      // This is an export...from, so throw away the normal named export code\n      // and use the Object.defineProperty code from ImportProcessor.\n      this.tokens.removeToken();\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      removeMaybeImportAttributes(this.tokens);\n    } else {\n      // This is a normal named export, so use that.\n      this.tokens.appendCode(exportStatements.join(\" \"));\n    }\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n  processExportStar() {\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n    const path = this.tokens.stringValue();\n    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    removeMaybeImportAttributes(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n  shouldElideExportedIdentifier(name) {\n    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(name);\n  }\n}","map":{"version":3,"names":["IdentifierRole","isDeclaration","isObjectShorthandDeclaration","ContextualKeyword","TokenType","tt","elideImportEquals","getDeclarationInfo","EMPTY_DECLARATION_INFO","getImportExportSpecifierInfo","isExportFrom","removeMaybeImportAttributes","shouldElideDefaultExport","Transformer","CJSImportTransformer","__init","hadExport","__init2","hadNamedExport","__init3","hadDefaultExport","constructor","rootTransformer","tokens","importProcessor","nameManager","helperManager","reactHotLoaderTransformer","enableLegacyBabel5ModuleInterop","enableLegacyTypeScriptModuleInterop","isTypeScriptTransformEnabled","isFlowTransformEnabled","preserveDynamicImport","keepUnusedImports","prototype","call","declarationInfo","getPrefixCode","prefix","getSuffixCode","process","matches3","_import","name","eq","processImportEquals","matches1","processImport","matches2","_export","replaceToken","currentToken","isType","processExport","postIncDec","processPostIncDec","jsxName","processIdentifier","processAssignment","assign","processComplexAssignment","preIncDec","processPreIncDec","importName","identifierNameAtIndex","currentIndex","shouldAutomaticallyElideImportedName","parenL","copyToken","requireWrapper","getHelperName","contextId","Error","matchesContextIdAndLabel","parenR","processToken","shouldElideImport","removeImportAndDetectIfShouldElide","removeToken","path","stringValue","replaceTokenTrimmingLeftWhitespace","claimImportCode","appendCode","semi","removeInitialToken","matchesContextual","_type","matches1AtIndex","comma","matchesContextualAtIndex","_from","removeRemainingImport","star","string","foundNonTypeImport","foundAnyNamedImport","braceL","braceR","matches4","token","shadowsGlobal","identifierRole","ObjectShorthand","processObjectShorthand","Access","replacement","getIdentifierReplacement","identifierNameForToken","possibleOpenParenIndex","length","type","tokenAtRelativeIndex","_new","processBalancedCode","copyExpectedToken","identifier","identifierName","_enum","_const","_default","processExportDefault","processExportBindings","_as","_var","_let","processExportVar","_function","processExportFunction","_class","_abstract","at","processExportClass","processExportStar","index","identifierToken","dot","includes","assignmentSnippet","resolveExportBinding","bracketL","operatorToken","operatorCode","rawCodeForToken","base","exportedRuntimeValue","matches5","_async","processNamedFunction","copyDecorators","processNamedClass","defaultVarName","claimFreeName","setExtractedDefaultExportName","isSimpleExportVar","processSimpleExportVar","processComplexExportVar","tokenIndex","varName","endIndex","rhsEndIndex","needsParens","depth","dollarBraceL","bracketR","processPossibleTypeRange","isReExport","exportStatements","specifierInfo","shouldRemoveExport","shouldElideExportedIdentifier","leftName","exportedName","rightName","localName","newLocalName","push","JSON","stringify","join","valueDeclarations","has"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/CJSImportTransformer.js"],"sourcesContent":["\n\n\nimport {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from \"../parser/tokenizer\";\nimport {ContextualKeyword} from \"../parser/tokenizer/keywords\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\nimport elideImportEquals from \"../util/elideImportEquals\";\nimport getDeclarationInfo, {\n\n  EMPTY_DECLARATION_INFO,\n} from \"../util/getDeclarationInfo\";\nimport getImportExportSpecifierInfo from \"../util/getImportExportSpecifierInfo\";\nimport isExportFrom from \"../util/isExportFrom\";\nimport {removeMaybeImportAttributes} from \"../util/removeMaybeImportAttributes\";\nimport shouldElideDefaultExport from \"../util/shouldElideDefaultExport\";\n\n\nimport Transformer from \"./Transformer\";\n\n/**\n * Class for editing import statements when we are transforming to commonjs.\n */\nexport default class CJSImportTransformer extends Transformer {\n   __init() {this.hadExport = false}\n   __init2() {this.hadNamedExport = false}\n   __init3() {this.hadDefaultExport = false}\n  \n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     helperManager,\n     reactHotLoaderTransformer,\n     enableLegacyBabel5ModuleInterop,\n     enableLegacyTypeScriptModuleInterop,\n     isTypeScriptTransformEnabled,\n     isFlowTransformEnabled,\n     preserveDynamicImport,\n     keepUnusedImports,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;this.keepUnusedImports = keepUnusedImports;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;\n    this.declarationInfo = isTypeScriptTransformEnabled\n      ? getDeclarationInfo(tokens)\n      : EMPTY_DECLARATION_INFO;\n  }\n\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.hadExport) {\n      prefix += 'Object.defineProperty(exports, \"__esModule\", {value: true});';\n    }\n    return prefix;\n  }\n\n  getSuffixCode() {\n    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {\n      return \"\\nmodule.exports = exports.default;\\n\";\n    }\n    return \"\";\n  }\n\n  process() {\n    // TypeScript `import foo = require('foo');` should always just be translated to plain require.\n    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {\n      return this.processImportEquals();\n    }\n    if (this.tokens.matches1(tt._import)) {\n      this.processImport();\n      return true;\n    }\n    if (this.tokens.matches2(tt._export, tt.eq)) {\n      this.tokens.replaceToken(\"module.exports\");\n      return true;\n    }\n    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {\n      this.hadExport = true;\n      return this.processExport();\n    }\n    if (this.tokens.matches2(tt.name, tt.postIncDec)) {\n      // Fall through to normal identifier matching if this doesn't apply.\n      if (this.processPostIncDec()) {\n        return true;\n      }\n    }\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {\n      return this.processIdentifier();\n    }\n    if (this.tokens.matches1(tt.eq)) {\n      return this.processAssignment();\n    }\n    if (this.tokens.matches1(tt.assign)) {\n      return this.processComplexAssignment();\n    }\n    if (this.tokens.matches1(tt.preIncDec)) {\n      return this.processPreIncDec();\n    }\n    return false;\n  }\n\n   processImportEquals() {\n    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {\n      // If this name is only used as a type, elide the whole import.\n      elideImportEquals(this.tokens);\n    } else {\n      // Otherwise, switch `import` to `const`.\n      this.tokens.replaceToken(\"const\");\n    }\n    return true;\n  }\n\n  /**\n   * Transform this:\n   * import foo, {bar} from 'baz';\n   * into\n   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);\n   *\n   * The import code was already generated in the import preprocessing step, so\n   * we just need to look it up.\n   */\n   processImport() {\n    if (this.tokens.matches2(tt._import, tt.parenL)) {\n      if (this.preserveDynamicImport) {\n        // Bail out, only making progress for this one token.\n        this.tokens.copyToken();\n        return;\n      }\n      const requireWrapper = this.enableLegacyTypeScriptModuleInterop\n        ? \"\"\n        : `${this.helperManager.getHelperName(\"interopRequireWildcard\")}(`;\n      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);\n      const contextId = this.tokens.currentToken().contextId;\n      if (contextId == null) {\n        throw new Error(\"Expected context ID on dynamic import invocation.\");\n      }\n      this.tokens.copyToken();\n      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.replaceToken(requireWrapper ? \")))\" : \"))\");\n      return;\n    }\n\n    const shouldElideImport = this.removeImportAndDetectIfShouldElide();\n    if (shouldElideImport) {\n      this.tokens.removeToken();\n    } else {\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      this.tokens.appendCode(this.importProcessor.claimImportCode(path));\n    }\n    removeMaybeImportAttributes(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n  /**\n   * Erase this import (since any CJS output would be completely different), and\n   * return true if this import is should be elided due to being a type-only\n   * import. Such imports will not be emitted at all to avoid side effects.\n   *\n   * Import elision only happens with the TypeScript or Flow transforms enabled.\n   *\n   * TODO: This function has some awkward overlap with\n   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.\n   *  That function handles TypeScript implicit import name elision, and removes\n   *  an import if all typical imported names (without `type`) are removed due\n   *  to being type-only imports. This function handles Flow import removal and\n   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS\n   *  purposes.\n   *\n   * The position should end at the import string.\n   */\n   removeImportAndDetectIfShouldElide() {\n    this.tokens.removeInitialToken();\n    if (\n      this.tokens.matchesContextual(ContextualKeyword._type) &&\n      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&\n      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)\n    ) {\n      // This is an \"import type\" statement, so exit early.\n      this.removeRemainingImport();\n      return true;\n    }\n\n    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {\n      // We have a default import or namespace import, so there must be some\n      // non-type import.\n      this.removeRemainingImport();\n      return false;\n    }\n\n    if (this.tokens.matches1(tt.string)) {\n      // This is a bare import, so we should proceed with the import.\n      return false;\n    }\n\n    let foundNonTypeImport = false;\n    let foundAnyNamedImport = false;\n    while (!this.tokens.matches1(tt.string)) {\n      // Check if any named imports are of the form \"foo\" or \"foo as bar\", with\n      // no leading \"type\".\n      if (\n        (!foundNonTypeImport && this.tokens.matches1(tt.braceL)) ||\n        this.tokens.matches1(tt.comma)\n      ) {\n        this.tokens.removeToken();\n        if (!this.tokens.matches1(tt.braceR)) {\n          foundAnyNamedImport = true;\n        }\n        if (\n          this.tokens.matches2(tt.name, tt.comma) ||\n          this.tokens.matches2(tt.name, tt.braceR) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||\n          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)\n        ) {\n          foundNonTypeImport = true;\n        }\n      }\n      this.tokens.removeToken();\n    }\n    if (this.keepUnusedImports) {\n      return false;\n    }\n    if (this.isTypeScriptTransformEnabled) {\n      return !foundNonTypeImport;\n    } else if (this.isFlowTransformEnabled) {\n      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.\n      return foundAnyNamedImport && !foundNonTypeImport;\n    } else {\n      return false;\n    }\n  }\n\n   removeRemainingImport() {\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processIdentifier() {\n    const token = this.tokens.currentToken();\n    if (token.shadowsGlobal) {\n      return false;\n    }\n\n    if (token.identifierRole === IdentifierRole.ObjectShorthand) {\n      return this.processObjectShorthand();\n    }\n\n    if (token.identifierRole !== IdentifierRole.Access) {\n      return false;\n    }\n    const replacement = this.importProcessor.getIdentifierReplacement(\n      this.tokens.identifierNameForToken(token),\n    );\n    if (!replacement) {\n      return false;\n    }\n    // Tolerate any number of closing parens while looking for an opening paren\n    // that indicates a function call.\n    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;\n    while (\n      possibleOpenParenIndex < this.tokens.tokens.length &&\n      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR\n    ) {\n      possibleOpenParenIndex++;\n    }\n    // Avoid treating imported functions as methods of their `exports` object\n    // by using `(0, f)` when the identifier is in a paren expression. Else\n    // use `Function.prototype.call` when the identifier is a guaranteed\n    // function call. When using `call`, pass undefined as the context.\n    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {\n      if (\n        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&\n        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new\n      ) {\n        this.tokens.replaceToken(`${replacement}.call(void 0, `);\n        // Remove the old paren.\n        this.tokens.removeToken();\n        // Balance out the new paren.\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        // See here: http://2ality.com/2015/12/references.html\n        this.tokens.replaceToken(`(0, ${replacement})`);\n      }\n    } else {\n      this.tokens.replaceToken(replacement);\n    }\n    return true;\n  }\n\n  processObjectShorthand() {\n    const identifier = this.tokens.identifierName();\n    const replacement = this.importProcessor.getIdentifierReplacement(identifier);\n    if (!replacement) {\n      return false;\n    }\n    this.tokens.replaceToken(`${identifier}: ${replacement}`);\n    return true;\n  }\n\n  processExport() {\n    if (\n      this.tokens.matches2(tt._export, tt._enum) ||\n      this.tokens.matches3(tt._export, tt._const, tt._enum)\n    ) {\n      this.hadNamedExport = true;\n      // Let the TypeScript transform handle it.\n      return false;\n    }\n    if (this.tokens.matches2(tt._export, tt._default)) {\n      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {\n        this.hadDefaultExport = true;\n        // Flow export default enums need some special handling, so handle them\n        // in that tranform rather than this one.\n        return false;\n      }\n      this.processExportDefault();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.braceL)) {\n      this.processExportBindings();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt.name) &&\n      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)\n    ) {\n      // export type {a};\n      // export type {a as b};\n      // export type {a} from './b';\n      // export type * from './b';\n      // export type * as ns from './b';\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      if (this.tokens.matches1(tt.braceL)) {\n        while (!this.tokens.matches1(tt.braceR)) {\n          this.tokens.removeToken();\n        }\n        this.tokens.removeToken();\n      } else {\n        // *\n        this.tokens.removeToken();\n        if (this.tokens.matches1(tt._as)) {\n          // as\n          this.tokens.removeToken();\n          // ns\n          this.tokens.removeToken();\n        }\n      }\n      // Remove type re-export `... } from './T'`\n      if (\n        this.tokens.matchesContextual(ContextualKeyword._from) &&\n        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)\n      ) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        removeMaybeImportAttributes(this.tokens);\n      }\n      return true;\n    }\n    this.hadNamedExport = true;\n    if (\n      this.tokens.matches2(tt._export, tt._var) ||\n      this.tokens.matches2(tt._export, tt._let) ||\n      this.tokens.matches2(tt._export, tt._const)\n    ) {\n      this.processExportVar();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._function) ||\n      // export async function\n      this.tokens.matches3(tt._export, tt.name, tt._function)\n    ) {\n      this.processExportFunction();\n      return true;\n    } else if (\n      this.tokens.matches2(tt._export, tt._class) ||\n      this.tokens.matches3(tt._export, tt._abstract, tt._class) ||\n      this.tokens.matches2(tt._export, tt.at)\n    ) {\n      this.processExportClass();\n      return true;\n    } else if (this.tokens.matches2(tt._export, tt.star)) {\n      this.processExportStar();\n      return true;\n    } else {\n      throw new Error(\"Unrecognized export syntax.\");\n    }\n  }\n\n   processAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,\n    // with `b` as the identifier, so nothing needs to be done in that case.\n    if (identifierToken.isType || identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {\n      // Declarations don't need an extra assignment. This doesn't avoid the\n      // assignment for comma-separated declarations, but it's still correct\n      // since the assignment is just redundant.\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.copyToken();\n    this.tokens.appendCode(` ${assignmentSnippet} =`);\n    return true;\n  }\n\n  /**\n   * Process something like `a += 3`, where `a` might be an exported value.\n   */\n   processComplexAssignment() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index - 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {\n      return false;\n    }\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(\n      this.tokens.identifierNameForToken(identifierToken),\n    );\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(` = ${assignmentSnippet}`);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `++a`, where `a` might be an exported value.\n   */\n   processPreIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    // Ignore things like ++a.b and ++a[b] and ++a().b.\n    if (\n      index + 2 < this.tokens.tokens.length &&\n      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||\n        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||\n        this.tokens.matches1AtIndex(index + 2, tt.parenL))\n    ) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    this.tokens.appendCode(`${assignmentSnippet} = `);\n    this.tokens.copyToken();\n    return true;\n  }\n\n  /**\n   * Process something like `a++`, where `a` might be an exported value.\n   * This starts at the `a`, not at the `++`.\n   */\n   processPostIncDec() {\n    const index = this.tokens.currentIndex();\n    const identifierToken = this.tokens.tokens[index];\n    const operatorToken = this.tokens.tokens[index + 1];\n    if (identifierToken.type !== tt.name) {\n      return false;\n    }\n    if (identifierToken.shadowsGlobal) {\n      return false;\n    }\n    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {\n      return false;\n    }\n    const identifierName = this.tokens.identifierNameForToken(identifierToken);\n    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);\n    if (!assignmentSnippet) {\n      return false;\n    }\n    const operatorCode = this.tokens.rawCodeForToken(operatorToken);\n    // We might also replace the identifier with something like exports.x, so\n    // do that replacement here as well.\n    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;\n    if (operatorCode === \"++\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);\n    } else if (operatorCode === \"--\") {\n      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);\n    } else {\n      throw new Error(`Unexpected operator: ${operatorCode}`);\n    }\n    this.tokens.removeToken();\n    return true;\n  }\n\n   processExportDefault() {\n    let exportedRuntimeValue = true;\n    if (\n      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||\n      // export default async function\n      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&\n        this.tokens.matchesContextualAtIndex(\n          this.tokens.currentIndex() + 2,\n          ContextualKeyword._async,\n        ))\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      // Named function export case: change it to a top-level function\n      // declaration followed by exports statement.\n      const name = this.processNamedFunction();\n      this.tokens.appendCode(` exports.default = ${name};`);\n    } else if (\n      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||\n      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) ||\n      this.tokens.matches3(tt._export, tt._default, tt.at)\n    ) {\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.copyDecorators();\n      if (this.tokens.matches1(tt._abstract)) {\n        this.tokens.removeToken();\n      }\n      const name = this.rootTransformer.processNamedClass();\n      this.tokens.appendCode(` exports.default = ${name};`);\n      // After this point, this is a plain \"export default E\" statement.\n    } else if (\n      shouldElideDefaultExport(\n        this.isTypeScriptTransformEnabled,\n        this.keepUnusedImports,\n        this.tokens,\n        this.declarationInfo,\n      )\n    ) {\n      // If the exported value is just an identifier and should be elided by TypeScript\n      // rules, then remove it entirely. It will always have the form `export default e`,\n      // where `e` is an identifier.\n      exportedRuntimeValue = false;\n      this.tokens.removeInitialToken();\n      this.tokens.removeToken();\n      this.tokens.removeToken();\n    } else if (this.reactHotLoaderTransformer) {\n      // We need to assign E to a variable. Change \"export default E\" to\n      // \"let _default; exports.default = _default = E\"\n      const defaultVarName = this.nameManager.claimFreeName(\"_default\");\n      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);\n      this.tokens.copyToken();\n      this.tokens.appendCode(` = ${defaultVarName} =`);\n      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);\n    } else {\n      // Change \"export default E\" to \"exports.default = E\"\n      this.tokens.replaceToken(\"exports.\");\n      this.tokens.copyToken();\n      this.tokens.appendCode(\" =\");\n    }\n    if (exportedRuntimeValue) {\n      this.hadDefaultExport = true;\n    }\n  }\n\n   copyDecorators() {\n    while (this.tokens.matches1(tt.at)) {\n      this.tokens.copyToken();\n      if (this.tokens.matches1(tt.parenL)) {\n        this.tokens.copyExpectedToken(tt.parenL);\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n      } else {\n        this.tokens.copyExpectedToken(tt.name);\n        while (this.tokens.matches1(tt.dot)) {\n          this.tokens.copyExpectedToken(tt.dot);\n          this.tokens.copyExpectedToken(tt.name);\n        }\n        if (this.tokens.matches1(tt.parenL)) {\n          this.tokens.copyExpectedToken(tt.parenL);\n          this.rootTransformer.processBalancedCode();\n          this.tokens.copyExpectedToken(tt.parenR);\n        }\n      }\n    }\n  }\n\n  /**\n   * Transform a declaration like `export var`, `export let`, or `export const`.\n   */\n   processExportVar() {\n    if (this.isSimpleExportVar()) {\n      this.processSimpleExportVar();\n    } else {\n      this.processComplexExportVar();\n    }\n  }\n\n  /**\n   * Determine if the export is of the form:\n   * export var/let/const [varName] = [expr];\n   * In other words, determine if function name inference might apply.\n   */\n   isSimpleExportVar() {\n    let tokenIndex = this.tokens.currentIndex();\n    // export\n    tokenIndex++;\n    // var/let/const\n    tokenIndex++;\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.name)) {\n      return false;\n    }\n    tokenIndex++;\n    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {\n      tokenIndex++;\n    }\n    if (!this.tokens.matches1AtIndex(tokenIndex, tt.eq)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Transform an `export var` declaration initializing a single variable.\n   *\n   * For example, this:\n   * export const f = () => {};\n   * becomes this:\n   * const f = () => {}; exports.f = f;\n   *\n   * The variable is unused (e.g. exports.f has the true value of the export).\n   * We need to produce an assignment of this form so that the function will\n   * have an inferred name of \"f\", which wouldn't happen in the more general\n   * case below.\n   */\n   processSimpleExportVar() {\n    // export\n    this.tokens.removeInitialToken();\n    // var/let/const\n    this.tokens.copyToken();\n    const varName = this.tokens.identifierName();\n    // x: number  ->  x\n    while (!this.tokens.matches1(tt.eq)) {\n      this.rootTransformer.processToken();\n    }\n    const endIndex = this.tokens.currentToken().rhsEndIndex;\n    if (endIndex == null) {\n      throw new Error(\"Expected = token with an end index.\");\n    }\n    while (this.tokens.currentIndex() < endIndex) {\n      this.rootTransformer.processToken();\n    }\n    this.tokens.appendCode(`; exports.${varName} = ${varName}`);\n  }\n\n  /**\n   * Transform normal declaration exports, including handling destructuring.\n   * For example, this:\n   * export const {x: [a = 2, b], c} = d;\n   * becomes this:\n   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)\n   */\n   processComplexExportVar() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n    const needsParens = this.tokens.matches1(tt.braceL);\n    if (needsParens) {\n      this.tokens.appendCode(\"(\");\n    }\n\n    let depth = 0;\n    while (true) {\n      if (\n        this.tokens.matches1(tt.braceL) ||\n        this.tokens.matches1(tt.dollarBraceL) ||\n        this.tokens.matches1(tt.bracketL)\n      ) {\n        depth++;\n        this.tokens.copyToken();\n      } else if (this.tokens.matches1(tt.braceR) || this.tokens.matches1(tt.bracketR)) {\n        depth--;\n        this.tokens.copyToken();\n      } else if (\n        depth === 0 &&\n        !this.tokens.matches1(tt.name) &&\n        !this.tokens.currentToken().isType\n      ) {\n        break;\n      } else if (this.tokens.matches1(tt.eq)) {\n        // Default values might have assignments in the RHS that we want to ignore, so skip past\n        // them.\n        const endIndex = this.tokens.currentToken().rhsEndIndex;\n        if (endIndex == null) {\n          throw new Error(\"Expected = token with an end index.\");\n        }\n        while (this.tokens.currentIndex() < endIndex) {\n          this.rootTransformer.processToken();\n        }\n      } else {\n        const token = this.tokens.currentToken();\n        if (isDeclaration(token)) {\n          const name = this.tokens.identifierName();\n          let replacement = this.importProcessor.getIdentifierReplacement(name);\n          if (replacement === null) {\n            throw new Error(`Expected a replacement for ${name} in \\`export var\\` syntax.`);\n          }\n          if (isObjectShorthandDeclaration(token)) {\n            replacement = `${name}: ${replacement}`;\n          }\n          this.tokens.replaceToken(replacement);\n        } else {\n          this.rootTransformer.processToken();\n        }\n      }\n    }\n\n    if (needsParens) {\n      // Seek to the end of the RHS.\n      const endIndex = this.tokens.currentToken().rhsEndIndex;\n      if (endIndex == null) {\n        throw new Error(\"Expected = token with an end index.\");\n      }\n      while (this.tokens.currentIndex() < endIndex) {\n        this.rootTransformer.processToken();\n      }\n      this.tokens.appendCode(\")\");\n    }\n  }\n\n  /**\n   * Transform this:\n   * export function foo() {}\n   * into this:\n   * function foo() {} exports.foo = foo;\n   */\n   processExportFunction() {\n    this.tokens.replaceToken(\"\");\n    const name = this.processNamedFunction();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Skip past a function with a name and return that name.\n   */\n   processNamedFunction() {\n    if (this.tokens.matches1(tt._function)) {\n      this.tokens.copyToken();\n    } else if (this.tokens.matches2(tt.name, tt._function)) {\n      if (!this.tokens.matchesContextual(ContextualKeyword._async)) {\n        throw new Error(\"Expected async keyword in function export.\");\n      }\n      this.tokens.copyToken();\n      this.tokens.copyToken();\n    }\n    if (this.tokens.matches1(tt.star)) {\n      this.tokens.copyToken();\n    }\n    if (!this.tokens.matches1(tt.name)) {\n      throw new Error(\"Expected identifier for exported function name.\");\n    }\n    const name = this.tokens.identifierName();\n    this.tokens.copyToken();\n    if (this.tokens.currentToken().isType) {\n      this.tokens.removeInitialToken();\n      while (this.tokens.currentToken().isType) {\n        this.tokens.removeToken();\n      }\n    }\n    this.tokens.copyExpectedToken(tt.parenL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.parenR);\n    this.rootTransformer.processPossibleTypeRange();\n    this.tokens.copyExpectedToken(tt.braceL);\n    this.rootTransformer.processBalancedCode();\n    this.tokens.copyExpectedToken(tt.braceR);\n    return name;\n  }\n\n  /**\n   * Transform this:\n   * export class A {}\n   * into this:\n   * class A {} exports.A = A;\n   */\n   processExportClass() {\n    this.tokens.removeInitialToken();\n    this.copyDecorators();\n    if (this.tokens.matches1(tt._abstract)) {\n      this.tokens.removeToken();\n    }\n    const name = this.rootTransformer.processNamedClass();\n    this.tokens.appendCode(` exports.${name} = ${name};`);\n  }\n\n  /**\n   * Transform this:\n   * export {a, b as c};\n   * into this:\n   * exports.a = a; exports.c = b;\n   *\n   * OR\n   *\n   * Transform this:\n   * export {a, b as c} from './foo';\n   * into the pre-generated Object.defineProperty code from the ImportProcessor.\n   *\n   * For the first case, if the TypeScript transform is enabled, we need to skip\n   * exports that are only defined as types.\n   */\n   processExportBindings() {\n    this.tokens.removeInitialToken();\n    this.tokens.removeToken();\n\n    const isReExport = isExportFrom(this.tokens);\n\n    const exportStatements = [];\n    while (true) {\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n\n      const specifierInfo = getImportExportSpecifierInfo(this.tokens);\n\n      while (this.tokens.currentIndex() < specifierInfo.endIndex) {\n        this.tokens.removeToken();\n      }\n\n      const shouldRemoveExport =\n        specifierInfo.isType ||\n        (!isReExport && this.shouldElideExportedIdentifier(specifierInfo.leftName));\n      if (!shouldRemoveExport) {\n        const exportedName = specifierInfo.rightName;\n        if (exportedName === \"default\") {\n          this.hadDefaultExport = true;\n        } else {\n          this.hadNamedExport = true;\n        }\n        const localName = specifierInfo.leftName;\n        const newLocalName = this.importProcessor.getIdentifierReplacement(localName);\n        exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);\n      }\n\n      if (this.tokens.matches1(tt.braceR)) {\n        this.tokens.removeToken();\n        break;\n      }\n      if (this.tokens.matches2(tt.comma, tt.braceR)) {\n        this.tokens.removeToken();\n        this.tokens.removeToken();\n        break;\n      } else if (this.tokens.matches1(tt.comma)) {\n        this.tokens.removeToken();\n      } else {\n        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);\n      }\n    }\n\n    if (this.tokens.matchesContextual(ContextualKeyword._from)) {\n      // This is an export...from, so throw away the normal named export code\n      // and use the Object.defineProperty code from ImportProcessor.\n      this.tokens.removeToken();\n      const path = this.tokens.stringValue();\n      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n      removeMaybeImportAttributes(this.tokens);\n    } else {\n      // This is a normal named export, so use that.\n      this.tokens.appendCode(exportStatements.join(\" \"));\n    }\n\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   processExportStar() {\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.string)) {\n      this.tokens.removeToken();\n    }\n    const path = this.tokens.stringValue();\n    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));\n    removeMaybeImportAttributes(this.tokens);\n    if (this.tokens.matches1(tt.semi)) {\n      this.tokens.removeToken();\n    }\n  }\n\n   shouldElideExportedIdentifier(name) {\n    return (\n      this.isTypeScriptTransformEnabled &&\n      !this.keepUnusedImports &&\n      !this.declarationInfo.valueDeclarations.has(name)\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}