{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\nconst utils = require(\"../utils\");\nfunction generate(input, settings) {\n  const patterns = processPatterns(input, settings);\n  const ignore = processPatterns(settings.ignore, settings);\n  const positivePatterns = getPositivePatterns(patterns);\n  const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);\n  const staticPatterns = positivePatterns.filter(pattern => utils.pattern.isStaticPattern(pattern, settings));\n  const dynamicPatterns = positivePatterns.filter(pattern => utils.pattern.isDynamicPattern(pattern, settings));\n  const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */false);\n  const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */true);\n  return staticTasks.concat(dynamicTasks);\n}\nexports.generate = generate;\nfunction processPatterns(input, settings) {\n  let patterns = input;\n  /**\n   * The original pattern like `{,*,**,a/*}` can lead to problems checking the depth when matching entry\n   * and some problems with the micromatch package (see fast-glob issues: #365, #394).\n   *\n   * To solve this problem, we expand all patterns containing brace expansion. This can lead to a slight slowdown\n   * in matching in the case of a large set of patterns after expansion.\n   */\n  if (settings.braceExpansion) {\n    patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);\n  }\n  /**\n   * If the `baseNameMatch` option is enabled, we must add globstar to patterns, so that they can be used\n   * at any nesting level.\n   *\n   * We do this here, because otherwise we have to complicate the filtering logic. For example, we need to change\n   * the pattern in the filter before creating a regular expression. There is no need to change the patterns\n   * in the application. Only on the input.\n   */\n  if (settings.baseNameMatch) {\n    patterns = patterns.map(pattern => pattern.includes('/') ? pattern : `**/${pattern}`);\n  }\n  /**\n   * This method also removes duplicate slashes that may have been in the pattern or formed as a result of expansion.\n   */\n  return patterns.map(pattern => utils.pattern.removeDuplicateSlashes(pattern));\n}\n/**\n * Returns tasks grouped by basic pattern directories.\n *\n * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.\n * This is necessary because directory traversal starts at the base directory and goes deeper.\n */\nfunction convertPatternsToTasks(positive, negative, dynamic) {\n  const tasks = [];\n  const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\n  const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\n  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\n  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\n  tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\n  /*\n   * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory\n   * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.\n   */\n  if ('.' in insideCurrentDirectoryGroup) {\n    tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));\n  } else {\n    tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\n  }\n  return tasks;\n}\nexports.convertPatternsToTasks = convertPatternsToTasks;\nfunction getPositivePatterns(patterns) {\n  return utils.pattern.getPositivePatterns(patterns);\n}\nexports.getPositivePatterns = getPositivePatterns;\nfunction getNegativePatternsAsPositive(patterns, ignore) {\n  const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\n  const positive = negative.map(utils.pattern.convertToPositivePattern);\n  return positive;\n}\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\nfunction groupPatternsByBaseDirectory(patterns) {\n  const group = {};\n  return patterns.reduce((collection, pattern) => {\n    const base = utils.pattern.getBaseDirectory(pattern);\n    if (base in collection) {\n      collection[base].push(pattern);\n    } else {\n      collection[base] = [pattern];\n    }\n    return collection;\n  }, group);\n}\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\n  return Object.keys(positive).map(base => {\n    return convertPatternGroupToTask(base, positive[base], negative, dynamic);\n  });\n}\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\n  return {\n    dynamic,\n    positive,\n    negative,\n    base,\n    patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\n  };\n}\nexports.convertPatternGroupToTask = convertPatternGroupToTask;","map":{"version":3,"names":["Object","defineProperty","exports","value","convertPatternGroupToTask","convertPatternGroupsToTasks","groupPatternsByBaseDirectory","getNegativePatternsAsPositive","getPositivePatterns","convertPatternsToTasks","generate","utils","require","input","settings","patterns","processPatterns","ignore","positivePatterns","negativePatterns","staticPatterns","filter","pattern","isStaticPattern","dynamicPatterns","isDynamicPattern","staticTasks","dynamicTasks","concat","braceExpansion","expandPatternsWithBraceExpansion","baseNameMatch","map","includes","removeDuplicateSlashes","positive","negative","dynamic","tasks","patternsOutsideCurrentDirectory","getPatternsOutsideCurrentDirectory","patternsInsideCurrentDirectory","getPatternsInsideCurrentDirectory","outsideCurrentDirectoryGroup","insideCurrentDirectoryGroup","push","getNegativePatterns","convertToPositivePattern","group","reduce","collection","base","getBaseDirectory","keys","convertToNegativePattern"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/fast-glob/out/managers/tasks.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\nconst utils = require(\"../utils\");\nfunction generate(input, settings) {\n    const patterns = processPatterns(input, settings);\n    const ignore = processPatterns(settings.ignore, settings);\n    const positivePatterns = getPositivePatterns(patterns);\n    const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);\n    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));\n    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));\n    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\n    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\n    return staticTasks.concat(dynamicTasks);\n}\nexports.generate = generate;\nfunction processPatterns(input, settings) {\n    let patterns = input;\n    /**\n     * The original pattern like `{,*,**,a/*}` can lead to problems checking the depth when matching entry\n     * and some problems with the micromatch package (see fast-glob issues: #365, #394).\n     *\n     * To solve this problem, we expand all patterns containing brace expansion. This can lead to a slight slowdown\n     * in matching in the case of a large set of patterns after expansion.\n     */\n    if (settings.braceExpansion) {\n        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);\n    }\n    /**\n     * If the `baseNameMatch` option is enabled, we must add globstar to patterns, so that they can be used\n     * at any nesting level.\n     *\n     * We do this here, because otherwise we have to complicate the filtering logic. For example, we need to change\n     * the pattern in the filter before creating a regular expression. There is no need to change the patterns\n     * in the application. Only on the input.\n     */\n    if (settings.baseNameMatch) {\n        patterns = patterns.map((pattern) => pattern.includes('/') ? pattern : `**/${pattern}`);\n    }\n    /**\n     * This method also removes duplicate slashes that may have been in the pattern or formed as a result of expansion.\n     */\n    return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));\n}\n/**\n * Returns tasks grouped by basic pattern directories.\n *\n * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.\n * This is necessary because directory traversal starts at the base directory and goes deeper.\n */\nfunction convertPatternsToTasks(positive, negative, dynamic) {\n    const tasks = [];\n    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\n    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\n    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\n    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\n    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\n    /*\n     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory\n     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.\n     */\n    if ('.' in insideCurrentDirectoryGroup) {\n        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));\n    }\n    else {\n        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\n    }\n    return tasks;\n}\nexports.convertPatternsToTasks = convertPatternsToTasks;\nfunction getPositivePatterns(patterns) {\n    return utils.pattern.getPositivePatterns(patterns);\n}\nexports.getPositivePatterns = getPositivePatterns;\nfunction getNegativePatternsAsPositive(patterns, ignore) {\n    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\n    const positive = negative.map(utils.pattern.convertToPositivePattern);\n    return positive;\n}\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\nfunction groupPatternsByBaseDirectory(patterns) {\n    const group = {};\n    return patterns.reduce((collection, pattern) => {\n        const base = utils.pattern.getBaseDirectory(pattern);\n        if (base in collection) {\n            collection[base].push(pattern);\n        }\n        else {\n            collection[base] = [pattern];\n        }\n        return collection;\n    }, group);\n}\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\n    return Object.keys(positive).map((base) => {\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\n    });\n}\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\n    return {\n        dynamic,\n        positive,\n        negative,\n        base,\n        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\n    };\n}\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}