{"ast":null,"code":"// @ts-check\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Offsets\", {\n  enumerable: true,\n  get: function () {\n    return Offsets;\n  }\n});\nconst _bigSign = /*#__PURE__*/_interop_require_default(require(\"../util/bigSign\"));\nconst _remapbitfield = require(\"./remap-bitfield.js\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass Offsets {\n  constructor() {\n    /**\n    * Offsets for the next rule in a given layer\n    *\n    * @type {Record<Layer, bigint>}\n    */\n    this.offsets = {\n      defaults: 0n,\n      base: 0n,\n      components: 0n,\n      utilities: 0n,\n      variants: 0n,\n      user: 0n\n    };\n    /**\n    * Positions for a given layer\n    *\n    * @type {Record<Layer, bigint>}\n    */\n    this.layerPositions = {\n      defaults: 0n,\n      base: 1n,\n      components: 2n,\n      utilities: 3n,\n      // There isn't technically a \"user\" layer, but we need to give it a position\n      // Because it's used for ordering user-css from @apply\n      user: 4n,\n      variants: 5n\n    };\n    /**\n    * The total number of functions currently registered across all variants (including arbitrary variants)\n    *\n    * @type {bigint}\n    */\n    this.reservedVariantBits = 0n;\n    /**\n    * Positions for a given variant\n    *\n    * @type {Map<string, bigint>}\n    */\n    this.variantOffsets = new Map();\n  }\n  /**\n  * @param {Layer} layer\n  * @returns {RuleOffset}\n  */\n  create(layer) {\n    return {\n      layer,\n      parentLayer: layer,\n      arbitrary: 0n,\n      variants: 0n,\n      parallelIndex: 0n,\n      index: this.offsets[layer]++,\n      options: []\n    };\n  }\n  /**\n  * @returns {RuleOffset}\n  */\n  arbitraryProperty() {\n    return {\n      ...this.create(\"utilities\"),\n      arbitrary: 1n\n    };\n  }\n  /**\n  * Get the offset for a variant\n  *\n  * @param {string} variant\n  * @param {number} index\n  * @returns {RuleOffset}\n  */\n  forVariant(variant, index = 0) {\n    let offset = this.variantOffsets.get(variant);\n    if (offset === undefined) {\n      throw new Error(`Cannot find offset for unknown variant ${variant}`);\n    }\n    return {\n      ...this.create(\"variants\"),\n      variants: offset << BigInt(index)\n    };\n  }\n  /**\n  * @param {RuleOffset} rule\n  * @param {RuleOffset} variant\n  * @param {VariantOption} options\n  * @returns {RuleOffset}\n  */\n  applyVariantOffset(rule, variant, options) {\n    options.variant = variant.variants;\n    return {\n      ...rule,\n      layer: \"variants\",\n      parentLayer: rule.layer === \"variants\" ? rule.parentLayer : rule.layer,\n      variants: rule.variants | variant.variants,\n      options: options.sort ? [].concat(options, rule.options) : rule.options,\n      // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.\n      // We'll take the max of all the parallel indexes for now.\n      // @ts-ignore\n      parallelIndex: max([rule.parallelIndex, variant.parallelIndex])\n    };\n  }\n  /**\n  * @param {RuleOffset} offset\n  * @param {number} parallelIndex\n  * @returns {RuleOffset}\n  */\n  applyParallelOffset(offset, parallelIndex) {\n    return {\n      ...offset,\n      parallelIndex: BigInt(parallelIndex)\n    };\n  }\n  /**\n  * Each variant gets 1 bit per function / rule registered.\n  * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.\n  * Additionally, every unique group of variants is grouped together in the stylesheet.\n  *\n  * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.\n  *\n  * @param {string[]} variants\n  * @param {(name: string) => number} getLength\n  */\n  recordVariants(variants, getLength) {\n    for (let variant of variants) {\n      this.recordVariant(variant, getLength(variant));\n    }\n  }\n  /**\n  * The same as `recordVariants` but for a single arbitrary variant at runtime.\n  * @param {string} variant\n  * @param {number} fnCount\n  *\n  * @returns {RuleOffset} The highest offset for this variant\n  */\n  recordVariant(variant, fnCount = 1) {\n    this.variantOffsets.set(variant, 1n << this.reservedVariantBits);\n    // Ensure space is reserved for each \"function\" in the parallel variant\n    // by offsetting the next variant by the number of parallel variants\n    // in the one we just added.\n    // Single functions that return parallel variants are NOT handled separately here\n    // They're offset by 1 (or the number of functions) as usual\n    // And each rule returned is tracked separately since the functions are evaluated lazily.\n    // @see `RuleOffset.parallelIndex`\n    this.reservedVariantBits += BigInt(fnCount);\n    return {\n      ...this.create(\"variants\"),\n      variants: this.variantOffsets.get(variant)\n    };\n  }\n  /**\n  * @param {RuleOffset} a\n  * @param {RuleOffset} b\n  * @returns {bigint}\n  */\n  compare(a, b) {\n    // Sort layers together\n    if (a.layer !== b.layer) {\n      return this.layerPositions[a.layer] - this.layerPositions[b.layer];\n    }\n    // When sorting the `variants` layer, we need to sort based on the parent layer as well within\n    // this variants layer.\n    if (a.parentLayer !== b.parentLayer) {\n      return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];\n    }\n    // Sort based on the sorting function\n    for (let aOptions of a.options) {\n      for (let bOptions of b.options) {\n        if (aOptions.id !== bOptions.id) continue;\n        if (!aOptions.sort || !bOptions.sort) continue;\n        var _max;\n        let maxFnVariant = (_max = max([aOptions.variant, bOptions.variant])) !== null && _max !== void 0 ? _max : 0n;\n        // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit\n        let mask = ~(maxFnVariant | maxFnVariant - 1n);\n        let aVariantsAfterFn = a.variants & mask;\n        let bVariantsAfterFn = b.variants & mask;\n        // If the variants the same, we _can_ sort them\n        if (aVariantsAfterFn !== bVariantsAfterFn) {\n          continue;\n        }\n        let result = aOptions.sort({\n          value: aOptions.value,\n          modifier: aOptions.modifier\n        }, {\n          value: bOptions.value,\n          modifier: bOptions.modifier\n        });\n        if (result !== 0) return result;\n      }\n    }\n    // Sort variants in the order they were registered\n    if (a.variants !== b.variants) {\n      return a.variants - b.variants;\n    }\n    // Make sure each rule returned by a parallel variant is sorted in ascending order\n    if (a.parallelIndex !== b.parallelIndex) {\n      return a.parallelIndex - b.parallelIndex;\n    }\n    // Always sort arbitrary properties after other utilities\n    if (a.arbitrary !== b.arbitrary) {\n      return a.arbitrary - b.arbitrary;\n    }\n    // Sort utilities, components, etcâ€¦ in the order they were registered\n    return a.index - b.index;\n  }\n  /**\n  * Arbitrary variants are recorded in the order they're encountered.\n  * This means that the order is not stable between environments and sets of content files.\n  *\n  * In order to make the order stable, we need to remap the arbitrary variant offsets to\n  * be in alphabetical order starting from the offset of the first arbitrary variant.\n  */\n  recalculateVariantOffsets() {\n    // Sort the variants by their name\n    let variants = Array.from(this.variantOffsets.entries()).filter(([v]) => v.startsWith(\"[\")).sort(([a], [z]) => fastCompare(a, z));\n    // Sort the list of offsets\n    // This is not necessarily a discrete range of numbers which is why\n    // we're using sort instead of creating a range from min/max\n    let newOffsets = variants.map(([, offset]) => offset).sort((a, z) => (0, _bigSign.default)(a - z));\n    // Create a map from the old offsets to the new offsets in the new sort order\n    /** @type {[bigint, bigint][]} */\n    let mapping = variants.map(([, oldOffset], i) => [oldOffset, newOffsets[i]]);\n    // Remove any variants that will not move letting us skip\n    // remapping if everything happens to be in order\n    return mapping.filter(([a, z]) => a !== z);\n  }\n  /**\n  * @template T\n  * @param {[RuleOffset, T][]} list\n  * @returns {[RuleOffset, T][]}\n  */\n  remapArbitraryVariantOffsets(list) {\n    let mapping = this.recalculateVariantOffsets();\n    // No arbitrary variants? Nothing to do.\n    // Everyhing already in order? Nothing to do.\n    if (mapping.length === 0) {\n      return list;\n    }\n    // Remap every variant offset in the list\n    return list.map(item => {\n      let [offset, rule] = item;\n      offset = {\n        ...offset,\n        variants: (0, _remapbitfield.remapBitfield)(offset.variants, mapping)\n      };\n      return [offset, rule];\n    });\n  }\n  /**\n  * @template T\n  * @param {[RuleOffset, T][]} list\n  * @returns {[RuleOffset, T][]}\n  */\n  sort(list) {\n    list = this.remapArbitraryVariantOffsets(list);\n    return list.sort(([a], [b]) => (0, _bigSign.default)(this.compare(a, b)));\n  }\n}\n/**\n *\n * @param {bigint[]} nums\n * @returns {bigint|null}\n */\nfunction max(nums) {\n  let max = null;\n  for (const num of nums) {\n    max = max !== null && max !== void 0 ? max : num;\n    max = max > num ? max : num;\n  }\n  return max;\n}\n/**\n * A fast ASCII order string comparison function.\n *\n * Using `.sort()` without a custom compare function is faster\n * But you can only use that if you're sorting an array of\n * only strings. If you're sorting strings inside objects\n * or arrays, you need must use a custom compare function.\n *\n * @param {string} a\n * @param {string} b\n */\nfunction fastCompare(a, b) {\n  let aLen = a.length;\n  let bLen = b.length;\n  let minLen = aLen < bLen ? aLen : bLen;\n  for (let i = 0; i < minLen; i++) {\n    let cmp = a.charCodeAt(i) - b.charCodeAt(i);\n    if (cmp !== 0) return cmp;\n  }\n  return aLen - bLen;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","Offsets","_bigSign","_interop_require_default","require","_remapbitfield","obj","__esModule","default","constructor","offsets","defaults","base","components","utilities","variants","user","layerPositions","reservedVariantBits","variantOffsets","Map","create","layer","parentLayer","arbitrary","parallelIndex","index","options","arbitraryProperty","forVariant","variant","offset","undefined","Error","BigInt","applyVariantOffset","rule","sort","concat","max","applyParallelOffset","recordVariants","getLength","recordVariant","fnCount","set","compare","a","b","aOptions","bOptions","id","_max","maxFnVariant","mask","aVariantsAfterFn","bVariantsAfterFn","result","modifier","recalculateVariantOffsets","Array","from","entries","filter","v","startsWith","z","fastCompare","newOffsets","map","mapping","oldOffset","i","remapArbitraryVariantOffsets","list","length","item","remapBitfield","nums","num","aLen","bLen","minLen","cmp","charCodeAt"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/lib/offsets.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"Offsets\", {\n    enumerable: true,\n    get: function() {\n        return Offsets;\n    }\n});\nconst _bigSign = /*#__PURE__*/ _interop_require_default(require(\"../util/bigSign\"));\nconst _remapbitfield = require(\"./remap-bitfield.js\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nclass Offsets {\n    constructor(){\n        /**\n     * Offsets for the next rule in a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.offsets = {\n            defaults: 0n,\n            base: 0n,\n            components: 0n,\n            utilities: 0n,\n            variants: 0n,\n            user: 0n\n        };\n        /**\n     * Positions for a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.layerPositions = {\n            defaults: 0n,\n            base: 1n,\n            components: 2n,\n            utilities: 3n,\n            // There isn't technically a \"user\" layer, but we need to give it a position\n            // Because it's used for ordering user-css from @apply\n            user: 4n,\n            variants: 5n\n        };\n        /**\n     * The total number of functions currently registered across all variants (including arbitrary variants)\n     *\n     * @type {bigint}\n     */ this.reservedVariantBits = 0n;\n        /**\n     * Positions for a given variant\n     *\n     * @type {Map<string, bigint>}\n     */ this.variantOffsets = new Map();\n    }\n    /**\n   * @param {Layer} layer\n   * @returns {RuleOffset}\n   */ create(layer) {\n        return {\n            layer,\n            parentLayer: layer,\n            arbitrary: 0n,\n            variants: 0n,\n            parallelIndex: 0n,\n            index: this.offsets[layer]++,\n            options: []\n        };\n    }\n    /**\n   * @returns {RuleOffset}\n   */ arbitraryProperty() {\n        return {\n            ...this.create(\"utilities\"),\n            arbitrary: 1n\n        };\n    }\n    /**\n   * Get the offset for a variant\n   *\n   * @param {string} variant\n   * @param {number} index\n   * @returns {RuleOffset}\n   */ forVariant(variant, index = 0) {\n        let offset = this.variantOffsets.get(variant);\n        if (offset === undefined) {\n            throw new Error(`Cannot find offset for unknown variant ${variant}`);\n        }\n        return {\n            ...this.create(\"variants\"),\n            variants: offset << BigInt(index)\n        };\n    }\n    /**\n   * @param {RuleOffset} rule\n   * @param {RuleOffset} variant\n   * @param {VariantOption} options\n   * @returns {RuleOffset}\n   */ applyVariantOffset(rule, variant, options) {\n        options.variant = variant.variants;\n        return {\n            ...rule,\n            layer: \"variants\",\n            parentLayer: rule.layer === \"variants\" ? rule.parentLayer : rule.layer,\n            variants: rule.variants | variant.variants,\n            options: options.sort ? [].concat(options, rule.options) : rule.options,\n            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.\n            // We'll take the max of all the parallel indexes for now.\n            // @ts-ignore\n            parallelIndex: max([\n                rule.parallelIndex,\n                variant.parallelIndex\n            ])\n        };\n    }\n    /**\n   * @param {RuleOffset} offset\n   * @param {number} parallelIndex\n   * @returns {RuleOffset}\n   */ applyParallelOffset(offset, parallelIndex) {\n        return {\n            ...offset,\n            parallelIndex: BigInt(parallelIndex)\n        };\n    }\n    /**\n   * Each variant gets 1 bit per function / rule registered.\n   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.\n   * Additionally, every unique group of variants is grouped together in the stylesheet.\n   *\n   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.\n   *\n   * @param {string[]} variants\n   * @param {(name: string) => number} getLength\n   */ recordVariants(variants, getLength) {\n        for (let variant of variants){\n            this.recordVariant(variant, getLength(variant));\n        }\n    }\n    /**\n   * The same as `recordVariants` but for a single arbitrary variant at runtime.\n   * @param {string} variant\n   * @param {number} fnCount\n   *\n   * @returns {RuleOffset} The highest offset for this variant\n   */ recordVariant(variant, fnCount = 1) {\n        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);\n        // Ensure space is reserved for each \"function\" in the parallel variant\n        // by offsetting the next variant by the number of parallel variants\n        // in the one we just added.\n        // Single functions that return parallel variants are NOT handled separately here\n        // They're offset by 1 (or the number of functions) as usual\n        // And each rule returned is tracked separately since the functions are evaluated lazily.\n        // @see `RuleOffset.parallelIndex`\n        this.reservedVariantBits += BigInt(fnCount);\n        return {\n            ...this.create(\"variants\"),\n            variants: this.variantOffsets.get(variant)\n        };\n    }\n    /**\n   * @param {RuleOffset} a\n   * @param {RuleOffset} b\n   * @returns {bigint}\n   */ compare(a, b) {\n        // Sort layers together\n        if (a.layer !== b.layer) {\n            return this.layerPositions[a.layer] - this.layerPositions[b.layer];\n        }\n        // When sorting the `variants` layer, we need to sort based on the parent layer as well within\n        // this variants layer.\n        if (a.parentLayer !== b.parentLayer) {\n            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];\n        }\n        // Sort based on the sorting function\n        for (let aOptions of a.options){\n            for (let bOptions of b.options){\n                if (aOptions.id !== bOptions.id) continue;\n                if (!aOptions.sort || !bOptions.sort) continue;\n                var _max;\n                let maxFnVariant = (_max = max([\n                    aOptions.variant,\n                    bOptions.variant\n                ])) !== null && _max !== void 0 ? _max : 0n;\n                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit\n                let mask = ~(maxFnVariant | maxFnVariant - 1n);\n                let aVariantsAfterFn = a.variants & mask;\n                let bVariantsAfterFn = b.variants & mask;\n                // If the variants the same, we _can_ sort them\n                if (aVariantsAfterFn !== bVariantsAfterFn) {\n                    continue;\n                }\n                let result = aOptions.sort({\n                    value: aOptions.value,\n                    modifier: aOptions.modifier\n                }, {\n                    value: bOptions.value,\n                    modifier: bOptions.modifier\n                });\n                if (result !== 0) return result;\n            }\n        }\n        // Sort variants in the order they were registered\n        if (a.variants !== b.variants) {\n            return a.variants - b.variants;\n        }\n        // Make sure each rule returned by a parallel variant is sorted in ascending order\n        if (a.parallelIndex !== b.parallelIndex) {\n            return a.parallelIndex - b.parallelIndex;\n        }\n        // Always sort arbitrary properties after other utilities\n        if (a.arbitrary !== b.arbitrary) {\n            return a.arbitrary - b.arbitrary;\n        }\n        // Sort utilities, components, etcâ€¦ in the order they were registered\n        return a.index - b.index;\n    }\n    /**\n   * Arbitrary variants are recorded in the order they're encountered.\n   * This means that the order is not stable between environments and sets of content files.\n   *\n   * In order to make the order stable, we need to remap the arbitrary variant offsets to\n   * be in alphabetical order starting from the offset of the first arbitrary variant.\n   */ recalculateVariantOffsets() {\n        // Sort the variants by their name\n        let variants = Array.from(this.variantOffsets.entries()).filter(([v])=>v.startsWith(\"[\")).sort(([a], [z])=>fastCompare(a, z));\n        // Sort the list of offsets\n        // This is not necessarily a discrete range of numbers which is why\n        // we're using sort instead of creating a range from min/max\n        let newOffsets = variants.map(([, offset])=>offset).sort((a, z)=>(0, _bigSign.default)(a - z));\n        // Create a map from the old offsets to the new offsets in the new sort order\n        /** @type {[bigint, bigint][]} */ let mapping = variants.map(([, oldOffset], i)=>[\n                oldOffset,\n                newOffsets[i]\n            ]);\n        // Remove any variants that will not move letting us skip\n        // remapping if everything happens to be in order\n        return mapping.filter(([a, z])=>a !== z);\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ remapArbitraryVariantOffsets(list) {\n        let mapping = this.recalculateVariantOffsets();\n        // No arbitrary variants? Nothing to do.\n        // Everyhing already in order? Nothing to do.\n        if (mapping.length === 0) {\n            return list;\n        }\n        // Remap every variant offset in the list\n        return list.map((item)=>{\n            let [offset, rule] = item;\n            offset = {\n                ...offset,\n                variants: (0, _remapbitfield.remapBitfield)(offset.variants, mapping)\n            };\n            return [\n                offset,\n                rule\n            ];\n        });\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ sort(list) {\n        list = this.remapArbitraryVariantOffsets(list);\n        return list.sort(([a], [b])=>(0, _bigSign.default)(this.compare(a, b)));\n    }\n}\n/**\n *\n * @param {bigint[]} nums\n * @returns {bigint|null}\n */ function max(nums) {\n    let max = null;\n    for (const num of nums){\n        max = max !== null && max !== void 0 ? max : num;\n        max = max > num ? max : num;\n    }\n    return max;\n}\n/**\n * A fast ASCII order string comparison function.\n *\n * Using `.sort()` without a custom compare function is faster\n * But you can only use that if you're sorting an array of\n * only strings. If you're sorting strings inside objects\n * or arrays, you need must use a custom compare function.\n *\n * @param {string} a\n * @param {string} b\n */ function fastCompare(a, b) {\n    let aLen = a.length;\n    let bLen = b.length;\n    let minLen = aLen < bLen ? aLen : bLen;\n    for(let i = 0; i < minLen; i++){\n        let cmp = a.charCodeAt(i) - b.charCodeAt(i);\n        if (cmp !== 0) return cmp;\n    }\n    return aLen - bLen;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}