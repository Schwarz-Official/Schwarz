{"ast":null,"code":"import { flowParseAssignableListItemTypes } from \"../plugins/flow\";\nimport { tsParseAssignableListItemTypes, tsParseModifiers } from \"../plugins/typescript\";\nimport { eat, IdentifierRole, match, next, popTypeContext, pushTypeContext } from \"../tokenizer/index\";\nimport { ContextualKeyword } from \"../tokenizer/keywords\";\nimport { TokenType, TokenType as tt } from \"../tokenizer/types\";\nimport { isFlowEnabled, isTypeScriptEnabled, state } from \"./base\";\nimport { parseIdentifier, parseMaybeAssign, parseObj } from \"./expression\";\nimport { expect, unexpected } from \"./util\";\nexport function parseSpread() {\n  next();\n  parseMaybeAssign(false);\n}\nexport function parseRest(isBlockScope) {\n  next();\n  parseBindingAtom(isBlockScope);\n}\nexport function parseBindingIdentifier(isBlockScope) {\n  parseIdentifier();\n  markPriorBindingIdentifier(isBlockScope);\n}\nexport function parseImportedIdentifier() {\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n}\nexport function markPriorBindingIdentifier(isBlockScope) {\n  let identifierRole;\n  if (state.scopeDepth === 0) {\n    identifierRole = IdentifierRole.TopLevelDeclaration;\n  } else if (isBlockScope) {\n    identifierRole = IdentifierRole.BlockScopedDeclaration;\n  } else {\n    identifierRole = IdentifierRole.FunctionScopedDeclaration;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n}\n\n// Parses lvalue (assignable) atom.\nexport function parseBindingAtom(isBlockScope) {\n  switch (state.type) {\n    case tt._this:\n      {\n        // In TypeScript, \"this\" may be the name of a parameter, so allow it.\n        const oldIsType = pushTypeContext(0);\n        next();\n        popTypeContext(oldIsType);\n        return;\n      }\n    case tt._yield:\n    case tt.name:\n      {\n        state.type = tt.name;\n        parseBindingIdentifier(isBlockScope);\n        return;\n      }\n    case tt.bracketL:\n      {\n        next();\n        parseBindingList(tt.bracketR, isBlockScope, true /* allowEmpty */);\n        return;\n      }\n    case tt.braceL:\n      parseObj(true, isBlockScope);\n      return;\n    default:\n      unexpected();\n  }\n}\nexport function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifiers = false, contextId = 0) {\n  let first = true;\n  let hasRemovedComma = false;\n  const firstItemTokenIndex = state.tokens.length;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      state.tokens[state.tokens.length - 1].contextId = contextId;\n      // After a \"this\" type in TypeScript, we need to set the following comma (if any) to also be\n      // a type token so that it will be removed.\n      if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {\n        state.tokens[state.tokens.length - 1].isType = true;\n        hasRemovedComma = true;\n      }\n    }\n    if (allowEmpty && match(tt.comma)) {\n      // Empty item; nothing further to parse for this item.\n    } else if (eat(close)) {\n      break;\n    } else if (match(tt.ellipsis)) {\n      parseRest(isBlockScope);\n      parseAssignableListItemTypes();\n      // Support rest element trailing commas allowed by TypeScript <2.9.\n      eat(TokenType.comma);\n      expect(close);\n      break;\n    } else {\n      parseAssignableListItem(allowModifiers, isBlockScope);\n    }\n  }\n}\nfunction parseAssignableListItem(allowModifiers, isBlockScope) {\n  if (allowModifiers) {\n    tsParseModifiers([ContextualKeyword._public, ContextualKeyword._protected, ContextualKeyword._private, ContextualKeyword._readonly, ContextualKeyword._override]);\n  }\n  parseMaybeDefault(isBlockScope);\n  parseAssignableListItemTypes();\n  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);\n}\n\nfunction parseAssignableListItemTypes() {\n  if (isFlowEnabled) {\n    flowParseAssignableListItemTypes();\n  } else if (isTypeScriptEnabled) {\n    tsParseAssignableListItemTypes();\n  }\n}\n\n// Parses assignment pattern around given atom if possible.\nexport function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {\n  if (!leftAlreadyParsed) {\n    parseBindingAtom(isBlockScope);\n  }\n  if (!eat(tt.eq)) {\n    return;\n  }\n  const eqIndex = state.tokens.length - 1;\n  parseMaybeAssign();\n  state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n}","map":{"version":3,"names":["flowParseAssignableListItemTypes","tsParseAssignableListItemTypes","tsParseModifiers","eat","IdentifierRole","match","next","popTypeContext","pushTypeContext","ContextualKeyword","TokenType","tt","isFlowEnabled","isTypeScriptEnabled","state","parseIdentifier","parseMaybeAssign","parseObj","expect","unexpected","parseSpread","parseRest","isBlockScope","parseBindingAtom","parseBindingIdentifier","markPriorBindingIdentifier","parseImportedIdentifier","tokens","length","identifierRole","ImportDeclaration","scopeDepth","TopLevelDeclaration","BlockScopedDeclaration","FunctionScopedDeclaration","type","_this","oldIsType","_yield","name","bracketL","parseBindingList","bracketR","braceL","close","allowEmpty","allowModifiers","contextId","first","hasRemovedComma","firstItemTokenIndex","error","comma","isType","ellipsis","parseAssignableListItemTypes","parseAssignableListItem","_public","_protected","_private","_readonly","_override","parseMaybeDefault","leftAlreadyParsed","eq","eqIndex","rhsEndIndex"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/traverser/lval.js"],"sourcesContent":["import {flowParseAssignableListItemTypes} from \"../plugins/flow\";\nimport {tsParseAssignableListItemTypes, tsParseModifiers} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {parseIdentifier, parseMaybeAssign, parseObj} from \"./expression\";\nimport {expect, unexpected} from \"./util\";\n\nexport function parseSpread() {\n  next();\n  parseMaybeAssign(false);\n}\n\nexport function parseRest(isBlockScope) {\n  next();\n  parseBindingAtom(isBlockScope);\n}\n\nexport function parseBindingIdentifier(isBlockScope) {\n  parseIdentifier();\n  markPriorBindingIdentifier(isBlockScope);\n}\n\nexport function parseImportedIdentifier() {\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n}\n\nexport function markPriorBindingIdentifier(isBlockScope) {\n  let identifierRole;\n  if (state.scopeDepth === 0) {\n    identifierRole = IdentifierRole.TopLevelDeclaration;\n  } else if (isBlockScope) {\n    identifierRole = IdentifierRole.BlockScopedDeclaration;\n  } else {\n    identifierRole = IdentifierRole.FunctionScopedDeclaration;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n}\n\n// Parses lvalue (assignable) atom.\nexport function parseBindingAtom(isBlockScope) {\n  switch (state.type) {\n    case tt._this: {\n      // In TypeScript, \"this\" may be the name of a parameter, so allow it.\n      const oldIsType = pushTypeContext(0);\n      next();\n      popTypeContext(oldIsType);\n      return;\n    }\n\n    case tt._yield:\n    case tt.name: {\n      state.type = tt.name;\n      parseBindingIdentifier(isBlockScope);\n      return;\n    }\n\n    case tt.bracketL: {\n      next();\n      parseBindingList(tt.bracketR, isBlockScope, true /* allowEmpty */);\n      return;\n    }\n\n    case tt.braceL:\n      parseObj(true, isBlockScope);\n      return;\n\n    default:\n      unexpected();\n  }\n}\n\nexport function parseBindingList(\n  close,\n  isBlockScope,\n  allowEmpty = false,\n  allowModifiers = false,\n  contextId = 0,\n) {\n  let first = true;\n\n  let hasRemovedComma = false;\n  const firstItemTokenIndex = state.tokens.length;\n\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      state.tokens[state.tokens.length - 1].contextId = contextId;\n      // After a \"this\" type in TypeScript, we need to set the following comma (if any) to also be\n      // a type token so that it will be removed.\n      if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {\n        state.tokens[state.tokens.length - 1].isType = true;\n        hasRemovedComma = true;\n      }\n    }\n    if (allowEmpty && match(tt.comma)) {\n      // Empty item; nothing further to parse for this item.\n    } else if (eat(close)) {\n      break;\n    } else if (match(tt.ellipsis)) {\n      parseRest(isBlockScope);\n      parseAssignableListItemTypes();\n      // Support rest element trailing commas allowed by TypeScript <2.9.\n      eat(TokenType.comma);\n      expect(close);\n      break;\n    } else {\n      parseAssignableListItem(allowModifiers, isBlockScope);\n    }\n  }\n}\n\nfunction parseAssignableListItem(allowModifiers, isBlockScope) {\n  if (allowModifiers) {\n    tsParseModifiers([\n      ContextualKeyword._public,\n      ContextualKeyword._protected,\n      ContextualKeyword._private,\n      ContextualKeyword._readonly,\n      ContextualKeyword._override,\n    ]);\n  }\n\n  parseMaybeDefault(isBlockScope);\n  parseAssignableListItemTypes();\n  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);\n}\n\nfunction parseAssignableListItemTypes() {\n  if (isFlowEnabled) {\n    flowParseAssignableListItemTypes();\n  } else if (isTypeScriptEnabled) {\n    tsParseAssignableListItemTypes();\n  }\n}\n\n// Parses assignment pattern around given atom if possible.\nexport function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {\n  if (!leftAlreadyParsed) {\n    parseBindingAtom(isBlockScope);\n  }\n  if (!eat(tt.eq)) {\n    return;\n  }\n  const eqIndex = state.tokens.length - 1;\n  parseMaybeAssign();\n  state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}