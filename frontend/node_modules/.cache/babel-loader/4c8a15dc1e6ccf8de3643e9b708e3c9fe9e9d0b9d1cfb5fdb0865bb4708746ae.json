{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return collapseDuplicateDeclarations;\n  }\n});\nfunction collapseDuplicateDeclarations() {\n  return root => {\n    root.walkRules(node => {\n      let seen = new Map();\n      let droppable = new Set([]);\n      let byProperty = new Map();\n      node.walkDecls(decl => {\n        // This could happen if we have nested selectors. In that case the\n        // parent will loop over all its declarations but also the declarations\n        // of nested rules. With this we ensure that we are shallowly checking\n        // declarations.\n        if (decl.parent !== node) {\n          return;\n        }\n        if (seen.has(decl.prop)) {\n          // Exact same value as what we have seen so far\n          if (seen.get(decl.prop).value === decl.value) {\n            // Keep the last one, drop the one we've seen so far\n            droppable.add(seen.get(decl.prop));\n            // Override the existing one with the new value. This is necessary\n            // so that if we happen to have more than one declaration with the\n            // same value, that we keep removing the previous one. Otherwise we\n            // will only remove the *first* one.\n            seen.set(decl.prop, decl);\n            return;\n          }\n          // Not the same value, so we need to check if we can merge it so\n          // let's collect it first.\n          if (!byProperty.has(decl.prop)) {\n            byProperty.set(decl.prop, new Set());\n          }\n          byProperty.get(decl.prop).add(seen.get(decl.prop));\n          byProperty.get(decl.prop).add(decl);\n        }\n        seen.set(decl.prop, decl);\n      });\n      // Drop all the duplicate declarations with the exact same value we've\n      // already seen so far.\n      for (let decl of droppable) {\n        decl.remove();\n      }\n      // Analyze the declarations based on its unit, drop all the declarations\n      // with the same unit but the last one in the list.\n      for (let declarations of byProperty.values()) {\n        let byUnit = new Map();\n        for (let decl of declarations) {\n          let unit = resolveUnit(decl.value);\n          if (unit === null) {\n            continue;\n          }\n          if (!byUnit.has(unit)) {\n            byUnit.set(unit, new Set());\n          }\n          byUnit.get(unit).add(decl);\n        }\n        for (let declarations of byUnit.values()) {\n          // Get all but the last one\n          let removableDeclarations = Array.from(declarations).slice(0, -1);\n          for (let decl of removableDeclarations) {\n            decl.remove();\n          }\n        }\n      }\n    });\n  };\n}\nlet UNITLESS_NUMBER = Symbol(\"unitless-number\");\nfunction resolveUnit(input) {\n  let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);\n  if (result) {\n    var _result_;\n    return (_result_ = result[1]) !== null && _result_ !== void 0 ? _result_ : UNITLESS_NUMBER;\n  }\n  return null;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","collapseDuplicateDeclarations","root","walkRules","node","seen","Map","droppable","Set","byProperty","walkDecls","decl","parent","has","prop","add","set","remove","declarations","values","byUnit","unit","resolveUnit","removableDeclarations","Array","from","slice","UNITLESS_NUMBER","Symbol","input","result","exec","_result_"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return collapseDuplicateDeclarations;\n    }\n});\nfunction collapseDuplicateDeclarations() {\n    return (root)=>{\n        root.walkRules((node)=>{\n            let seen = new Map();\n            let droppable = new Set([]);\n            let byProperty = new Map();\n            node.walkDecls((decl)=>{\n                // This could happen if we have nested selectors. In that case the\n                // parent will loop over all its declarations but also the declarations\n                // of nested rules. With this we ensure that we are shallowly checking\n                // declarations.\n                if (decl.parent !== node) {\n                    return;\n                }\n                if (seen.has(decl.prop)) {\n                    // Exact same value as what we have seen so far\n                    if (seen.get(decl.prop).value === decl.value) {\n                        // Keep the last one, drop the one we've seen so far\n                        droppable.add(seen.get(decl.prop));\n                        // Override the existing one with the new value. This is necessary\n                        // so that if we happen to have more than one declaration with the\n                        // same value, that we keep removing the previous one. Otherwise we\n                        // will only remove the *first* one.\n                        seen.set(decl.prop, decl);\n                        return;\n                    }\n                    // Not the same value, so we need to check if we can merge it so\n                    // let's collect it first.\n                    if (!byProperty.has(decl.prop)) {\n                        byProperty.set(decl.prop, new Set());\n                    }\n                    byProperty.get(decl.prop).add(seen.get(decl.prop));\n                    byProperty.get(decl.prop).add(decl);\n                }\n                seen.set(decl.prop, decl);\n            });\n            // Drop all the duplicate declarations with the exact same value we've\n            // already seen so far.\n            for (let decl of droppable){\n                decl.remove();\n            }\n            // Analyze the declarations based on its unit, drop all the declarations\n            // with the same unit but the last one in the list.\n            for (let declarations of byProperty.values()){\n                let byUnit = new Map();\n                for (let decl of declarations){\n                    let unit = resolveUnit(decl.value);\n                    if (unit === null) {\n                        continue;\n                    }\n                    if (!byUnit.has(unit)) {\n                        byUnit.set(unit, new Set());\n                    }\n                    byUnit.get(unit).add(decl);\n                }\n                for (let declarations of byUnit.values()){\n                    // Get all but the last one\n                    let removableDeclarations = Array.from(declarations).slice(0, -1);\n                    for (let decl of removableDeclarations){\n                        decl.remove();\n                    }\n                }\n            }\n        });\n    };\n}\nlet UNITLESS_NUMBER = Symbol(\"unitless-number\");\nfunction resolveUnit(input) {\n    let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);\n    if (result) {\n        var _result_;\n        return (_result_ = result[1]) !== null && _result_ !== void 0 ? _result_ : UNITLESS_NUMBER;\n    }\n    return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}