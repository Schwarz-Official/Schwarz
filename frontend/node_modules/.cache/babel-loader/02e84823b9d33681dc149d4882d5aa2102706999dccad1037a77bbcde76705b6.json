{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  formatVariantSelector: function () {\n    return formatVariantSelector;\n  },\n  eliminateIrrelevantSelectors: function () {\n    return eliminateIrrelevantSelectors;\n  },\n  finalizeSelector: function () {\n    return finalizeSelector;\n  },\n  handleMergePseudo: function () {\n    return handleMergePseudo;\n  }\n});\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/_interop_require_default(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/_interop_require_default(require(\"../util/prefixSelector\"));\nconst _pseudoElements = require(\"./pseudoElements\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, respectPrefix: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */\nlet MERGE = \":merge\";\nfunction formatVariantSelector(formats, {\n  context,\n  candidate\n}) {\n  var _context_tailwindConfig_prefix;\n  let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : \"\";\n  // Parse the format selector into an AST\n  let parsedFormats = formats.map(format => {\n    let ast = (0, _postcssselectorparser.default)().astSync(format.format);\n    return {\n      ...format,\n      ast: format.respectPrefix ? (0, _prefixSelector.default)(prefix, ast) : ast\n    };\n  });\n  // We start with the candidate selector\n  let formatAst = _postcssselectorparser.default.root({\n    nodes: [_postcssselectorparser.default.selector({\n      nodes: [_postcssselectorparser.default.className({\n        value: (0, _escapeClassName.default)(candidate)\n      })]\n    })]\n  });\n  // And iteratively merge each format selector into the candidate selector\n  for (let {\n    ast\n  } of parsedFormats) {\n    [formatAst, ast] = handleMergePseudo(formatAst, ast);\n    // 2. Merge the format selector into the current selector AST\n    ast.walkNesting(nesting => nesting.replaceWith(...formatAst.nodes[0].nodes));\n    // 3. Keep going!\n    formatAst = ast;\n  }\n  return formatAst;\n}\n/**\n * Given any node in a selector this gets the \"simple\" selector it's a part of\n * A simple selector is just a list of nodes without any combinators\n * Technically :is(), :not(), :has(), etc… can have combinators but those are nested\n * inside the relevant node and won't be picked up so they're fine to ignore\n *\n * @param {Node} node\n * @returns {Node[]}\n **/\nfunction simpleSelectorForNode(node) {\n  /** @type {Node[]} */let nodes = [];\n  // Walk backwards until we hit a combinator node (or the start)\n  while (node.prev() && node.prev().type !== \"combinator\") {\n    node = node.prev();\n  }\n  // Now record all non-combinator nodes until we hit one (or the end)\n  while (node && node.type !== \"combinator\") {\n    nodes.push(node);\n    node = node.next();\n  }\n  return nodes;\n}\n/**\n * Resorts the nodes in a selector to ensure they're in the correct order\n * Tags go before classes, and pseudo classes go after classes\n *\n * @param {Selector} sel\n * @returns {Selector}\n **/\nfunction resortSelector(sel) {\n  sel.sort((a, b) => {\n    if (a.type === \"tag\" && b.type === \"class\") {\n      return -1;\n    } else if (a.type === \"class\" && b.type === \"tag\") {\n      return 1;\n    } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n      return -1;\n    } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n      return 1;\n    }\n    return sel.index(a) - sel.index(b);\n  });\n  return sel;\n}\nfunction eliminateIrrelevantSelectors(sel, base) {\n  let hasClassesMatchingCandidate = false;\n  sel.walk(child => {\n    if (child.type === \"class\" && child.value === base) {\n      hasClassesMatchingCandidate = true;\n      return false // Stop walking\n      ;\n    }\n  });\n\n  if (!hasClassesMatchingCandidate) {\n    sel.remove();\n  }\n  // We do NOT recursively eliminate sub selectors that don't have the base class\n  // as this is NOT a safe operation. For example, if we have:\n  // `.space-x-2 > :not([hidden]) ~ :not([hidden])`\n  // We cannot remove the [hidden] from the :not() because it would change the\n  // meaning of the selector.\n  // TODO: Can we do this for :matches, :is, and :where?\n}\n\nfunction finalizeSelector(current, formats, {\n  context,\n  candidate,\n  base\n}) {\n  var _context_tailwindConfig;\n  var _context_tailwindConfig_separator;\n  let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : \":\";\n  // Split by the separator, but ignore the separator inside square brackets:\n  //\n  // E.g.: dark:lg:hover:[paint-order:markers]\n  //           ┬  ┬     ┬            ┬\n  //           │  │     │            ╰── We will not split here\n  //           ╰──┴─────┴─────────────── We will split here\n  //\n  base = base !== null && base !== void 0 ? base : candidate.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`)).pop();\n  // Parse the selector into an AST\n  let selector = (0, _postcssselectorparser.default)().astSync(current);\n  // Normalize escaped classes, e.g.:\n  //\n  // The idea would be to replace the escaped `base` in the selector with the\n  // `format`. However, in css you can escape the same selector in a few\n  // different ways. This would result in different strings and therefore we\n  // can't replace it properly.\n  //\n  //               base: bg-[rgb(255,0,0)]\n  //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n  //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n  //\n  selector.walkClasses(node => {\n    if (node.raws && node.value.includes(base)) {\n      node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n    }\n  });\n  // Remove extraneous selectors that do not include the base candidate\n  selector.each(sel => eliminateIrrelevantSelectors(sel, base));\n  // If there are no formats that means there were no variants added to the candidate\n  // so we can just return the selector as-is\n  let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {\n    context,\n    candidate\n  }) : formats;\n  if (formatAst === null) {\n    return selector.toString();\n  }\n  let simpleStart = _postcssselectorparser.default.comment({\n    value: \"/*__simple__*/\"\n  });\n  let simpleEnd = _postcssselectorparser.default.comment({\n    value: \"/*__simple__*/\"\n  });\n  // We can safely replace the escaped base now, since the `base` section is\n  // now in a normalized escaped value.\n  selector.walkClasses(node => {\n    if (node.value !== base) {\n      return;\n    }\n    let parent = node.parent;\n    let formatNodes = formatAst.nodes[0].nodes;\n    // Perf optimization: if the parent is a single class we can just replace it and be done\n    if (parent.nodes.length === 1) {\n      node.replaceWith(...formatNodes);\n      return;\n    }\n    let simpleSelector = simpleSelectorForNode(node);\n    parent.insertBefore(simpleSelector[0], simpleStart);\n    parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);\n    for (let child of formatNodes) {\n      parent.insertBefore(simpleSelector[0], child.clone());\n    }\n    node.remove();\n    // Re-sort the simple selector to ensure it's in the correct order\n    simpleSelector = simpleSelectorForNode(simpleStart);\n    let firstNode = parent.index(simpleStart);\n    parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssselectorparser.default.selector({\n      nodes: simpleSelector\n    })).nodes);\n    simpleStart.remove();\n    simpleEnd.remove();\n  });\n  // Remove unnecessary pseudo selectors that we used as placeholders\n  selector.walkPseudos(p => {\n    if (p.value === MERGE) {\n      p.replaceWith(p.nodes);\n    }\n  });\n  // Move pseudo elements to the end of the selector (if necessary)\n  selector.each(sel => (0, _pseudoElements.movePseudos)(sel));\n  return selector.toString();\n}\nfunction handleMergePseudo(selector, format) {\n  /** @type {{pseudo: Pseudo, value: string}[]} */let merges = [];\n  // Find all :merge() pseudo-classes in `selector`\n  selector.walkPseudos(pseudo => {\n    if (pseudo.value === MERGE) {\n      merges.push({\n        pseudo,\n        value: pseudo.nodes[0].toString()\n      });\n    }\n  });\n  // Find all :merge() \"attachments\" in `format` and attach them to the matching selector in `selector`\n  format.walkPseudos(pseudo => {\n    if (pseudo.value !== MERGE) {\n      return;\n    }\n    let value = pseudo.nodes[0].toString();\n    // Does `selector` contain a :merge() pseudo-class with the same value?\n    let existing = merges.find(merge => merge.value === value);\n    // Nope so there's nothing to do\n    if (!existing) {\n      return;\n    }\n    // Everything after `:merge()` up to the next combinator is what is attached to the merged selector\n    let attachments = [];\n    let next = pseudo.next();\n    while (next && next.type !== \"combinator\") {\n      attachments.push(next);\n      next = next.next();\n    }\n    let combinator = next;\n    existing.pseudo.parent.insertAfter(existing.pseudo, _postcssselectorparser.default.selector({\n      nodes: attachments.map(node => node.clone())\n    }));\n    pseudo.remove();\n    attachments.forEach(node => node.remove());\n    // What about this case:\n    // :merge(.group):focus > &\n    // :merge(.group):hover &\n    if (combinator && combinator.type === \"combinator\") {\n      combinator.remove();\n    }\n  });\n  return [selector, format];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","formatVariantSelector","eliminateIrrelevantSelectors","finalizeSelector","handleMergePseudo","_postcssselectorparser","_interop_require_default","require","_unesc","_escapeClassName","_prefixSelector","_pseudoElements","obj","__esModule","default","MERGE","formats","context","candidate","_context_tailwindConfig_prefix","prefix","tailwindConfig","parsedFormats","map","format","ast","astSync","respectPrefix","formatAst","root","nodes","selector","className","walkNesting","nesting","replaceWith","simpleSelectorForNode","node","prev","type","push","next","resortSelector","sel","sort","a","b","startsWith","index","base","hasClassesMatchingCandidate","walk","child","remove","current","_context_tailwindConfig","_context_tailwindConfig_separator","separator","split","RegExp","pop","walkClasses","raws","includes","each","Array","isArray","toString","simpleStart","comment","simpleEnd","parent","formatNodes","length","simpleSelector","insertBefore","insertAfter","clone","firstNode","splice","walkPseudos","p","movePseudos","merges","pseudo","existing","find","merge","attachments","combinator","forEach"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/util/formatVariantSelector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatVariantSelector: function() {\n        return formatVariantSelector;\n    },\n    eliminateIrrelevantSelectors: function() {\n        return eliminateIrrelevantSelectors;\n    },\n    finalizeSelector: function() {\n        return finalizeSelector;\n    },\n    handleMergePseudo: function() {\n        return handleMergePseudo;\n    }\n});\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _pseudoElements = require(\"./pseudoElements\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, respectPrefix: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */ let MERGE = \":merge\";\nfunction formatVariantSelector(formats, { context , candidate  }) {\n    var _context_tailwindConfig_prefix;\n    let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : \"\";\n    // Parse the format selector into an AST\n    let parsedFormats = formats.map((format)=>{\n        let ast = (0, _postcssselectorparser.default)().astSync(format.format);\n        return {\n            ...format,\n            ast: format.respectPrefix ? (0, _prefixSelector.default)(prefix, ast) : ast\n        };\n    });\n    // We start with the candidate selector\n    let formatAst = _postcssselectorparser.default.root({\n        nodes: [\n            _postcssselectorparser.default.selector({\n                nodes: [\n                    _postcssselectorparser.default.className({\n                        value: (0, _escapeClassName.default)(candidate)\n                    })\n                ]\n            })\n        ]\n    });\n    // And iteratively merge each format selector into the candidate selector\n    for (let { ast  } of parsedFormats){\n        [formatAst, ast] = handleMergePseudo(formatAst, ast);\n        // 2. Merge the format selector into the current selector AST\n        ast.walkNesting((nesting)=>nesting.replaceWith(...formatAst.nodes[0].nodes));\n        // 3. Keep going!\n        formatAst = ast;\n    }\n    return formatAst;\n}\n/**\n * Given any node in a selector this gets the \"simple\" selector it's a part of\n * A simple selector is just a list of nodes without any combinators\n * Technically :is(), :not(), :has(), etc… can have combinators but those are nested\n * inside the relevant node and won't be picked up so they're fine to ignore\n *\n * @param {Node} node\n * @returns {Node[]}\n **/ function simpleSelectorForNode(node) {\n    /** @type {Node[]} */ let nodes = [];\n    // Walk backwards until we hit a combinator node (or the start)\n    while(node.prev() && node.prev().type !== \"combinator\"){\n        node = node.prev();\n    }\n    // Now record all non-combinator nodes until we hit one (or the end)\n    while(node && node.type !== \"combinator\"){\n        nodes.push(node);\n        node = node.next();\n    }\n    return nodes;\n}\n/**\n * Resorts the nodes in a selector to ensure they're in the correct order\n * Tags go before classes, and pseudo classes go after classes\n *\n * @param {Selector} sel\n * @returns {Selector}\n **/ function resortSelector(sel) {\n    sel.sort((a, b)=>{\n        if (a.type === \"tag\" && b.type === \"class\") {\n            return -1;\n        } else if (a.type === \"class\" && b.type === \"tag\") {\n            return 1;\n        } else if (a.type === \"class\" && b.type === \"pseudo\" && b.value.startsWith(\"::\")) {\n            return -1;\n        } else if (a.type === \"pseudo\" && a.value.startsWith(\"::\") && b.type === \"class\") {\n            return 1;\n        }\n        return sel.index(a) - sel.index(b);\n    });\n    return sel;\n}\nfunction eliminateIrrelevantSelectors(sel, base) {\n    let hasClassesMatchingCandidate = false;\n    sel.walk((child)=>{\n        if (child.type === \"class\" && child.value === base) {\n            hasClassesMatchingCandidate = true;\n            return false // Stop walking\n            ;\n        }\n    });\n    if (!hasClassesMatchingCandidate) {\n        sel.remove();\n    }\n// We do NOT recursively eliminate sub selectors that don't have the base class\n// as this is NOT a safe operation. For example, if we have:\n// `.space-x-2 > :not([hidden]) ~ :not([hidden])`\n// We cannot remove the [hidden] from the :not() because it would change the\n// meaning of the selector.\n// TODO: Can we do this for :matches, :is, and :where?\n}\nfunction finalizeSelector(current, formats, { context , candidate , base  }) {\n    var _context_tailwindConfig;\n    var _context_tailwindConfig_separator;\n    let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : \":\";\n    // Split by the separator, but ignore the separator inside square brackets:\n    //\n    // E.g.: dark:lg:hover:[paint-order:markers]\n    //           ┬  ┬     ┬            ┬\n    //           │  │     │            ╰── We will not split here\n    //           ╰──┴─────┴─────────────── We will split here\n    //\n    base = base !== null && base !== void 0 ? base : candidate.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`)).pop();\n    // Parse the selector into an AST\n    let selector = (0, _postcssselectorparser.default)().astSync(current);\n    // Normalize escaped classes, e.g.:\n    //\n    // The idea would be to replace the escaped `base` in the selector with the\n    // `format`. However, in css you can escape the same selector in a few\n    // different ways. This would result in different strings and therefore we\n    // can't replace it properly.\n    //\n    //               base: bg-[rgb(255,0,0)]\n    //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n    //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n    //\n    selector.walkClasses((node)=>{\n        if (node.raws && node.value.includes(base)) {\n            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n        }\n    });\n    // Remove extraneous selectors that do not include the base candidate\n    selector.each((sel)=>eliminateIrrelevantSelectors(sel, base));\n    // If there are no formats that means there were no variants added to the candidate\n    // so we can just return the selector as-is\n    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {\n        context,\n        candidate\n    }) : formats;\n    if (formatAst === null) {\n        return selector.toString();\n    }\n    let simpleStart = _postcssselectorparser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    let simpleEnd = _postcssselectorparser.default.comment({\n        value: \"/*__simple__*/\"\n    });\n    // We can safely replace the escaped base now, since the `base` section is\n    // now in a normalized escaped value.\n    selector.walkClasses((node)=>{\n        if (node.value !== base) {\n            return;\n        }\n        let parent = node.parent;\n        let formatNodes = formatAst.nodes[0].nodes;\n        // Perf optimization: if the parent is a single class we can just replace it and be done\n        if (parent.nodes.length === 1) {\n            node.replaceWith(...formatNodes);\n            return;\n        }\n        let simpleSelector = simpleSelectorForNode(node);\n        parent.insertBefore(simpleSelector[0], simpleStart);\n        parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);\n        for (let child of formatNodes){\n            parent.insertBefore(simpleSelector[0], child.clone());\n        }\n        node.remove();\n        // Re-sort the simple selector to ensure it's in the correct order\n        simpleSelector = simpleSelectorForNode(simpleStart);\n        let firstNode = parent.index(simpleStart);\n        parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssselectorparser.default.selector({\n            nodes: simpleSelector\n        })).nodes);\n        simpleStart.remove();\n        simpleEnd.remove();\n    });\n    // Remove unnecessary pseudo selectors that we used as placeholders\n    selector.walkPseudos((p)=>{\n        if (p.value === MERGE) {\n            p.replaceWith(p.nodes);\n        }\n    });\n    // Move pseudo elements to the end of the selector (if necessary)\n    selector.each((sel)=>(0, _pseudoElements.movePseudos)(sel));\n    return selector.toString();\n}\nfunction handleMergePseudo(selector, format) {\n    /** @type {{pseudo: Pseudo, value: string}[]} */ let merges = [];\n    // Find all :merge() pseudo-classes in `selector`\n    selector.walkPseudos((pseudo)=>{\n        if (pseudo.value === MERGE) {\n            merges.push({\n                pseudo,\n                value: pseudo.nodes[0].toString()\n            });\n        }\n    });\n    // Find all :merge() \"attachments\" in `format` and attach them to the matching selector in `selector`\n    format.walkPseudos((pseudo)=>{\n        if (pseudo.value !== MERGE) {\n            return;\n        }\n        let value = pseudo.nodes[0].toString();\n        // Does `selector` contain a :merge() pseudo-class with the same value?\n        let existing = merges.find((merge)=>merge.value === value);\n        // Nope so there's nothing to do\n        if (!existing) {\n            return;\n        }\n        // Everything after `:merge()` up to the next combinator is what is attached to the merged selector\n        let attachments = [];\n        let next = pseudo.next();\n        while(next && next.type !== \"combinator\"){\n            attachments.push(next);\n            next = next.next();\n        }\n        let combinator = next;\n        existing.pseudo.parent.insertAfter(existing.pseudo, _postcssselectorparser.default.selector({\n            nodes: attachments.map((node)=>node.clone())\n        }));\n        pseudo.remove();\n        attachments.forEach((node)=>node.remove());\n        // What about this case:\n        // :merge(.group):focus > &\n        // :merge(.group):hover &\n        if (combinator && combinator.type === \"combinator\") {\n            combinator.remove();\n        }\n    });\n    return [\n        selector,\n        format\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}