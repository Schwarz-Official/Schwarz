{"ast":null,"code":"/* eslint max-len: 0 */\n\nimport { input, isFlowEnabled, state } from \"../traverser/base\";\nimport { unexpected } from \"../traverser/util\";\nimport { charCodes } from \"../util/charcodes\";\nimport { IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START } from \"../util/identifier\";\nimport { IS_WHITESPACE, skipWhiteSpace } from \"../util/whitespace\";\nimport { ContextualKeyword } from \"./keywords\";\nimport readWord from \"./readWord\";\nimport { TokenType as tt } from \"./types\";\nexport var IdentifierRole;\n(function (IdentifierRole) {\n  const Access = 0;\n  IdentifierRole[IdentifierRole[\"Access\"] = Access] = \"Access\";\n  const ExportAccess = Access + 1;\n  IdentifierRole[IdentifierRole[\"ExportAccess\"] = ExportAccess] = \"ExportAccess\";\n  const TopLevelDeclaration = ExportAccess + 1;\n  IdentifierRole[IdentifierRole[\"TopLevelDeclaration\"] = TopLevelDeclaration] = \"TopLevelDeclaration\";\n  const FunctionScopedDeclaration = TopLevelDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"FunctionScopedDeclaration\"] = FunctionScopedDeclaration] = \"FunctionScopedDeclaration\";\n  const BlockScopedDeclaration = FunctionScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"BlockScopedDeclaration\"] = BlockScopedDeclaration] = \"BlockScopedDeclaration\";\n  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthandTopLevelDeclaration\"] = ObjectShorthandTopLevelDeclaration] = \"ObjectShorthandTopLevelDeclaration\";\n  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthandFunctionScopedDeclaration\"] = ObjectShorthandFunctionScopedDeclaration] = \"ObjectShorthandFunctionScopedDeclaration\";\n  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthandBlockScopedDeclaration\"] = ObjectShorthandBlockScopedDeclaration] = \"ObjectShorthandBlockScopedDeclaration\";\n  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectShorthand\"] = ObjectShorthand] = \"ObjectShorthand\";\n  // Any identifier bound in an import statement, e.g. both A and b from\n  // `import A, * as b from 'A';`\n  const ImportDeclaration = ObjectShorthand + 1;\n  IdentifierRole[IdentifierRole[\"ImportDeclaration\"] = ImportDeclaration] = \"ImportDeclaration\";\n  const ObjectKey = ImportDeclaration + 1;\n  IdentifierRole[IdentifierRole[\"ObjectKey\"] = ObjectKey] = \"ObjectKey\";\n  // The `foo` in `import {foo as bar} from \"./abc\";`.\n  const ImportAccess = ObjectKey + 1;\n  IdentifierRole[IdentifierRole[\"ImportAccess\"] = ImportAccess] = \"ImportAccess\";\n})(IdentifierRole || (IdentifierRole = {}));\n\n/**\n * Extra information on jsxTagStart tokens, used to determine which of the three\n * jsx functions are called in the automatic transform.\n */\nexport var JSXRole;\n(function (JSXRole) {\n  // The element is self-closing or has a body that resolves to empty. We\n  // shouldn't emit children at all in this case.\n  const NoChildren = 0;\n  JSXRole[JSXRole[\"NoChildren\"] = NoChildren] = \"NoChildren\";\n  // The element has a single explicit child, which might still be an arbitrary\n  // expression like an array. We should emit that expression as the children.\n  const OneChild = NoChildren + 1;\n  JSXRole[JSXRole[\"OneChild\"] = OneChild] = \"OneChild\";\n  // The element has at least two explicitly-specified children or has spread\n  // children, so child positions are assumed to be \"static\". We should wrap\n  // these children in an array.\n  const StaticChildren = OneChild + 1;\n  JSXRole[JSXRole[\"StaticChildren\"] = StaticChildren] = \"StaticChildren\";\n  // The element has a prop named \"key\" after a prop spread, so we should fall\n  // back to the createElement function.\n  const KeyAfterPropSpread = StaticChildren + 1;\n  JSXRole[JSXRole[\"KeyAfterPropSpread\"] = KeyAfterPropSpread] = \"KeyAfterPropSpread\";\n})(JSXRole || (JSXRole = {}));\nexport function isDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n}\nexport function isNonTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n}\nexport function isTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;\n}\nexport function isBlockScopedDeclaration(token) {\n  const role = token.identifierRole;\n  // Treat top-level declarations as block scope since the distinction doesn't matter here.\n  return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n}\nexport function isFunctionScopedDeclaration(token) {\n  const role = token.identifierRole;\n  return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n}\nexport function isObjectShorthandDeclaration(token) {\n  return token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nexport class Token {\n  constructor() {\n    this.type = state.type;\n    this.contextualKeyword = state.contextualKeyword;\n    this.start = state.start;\n    this.end = state.end;\n    this.scopeDepth = state.scopeDepth;\n    this.isType = state.isType;\n    this.identifierRole = null;\n    this.jsxRole = null;\n    this.shadowsGlobal = false;\n    this.isAsyncOperation = false;\n    this.contextId = null;\n    this.rhsEndIndex = null;\n    this.isExpression = false;\n    this.numNullishCoalesceStarts = 0;\n    this.numNullishCoalesceEnds = 0;\n    this.isOptionalChainStart = false;\n    this.isOptionalChainEnd = false;\n    this.subscriptStartIndex = null;\n    this.nullishStartIndex = null;\n  }\n\n  // Initially false for all tokens, then may be computed in a follow-up step that does scope\n  // analysis.\n\n  // Initially false for all tokens, but may be set during transform to mark it as containing an\n  // await operation.\n\n  // For assignments, the index of the RHS. For export tokens, the end of the export.\n\n  // For class tokens, records if the class is a class expression or a class statement.\n\n  // Number of times to insert a `nullishCoalesce(` snippet before this token.\n\n  // Number of times to insert a `)` snippet after this token.\n\n  // If true, insert an `optionalChain([` snippet before this token.\n\n  // If true, insert a `])` snippet after this token.\n\n  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the \"root\" token for this\n  // subscript chain. This can be used to determine if this chain is an optional chain.\n\n  // Tag for `??` operators to denote the root token for this nullish coalescing call.\n}\n\n// ## Tokenizer\n\n// Move to the next token\nexport function next() {\n  state.tokens.push(new Token());\n  nextToken();\n}\n\n// Call instead of next when inside a template, since that needs to be handled differently.\nexport function nextTemplateToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  readTmplToken();\n}\n\n// The tokenizer never parses regexes by default. Instead, the parser is responsible for\n// instructing it to parse a regex when we see a slash at the start of an expression.\nexport function retokenizeSlashAsRegex() {\n  if (state.type === tt.assign) {\n    --state.pos;\n  }\n  readRegexp();\n}\nexport function pushTypeContext(existingTokensInType) {\n  for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {\n    state.tokens[i].isType = true;\n  }\n  const oldIsType = state.isType;\n  state.isType = true;\n  return oldIsType;\n}\nexport function popTypeContext(oldIsType) {\n  state.isType = oldIsType;\n}\nexport function eat(type) {\n  if (match(type)) {\n    next();\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function eatTypeToken(tokenType) {\n  const oldIsType = state.isType;\n  state.isType = true;\n  eat(tokenType);\n  state.isType = oldIsType;\n}\nexport function match(type) {\n  return state.type === type;\n}\nexport function lookaheadType() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  state.restoreFromSnapshot(snapshot);\n  return type;\n}\nexport class TypeAndKeyword {\n  constructor(type, contextualKeyword) {\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n  }\n}\nexport function lookaheadTypeAndKeyword() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  const contextualKeyword = state.contextualKeyword;\n  state.restoreFromSnapshot(snapshot);\n  return new TypeAndKeyword(type, contextualKeyword);\n}\nexport function nextTokenStart() {\n  return nextTokenStartSince(state.pos);\n}\nexport function nextTokenStartSince(pos) {\n  skipWhiteSpace.lastIndex = pos;\n  const skip = skipWhiteSpace.exec(input);\n  return pos + skip[0].length;\n}\nexport function lookaheadCharCode() {\n  return input.charCodeAt(nextTokenStart());\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\nexport function nextToken() {\n  skipSpace();\n  state.start = state.pos;\n  if (state.pos >= input.length) {\n    const tokens = state.tokens;\n    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.\n    // Also check the token positions rather than the types since sometimes we rewrite the token\n    // type to something else.\n    if (tokens.length >= 2 && tokens[tokens.length - 1].start >= input.length && tokens[tokens.length - 2].start >= input.length) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n    }\n    finishToken(tt.eof);\n    return;\n  }\n  readToken(input.charCodeAt(state.pos));\n}\nfunction readToken(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (IS_IDENTIFIER_START[code] || code === charCodes.backslash || code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign) {\n    readWord();\n  } else {\n    getTokenFromCode(code);\n  }\n}\nfunction skipBlockComment() {\n  while (input.charCodeAt(state.pos) !== charCodes.asterisk || input.charCodeAt(state.pos + 1) !== charCodes.slash) {\n    state.pos++;\n    if (state.pos > input.length) {\n      unexpected(\"Unterminated comment\", state.pos - 2);\n      return;\n    }\n  }\n  state.pos += 2;\n}\nexport function skipLineComment(startSkip) {\n  let ch = input.charCodeAt(state.pos += startSkip);\n  if (state.pos < input.length) {\n    while (ch !== charCodes.lineFeed && ch !== charCodes.carriageReturn && ch !== charCodes.lineSeparator && ch !== charCodes.paragraphSeparator && ++state.pos < input.length) {\n      ch = input.charCodeAt(state.pos);\n    }\n  }\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments.\nexport function skipSpace() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    switch (ch) {\n      case charCodes.carriageReturn:\n        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {\n          ++state.pos;\n        }\n      case charCodes.lineFeed:\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        ++state.pos;\n        break;\n      case charCodes.slash:\n        switch (input.charCodeAt(state.pos + 1)) {\n          case charCodes.asterisk:\n            state.pos += 2;\n            skipBlockComment();\n            break;\n          case charCodes.slash:\n            skipLineComment(2);\n            break;\n          default:\n            return;\n        }\n        break;\n      default:\n        if (IS_WHITESPACE[ch]) {\n          ++state.pos;\n        } else {\n          return;\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets various fields, and skips the space after the token, so\n// that the next one's `start` will point at the right position.\nexport function finishToken(type, contextualKeyword = ContextualKeyword.NONE) {\n  state.end = state.pos;\n  state.type = type;\n  state.contextualKeyword = contextualKeyword;\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\nfunction readToken_dot() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {\n    readNumber(true);\n    return;\n  }\n  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {\n    state.pos += 3;\n    finishToken(tt.ellipsis);\n  } else {\n    ++state.pos;\n    finishToken(tt.dot);\n  }\n}\nfunction readToken_slash() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.slash, 1);\n  }\n}\nfunction readToken_mult_modulo(code) {\n  // '%*'\n  let tokenType = code === charCodes.asterisk ? tt.star : tt.modulo;\n  let width = 1;\n  let nextChar = input.charCodeAt(state.pos + 1);\n\n  // Exponentiation operator **\n  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {\n    width++;\n    nextChar = input.charCodeAt(state.pos + 2);\n    tokenType = tt.exponent;\n  }\n\n  // Match *= or %=, disallowing *=> which can be valid in flow.\n  if (nextChar === charCodes.equalsTo && input.charCodeAt(state.pos + 2) !== charCodes.greaterThan) {\n    width++;\n    tokenType = tt.assign;\n  }\n  finishOp(tokenType, width);\n}\nfunction readToken_pipe_amp(code) {\n  // '|&'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === code) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      // ||= or &&=\n      finishOp(tt.assign, 3);\n    } else {\n      // || or &&\n      finishOp(code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND, 2);\n    }\n    return;\n  }\n  if (code === charCodes.verticalBar) {\n    // '|>'\n    if (nextChar === charCodes.greaterThan) {\n      finishOp(tt.pipeline, 2);\n      return;\n    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {\n      // '|}'\n      finishOp(tt.braceBarR, 2);\n      return;\n    }\n  }\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n    return;\n  }\n  finishOp(code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND, 1);\n}\nfunction readToken_caret() {\n  // '^'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.bitwiseXOR, 1);\n  }\n}\nfunction readToken_plus_min(code) {\n  // '+-'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === code) {\n    // Tentatively call this a prefix operator, but it might be changed to postfix later.\n    finishOp(tt.preIncDec, 2);\n    return;\n  }\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else if (code === charCodes.plusSign) {\n    finishOp(tt.plus, 1);\n  } else {\n    finishOp(tt.minus, 1);\n  }\n}\nfunction readToken_lt() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.lessThan) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      finishOp(tt.assign, 3);\n      return;\n    }\n    // We see <<, but need to be really careful about whether to treat it as a\n    // true left-shift or as two < tokens.\n    if (state.isType) {\n      // Within a type, << might come up in a snippet like `Array<<T>() => void>`,\n      // so treat it as two < tokens. Importantly, this should only override <<\n      // rather than other tokens like <= . If we treated <= as < in a type\n      // context, then the snippet `a as T <= 1` would incorrectly start parsing\n      // a type argument on T. We don't need to worry about `a as T << 1`\n      // because TypeScript disallows that syntax.\n      finishOp(tt.lessThan, 1);\n    } else {\n      // Outside a type, this might be a true left-shift operator, or it might\n      // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We\n      // look at the token while considering the `f`, so we don't yet know that\n      // we're in a type context. In this case, we initially tokenize as a\n      // left-shift and correct after-the-fact as necessary in\n      // tsParseTypeArgumentsWithPossibleBitshift .\n      finishOp(tt.bitShiftL, 2);\n    }\n    return;\n  }\n  if (nextChar === charCodes.equalsTo) {\n    // <=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.lessThan, 1);\n  }\n}\nfunction readToken_gt() {\n  if (state.isType) {\n    // Avoid right-shift for things like `Array<Array<string>>` and\n    // greater-than-or-equal for things like `const a: Array<number>=[];`.\n    finishOp(tt.greaterThan, 1);\n    return;\n  }\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.greaterThan) {\n    const size = input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;\n    if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {\n      finishOp(tt.assign, size + 1);\n      return;\n    }\n    finishOp(tt.bitShiftR, size);\n    return;\n  }\n  if (nextChar === charCodes.equalsTo) {\n    // >=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.greaterThan, 1);\n  }\n}\n\n/**\n * Reinterpret a possible > token when transitioning from a type to a non-type\n * context.\n *\n * This comes up in two situations where >= needs to be treated as one token:\n * - After an `as` expression, like in the code `a as T >= 1`.\n * - In a type argument in an expression context, e.g. `f(a < b, c >= d)`, we\n *   need to see the token as >= so that we get an error and backtrack to\n *   normal expression parsing.\n *\n * Other situations require >= to be seen as two tokens, e.g.\n * `const x: Array<T>=[];`, so it's important to treat > as its own token in\n * typical type parsing situations.\n */\nexport function rescan_gt() {\n  if (state.type === tt.greaterThan) {\n    state.pos -= 1;\n    readToken_gt();\n  }\n}\nfunction readToken_eq_excl(code) {\n  // '=!'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);\n    return;\n  }\n  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {\n    // '=>'\n    state.pos += 2;\n    finishToken(tt.arrow);\n    return;\n  }\n  finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n}\nfunction readToken_question() {\n  // '?'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  const nextChar2 = input.charCodeAt(state.pos + 2);\n  if (nextChar === charCodes.questionMark &&\n  // In Flow (but not TypeScript), ??string is a valid type that should be\n  // tokenized as two individual ? tokens.\n  !(isFlowEnabled && state.isType)) {\n    if (nextChar2 === charCodes.equalsTo) {\n      // '??='\n      finishOp(tt.assign, 3);\n    } else {\n      // '??'\n      finishOp(tt.nullishCoalescing, 2);\n    }\n  } else if (nextChar === charCodes.dot && !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)) {\n    // '.' not followed by a number\n    state.pos += 2;\n    finishToken(tt.questionDot);\n  } else {\n    ++state.pos;\n    finishToken(tt.question);\n  }\n}\nexport function getTokenFromCode(code) {\n  switch (code) {\n    case charCodes.numberSign:\n      ++state.pos;\n      finishToken(tt.hash);\n      return;\n\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n\n    case charCodes.dot:\n      readToken_dot();\n      return;\n\n    // Punctuation tokens.\n    case charCodes.leftParenthesis:\n      ++state.pos;\n      finishToken(tt.parenL);\n      return;\n    case charCodes.rightParenthesis:\n      ++state.pos;\n      finishToken(tt.parenR);\n      return;\n    case charCodes.semicolon:\n      ++state.pos;\n      finishToken(tt.semi);\n      return;\n    case charCodes.comma:\n      ++state.pos;\n      finishToken(tt.comma);\n      return;\n    case charCodes.leftSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketL);\n      return;\n    case charCodes.rightSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketR);\n      return;\n    case charCodes.leftCurlyBrace:\n      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {\n        finishOp(tt.braceBarL, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.braceL);\n      }\n      return;\n    case charCodes.rightCurlyBrace:\n      ++state.pos;\n      finishToken(tt.braceR);\n      return;\n    case charCodes.colon:\n      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {\n        finishOp(tt.doubleColon, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.colon);\n      }\n      return;\n    case charCodes.questionMark:\n      readToken_question();\n      return;\n    case charCodes.atSign:\n      ++state.pos;\n      finishToken(tt.at);\n      return;\n    case charCodes.graveAccent:\n      ++state.pos;\n      finishToken(tt.backQuote);\n      return;\n    case charCodes.digit0:\n      {\n        const nextChar = input.charCodeAt(state.pos + 1);\n        // '0x', '0X', '0o', '0O', '0b', '0B'\n        if (nextChar === charCodes.lowercaseX || nextChar === charCodes.uppercaseX || nextChar === charCodes.lowercaseO || nextChar === charCodes.uppercaseO || nextChar === charCodes.lowercaseB || nextChar === charCodes.uppercaseB) {\n          readRadixNumber();\n          return;\n        }\n      }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case charCodes.digit1:\n    case charCodes.digit2:\n    case charCodes.digit3:\n    case charCodes.digit4:\n    case charCodes.digit5:\n    case charCodes.digit6:\n    case charCodes.digit7:\n    case charCodes.digit8:\n    case charCodes.digit9:\n      readNumber(false);\n      return;\n\n    // Quotes produce strings.\n    case charCodes.quotationMark:\n    case charCodes.apostrophe:\n      readString(code);\n      return;\n\n    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case charCodes.slash:\n      readToken_slash();\n      return;\n    case charCodes.percentSign:\n    case charCodes.asterisk:\n      readToken_mult_modulo(code);\n      return;\n    case charCodes.verticalBar:\n    case charCodes.ampersand:\n      readToken_pipe_amp(code);\n      return;\n    case charCodes.caret:\n      readToken_caret();\n      return;\n    case charCodes.plusSign:\n    case charCodes.dash:\n      readToken_plus_min(code);\n      return;\n    case charCodes.lessThan:\n      readToken_lt();\n      return;\n    case charCodes.greaterThan:\n      readToken_gt();\n      return;\n    case charCodes.equalsTo:\n    case charCodes.exclamationMark:\n      readToken_eq_excl(code);\n      return;\n    case charCodes.tilde:\n      finishOp(tt.tilde, 1);\n      return;\n    default:\n      break;\n  }\n  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);\n}\nfunction finishOp(type, size) {\n  state.pos += size;\n  finishToken(type);\n}\nfunction readRegexp() {\n  const start = state.pos;\n  let escaped = false;\n  let inClass = false;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated regular expression\", start);\n      return;\n    }\n    const code = input.charCodeAt(state.pos);\n    if (escaped) {\n      escaped = false;\n    } else {\n      if (code === charCodes.leftSquareBracket) {\n        inClass = true;\n      } else if (code === charCodes.rightSquareBracket && inClass) {\n        inClass = false;\n      } else if (code === charCodes.slash && !inClass) {\n        break;\n      }\n      escaped = code === charCodes.backslash;\n    }\n    ++state.pos;\n  }\n  ++state.pos;\n  // Need to use `skipWord` because '\\uXXXX' sequences are allowed here (don't ask).\n  skipWord();\n  finishToken(tt.regexp);\n}\n\n/**\n * Read a decimal integer. Note that this can't be unified with the similar code\n * in readRadixNumber (which also handles hex digits) because \"e\" needs to be\n * the end of the integer so that we can properly handle scientific notation.\n */\nfunction readInt() {\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code === charCodes.underscore) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n}\nfunction readRadixNumber() {\n  state.pos += 2; // 0x\n\n  // Walk to the end of the number, allowing hex digits.\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF || code === charCodes.underscore) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n  const nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    finishToken(tt.bigint);\n  } else {\n    finishToken(tt.num);\n  }\n}\n\n// Read an integer, octal integer, or floating-point number.\nfunction readNumber(startsWithDot) {\n  let isBigInt = false;\n  let isDecimal = false;\n  if (!startsWithDot) {\n    readInt();\n  }\n  let nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.dot) {\n    ++state.pos;\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {\n    nextChar = input.charCodeAt(++state.pos);\n    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {\n      ++state.pos;\n    }\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  } else if (nextChar === charCodes.lowercaseM) {\n    ++state.pos;\n    isDecimal = true;\n  }\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n  if (isDecimal) {\n    finishToken(tt.decimal);\n    return;\n  }\n  finishToken(tt.num);\n}\nfunction readString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    } else if (ch === quote) {\n      break;\n    }\n    state.pos++;\n  }\n  state.pos++;\n  finishToken(tt.string);\n}\n\n// Reads template string tokens.\nfunction readTmplToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated template\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.graveAccent || ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace) {\n      if (state.pos === state.start && match(tt.template)) {\n        if (ch === charCodes.dollarSign) {\n          state.pos += 2;\n          finishToken(tt.dollarBraceL);\n          return;\n        } else {\n          ++state.pos;\n          finishToken(tt.backQuote);\n          return;\n        }\n      }\n      finishToken(tt.template);\n      return;\n    }\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    }\n    state.pos++;\n  }\n}\n\n// Skip to the end of the current word. Note that this is the same as the snippet at the end of\n// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough\n// measurements.\nexport function skipWord() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      state.pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      state.pos += 2;\n      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {\n        while (state.pos < input.length && input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace) {\n          state.pos++;\n        }\n        state.pos++;\n      }\n    } else {\n      break;\n    }\n  }\n}","map":{"version":3,"names":["input","isFlowEnabled","state","unexpected","charCodes","IS_IDENTIFIER_CHAR","IS_IDENTIFIER_START","IS_WHITESPACE","skipWhiteSpace","ContextualKeyword","readWord","TokenType","tt","IdentifierRole","Access","ExportAccess","TopLevelDeclaration","FunctionScopedDeclaration","BlockScopedDeclaration","ObjectShorthandTopLevelDeclaration","ObjectShorthandFunctionScopedDeclaration","ObjectShorthandBlockScopedDeclaration","ObjectShorthand","ImportDeclaration","ObjectKey","ImportAccess","JSXRole","NoChildren","OneChild","StaticChildren","KeyAfterPropSpread","isDeclaration","token","role","identifierRole","isNonTopLevelDeclaration","isTopLevelDeclaration","isBlockScopedDeclaration","isFunctionScopedDeclaration","isObjectShorthandDeclaration","Token","constructor","type","contextualKeyword","start","end","scopeDepth","isType","jsxRole","shadowsGlobal","isAsyncOperation","contextId","rhsEndIndex","isExpression","numNullishCoalesceStarts","numNullishCoalesceEnds","isOptionalChainStart","isOptionalChainEnd","subscriptStartIndex","nullishStartIndex","next","tokens","push","nextToken","nextTemplateToken","pos","readTmplToken","retokenizeSlashAsRegex","assign","readRegexp","pushTypeContext","existingTokensInType","i","length","oldIsType","popTypeContext","eat","match","eatTypeToken","tokenType","lookaheadType","snapshot","restoreFromSnapshot","TypeAndKeyword","lookaheadTypeAndKeyword","nextTokenStart","nextTokenStartSince","lastIndex","skip","exec","lookaheadCharCode","charCodeAt","skipSpace","finishToken","eof","readToken","code","backslash","atSign","getTokenFromCode","skipBlockComment","asterisk","slash","skipLineComment","startSkip","ch","lineFeed","carriageReturn","lineSeparator","paragraphSeparator","NONE","readToken_dot","nextChar","digit0","digit9","readNumber","dot","ellipsis","readToken_slash","equalsTo","finishOp","readToken_mult_modulo","star","modulo","width","exponent","greaterThan","readToken_pipe_amp","verticalBar","logicalOR","logicalAND","pipeline","rightCurlyBrace","braceBarR","bitwiseOR","bitwiseAND","readToken_caret","bitwiseXOR","readToken_plus_min","preIncDec","plusSign","plus","minus","readToken_lt","lessThan","bitShiftL","relationalOrEqual","readToken_gt","size","bitShiftR","rescan_gt","readToken_eq_excl","equality","arrow","eq","bang","readToken_question","nextChar2","questionMark","nullishCoalescing","questionDot","question","numberSign","hash","leftParenthesis","parenL","rightParenthesis","parenR","semicolon","semi","comma","leftSquareBracket","bracketL","rightSquareBracket","bracketR","leftCurlyBrace","braceBarL","braceL","braceR","colon","doubleColon","at","graveAccent","backQuote","lowercaseX","uppercaseX","lowercaseO","uppercaseO","lowercaseB","uppercaseB","readRadixNumber","digit1","digit2","digit3","digit4","digit5","digit6","digit7","digit8","quotationMark","apostrophe","readString","percentSign","ampersand","caret","dash","exclamationMark","tilde","String","fromCharCode","escaped","inClass","skipWord","regexp","readInt","underscore","lowercaseA","lowercaseF","uppercaseA","uppercaseF","lowercaseN","bigint","num","startsWithDot","isBigInt","isDecimal","uppercaseE","lowercaseE","lowercaseM","decimal","quote","string","dollarSign","template","dollarBraceL"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/tokenizer/index.js"],"sourcesContent":["/* eslint max-len: 0 */\n\nimport {input, isFlowEnabled, state} from \"../traverser/base\";\nimport {unexpected} from \"../traverser/util\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../util/identifier\";\nimport {IS_WHITESPACE, skipWhiteSpace} from \"../util/whitespace\";\nimport {ContextualKeyword} from \"./keywords\";\nimport readWord from \"./readWord\";\nimport { TokenType as tt} from \"./types\";\n\nexport var IdentifierRole; (function (IdentifierRole) {\n  const Access = 0; IdentifierRole[IdentifierRole[\"Access\"] = Access] = \"Access\";\n  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole[\"ExportAccess\"] = ExportAccess] = \"ExportAccess\";\n  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole[\"TopLevelDeclaration\"] = TopLevelDeclaration] = \"TopLevelDeclaration\";\n  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"FunctionScopedDeclaration\"] = FunctionScopedDeclaration] = \"FunctionScopedDeclaration\";\n  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"BlockScopedDeclaration\"] = BlockScopedDeclaration] = \"BlockScopedDeclaration\";\n  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandTopLevelDeclaration\"] = ObjectShorthandTopLevelDeclaration] = \"ObjectShorthandTopLevelDeclaration\";\n  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandFunctionScopedDeclaration\"] = ObjectShorthandFunctionScopedDeclaration] = \"ObjectShorthandFunctionScopedDeclaration\";\n  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthandBlockScopedDeclaration\"] = ObjectShorthandBlockScopedDeclaration] = \"ObjectShorthandBlockScopedDeclaration\";\n  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectShorthand\"] = ObjectShorthand] = \"ObjectShorthand\";\n  // Any identifier bound in an import statement, e.g. both A and b from\n  // `import A, * as b from 'A';`\n  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole[\"ImportDeclaration\"] = ImportDeclaration] = \"ImportDeclaration\";\n  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole[\"ObjectKey\"] = ObjectKey] = \"ObjectKey\";\n  // The `foo` in `import {foo as bar} from \"./abc\";`.\n  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole[\"ImportAccess\"] = ImportAccess] = \"ImportAccess\";\n})(IdentifierRole || (IdentifierRole = {}));\n\n/**\n * Extra information on jsxTagStart tokens, used to determine which of the three\n * jsx functions are called in the automatic transform.\n */\nexport var JSXRole; (function (JSXRole) {\n  // The element is self-closing or has a body that resolves to empty. We\n  // shouldn't emit children at all in this case.\n  const NoChildren = 0; JSXRole[JSXRole[\"NoChildren\"] = NoChildren] = \"NoChildren\";\n  // The element has a single explicit child, which might still be an arbitrary\n  // expression like an array. We should emit that expression as the children.\n  const OneChild = NoChildren + 1; JSXRole[JSXRole[\"OneChild\"] = OneChild] = \"OneChild\";\n  // The element has at least two explicitly-specified children or has spread\n  // children, so child positions are assumed to be \"static\". We should wrap\n  // these children in an array.\n  const StaticChildren = OneChild + 1; JSXRole[JSXRole[\"StaticChildren\"] = StaticChildren] = \"StaticChildren\";\n  // The element has a prop named \"key\" after a prop spread, so we should fall\n  // back to the createElement function.\n  const KeyAfterPropSpread = StaticChildren + 1; JSXRole[JSXRole[\"KeyAfterPropSpread\"] = KeyAfterPropSpread] = \"KeyAfterPropSpread\";\n})(JSXRole || (JSXRole = {}));\n\nexport function isDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isNonTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isTopLevelDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ImportDeclaration\n  );\n}\n\nexport function isBlockScopedDeclaration(token) {\n  const role = token.identifierRole;\n  // Treat top-level declarations as block scope since the distinction doesn't matter here.\n  return (\n    role === IdentifierRole.TopLevelDeclaration ||\n    role === IdentifierRole.BlockScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration\n  );\n}\n\nexport function isFunctionScopedDeclaration(token) {\n  const role = token.identifierRole;\n  return (\n    role === IdentifierRole.FunctionScopedDeclaration ||\n    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\nexport function isObjectShorthandDeclaration(token) {\n  return (\n    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||\n    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration\n  );\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nexport class Token {\n  constructor() {\n    this.type = state.type;\n    this.contextualKeyword = state.contextualKeyword;\n    this.start = state.start;\n    this.end = state.end;\n    this.scopeDepth = state.scopeDepth;\n    this.isType = state.isType;\n    this.identifierRole = null;\n    this.jsxRole = null;\n    this.shadowsGlobal = false;\n    this.isAsyncOperation = false;\n    this.contextId = null;\n    this.rhsEndIndex = null;\n    this.isExpression = false;\n    this.numNullishCoalesceStarts = 0;\n    this.numNullishCoalesceEnds = 0;\n    this.isOptionalChainStart = false;\n    this.isOptionalChainEnd = false;\n    this.subscriptStartIndex = null;\n    this.nullishStartIndex = null;\n  }\n\n  \n  \n  \n  \n  \n  \n  \n  \n  // Initially false for all tokens, then may be computed in a follow-up step that does scope\n  // analysis.\n  \n  // Initially false for all tokens, but may be set during transform to mark it as containing an\n  // await operation.\n  \n  \n  // For assignments, the index of the RHS. For export tokens, the end of the export.\n  \n  // For class tokens, records if the class is a class expression or a class statement.\n  \n  // Number of times to insert a `nullishCoalesce(` snippet before this token.\n  \n  // Number of times to insert a `)` snippet after this token.\n  \n  // If true, insert an `optionalChain([` snippet before this token.\n  \n  // If true, insert a `])` snippet after this token.\n  \n  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the \"root\" token for this\n  // subscript chain. This can be used to determine if this chain is an optional chain.\n  \n  // Tag for `??` operators to denote the root token for this nullish coalescing call.\n  \n}\n\n// ## Tokenizer\n\n// Move to the next token\nexport function next() {\n  state.tokens.push(new Token());\n  nextToken();\n}\n\n// Call instead of next when inside a template, since that needs to be handled differently.\nexport function nextTemplateToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  readTmplToken();\n}\n\n// The tokenizer never parses regexes by default. Instead, the parser is responsible for\n// instructing it to parse a regex when we see a slash at the start of an expression.\nexport function retokenizeSlashAsRegex() {\n  if (state.type === tt.assign) {\n    --state.pos;\n  }\n  readRegexp();\n}\n\nexport function pushTypeContext(existingTokensInType) {\n  for (let i = state.tokens.length - existingTokensInType; i < state.tokens.length; i++) {\n    state.tokens[i].isType = true;\n  }\n  const oldIsType = state.isType;\n  state.isType = true;\n  return oldIsType;\n}\n\nexport function popTypeContext(oldIsType) {\n  state.isType = oldIsType;\n}\n\nexport function eat(type) {\n  if (match(type)) {\n    next();\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function eatTypeToken(tokenType) {\n  const oldIsType = state.isType;\n  state.isType = true;\n  eat(tokenType);\n  state.isType = oldIsType;\n}\n\nexport function match(type) {\n  return state.type === type;\n}\n\nexport function lookaheadType() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  state.restoreFromSnapshot(snapshot);\n  return type;\n}\n\nexport class TypeAndKeyword {\n  \n  \n  constructor(type, contextualKeyword) {\n    this.type = type;\n    this.contextualKeyword = contextualKeyword;\n  }\n}\n\nexport function lookaheadTypeAndKeyword() {\n  const snapshot = state.snapshot();\n  next();\n  const type = state.type;\n  const contextualKeyword = state.contextualKeyword;\n  state.restoreFromSnapshot(snapshot);\n  return new TypeAndKeyword(type, contextualKeyword);\n}\n\nexport function nextTokenStart() {\n  return nextTokenStartSince(state.pos);\n}\n\nexport function nextTokenStartSince(pos) {\n  skipWhiteSpace.lastIndex = pos;\n  const skip = skipWhiteSpace.exec(input);\n  return pos + skip[0].length;\n}\n\nexport function lookaheadCharCode() {\n  return input.charCodeAt(nextTokenStart());\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\nexport function nextToken() {\n  skipSpace();\n  state.start = state.pos;\n  if (state.pos >= input.length) {\n    const tokens = state.tokens;\n    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.\n    // Also check the token positions rather than the types since sometimes we rewrite the token\n    // type to something else.\n    if (\n      tokens.length >= 2 &&\n      tokens[tokens.length - 1].start >= input.length &&\n      tokens[tokens.length - 2].start >= input.length\n    ) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n    }\n    finishToken(tt.eof);\n    return;\n  }\n  readToken(input.charCodeAt(state.pos));\n}\n\nfunction readToken(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (\n    IS_IDENTIFIER_START[code] ||\n    code === charCodes.backslash ||\n    (code === charCodes.atSign && input.charCodeAt(state.pos + 1) === charCodes.atSign)\n  ) {\n    readWord();\n  } else {\n    getTokenFromCode(code);\n  }\n}\n\nfunction skipBlockComment() {\n  while (\n    input.charCodeAt(state.pos) !== charCodes.asterisk ||\n    input.charCodeAt(state.pos + 1) !== charCodes.slash\n  ) {\n    state.pos++;\n    if (state.pos > input.length) {\n      unexpected(\"Unterminated comment\", state.pos - 2);\n      return;\n    }\n  }\n  state.pos += 2;\n}\n\nexport function skipLineComment(startSkip) {\n  let ch = input.charCodeAt((state.pos += startSkip));\n  if (state.pos < input.length) {\n    while (\n      ch !== charCodes.lineFeed &&\n      ch !== charCodes.carriageReturn &&\n      ch !== charCodes.lineSeparator &&\n      ch !== charCodes.paragraphSeparator &&\n      ++state.pos < input.length\n    ) {\n      ch = input.charCodeAt(state.pos);\n    }\n  }\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments.\nexport function skipSpace() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    switch (ch) {\n      case charCodes.carriageReturn:\n        if (input.charCodeAt(state.pos + 1) === charCodes.lineFeed) {\n          ++state.pos;\n        }\n\n      case charCodes.lineFeed:\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        ++state.pos;\n        break;\n\n      case charCodes.slash:\n        switch (input.charCodeAt(state.pos + 1)) {\n          case charCodes.asterisk:\n            state.pos += 2;\n            skipBlockComment();\n            break;\n\n          case charCodes.slash:\n            skipLineComment(2);\n            break;\n\n          default:\n            return;\n        }\n        break;\n\n      default:\n        if (IS_WHITESPACE[ch]) {\n          ++state.pos;\n        } else {\n          return;\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets various fields, and skips the space after the token, so\n// that the next one's `start` will point at the right position.\nexport function finishToken(\n  type,\n  contextualKeyword = ContextualKeyword.NONE,\n) {\n  state.end = state.pos;\n  state.type = type;\n  state.contextualKeyword = contextualKeyword;\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\nfunction readToken_dot() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar >= charCodes.digit0 && nextChar <= charCodes.digit9) {\n    readNumber(true);\n    return;\n  }\n\n  if (nextChar === charCodes.dot && input.charCodeAt(state.pos + 2) === charCodes.dot) {\n    state.pos += 3;\n    finishToken(tt.ellipsis);\n  } else {\n    ++state.pos;\n    finishToken(tt.dot);\n  }\n}\n\nfunction readToken_slash() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.slash, 1);\n  }\n}\n\nfunction readToken_mult_modulo(code) {\n  // '%*'\n  let tokenType = code === charCodes.asterisk ? tt.star : tt.modulo;\n  let width = 1;\n  let nextChar = input.charCodeAt(state.pos + 1);\n\n  // Exponentiation operator **\n  if (code === charCodes.asterisk && nextChar === charCodes.asterisk) {\n    width++;\n    nextChar = input.charCodeAt(state.pos + 2);\n    tokenType = tt.exponent;\n  }\n\n  // Match *= or %=, disallowing *=> which can be valid in flow.\n  if (\n    nextChar === charCodes.equalsTo &&\n    input.charCodeAt(state.pos + 2) !== charCodes.greaterThan\n  ) {\n    width++;\n    tokenType = tt.assign;\n  }\n\n  finishOp(tokenType, width);\n}\n\nfunction readToken_pipe_amp(code) {\n  // '|&'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      // ||= or &&=\n      finishOp(tt.assign, 3);\n    } else {\n      // || or &&\n      finishOp(code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND, 2);\n    }\n    return;\n  }\n\n  if (code === charCodes.verticalBar) {\n    // '|>'\n    if (nextChar === charCodes.greaterThan) {\n      finishOp(tt.pipeline, 2);\n      return;\n    } else if (nextChar === charCodes.rightCurlyBrace && isFlowEnabled) {\n      // '|}'\n      finishOp(tt.braceBarR, 2);\n      return;\n    }\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n    return;\n  }\n\n  finishOp(code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND, 1);\n}\n\nfunction readToken_caret() {\n  // '^'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else {\n    finishOp(tt.bitwiseXOR, 1);\n  }\n}\n\nfunction readToken_plus_min(code) {\n  // '+-'\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === code) {\n    // Tentatively call this a prefix operator, but it might be changed to postfix later.\n    finishOp(tt.preIncDec, 2);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.assign, 2);\n  } else if (code === charCodes.plusSign) {\n    finishOp(tt.plus, 1);\n  } else {\n    finishOp(tt.minus, 1);\n  }\n}\n\nfunction readToken_lt() {\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === charCodes.lessThan) {\n    if (input.charCodeAt(state.pos + 2) === charCodes.equalsTo) {\n      finishOp(tt.assign, 3);\n      return;\n    }\n    // We see <<, but need to be really careful about whether to treat it as a\n    // true left-shift or as two < tokens.\n    if (state.isType) {\n      // Within a type, << might come up in a snippet like `Array<<T>() => void>`,\n      // so treat it as two < tokens. Importantly, this should only override <<\n      // rather than other tokens like <= . If we treated <= as < in a type\n      // context, then the snippet `a as T <= 1` would incorrectly start parsing\n      // a type argument on T. We don't need to worry about `a as T << 1`\n      // because TypeScript disallows that syntax.\n      finishOp(tt.lessThan, 1);\n    } else {\n      // Outside a type, this might be a true left-shift operator, or it might\n      // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We\n      // look at the token while considering the `f`, so we don't yet know that\n      // we're in a type context. In this case, we initially tokenize as a\n      // left-shift and correct after-the-fact as necessary in\n      // tsParseTypeArgumentsWithPossibleBitshift .\n      finishOp(tt.bitShiftL, 2);\n    }\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    // <=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.lessThan, 1);\n  }\n}\n\nfunction readToken_gt() {\n  if (state.isType) {\n    // Avoid right-shift for things like `Array<Array<string>>` and\n    // greater-than-or-equal for things like `const a: Array<number>=[];`.\n    finishOp(tt.greaterThan, 1);\n    return;\n  }\n\n  const nextChar = input.charCodeAt(state.pos + 1);\n\n  if (nextChar === charCodes.greaterThan) {\n    const size = input.charCodeAt(state.pos + 2) === charCodes.greaterThan ? 3 : 2;\n    if (input.charCodeAt(state.pos + size) === charCodes.equalsTo) {\n      finishOp(tt.assign, size + 1);\n      return;\n    }\n    finishOp(tt.bitShiftR, size);\n    return;\n  }\n\n  if (nextChar === charCodes.equalsTo) {\n    // >=\n    finishOp(tt.relationalOrEqual, 2);\n  } else {\n    finishOp(tt.greaterThan, 1);\n  }\n}\n\n/**\n * Reinterpret a possible > token when transitioning from a type to a non-type\n * context.\n *\n * This comes up in two situations where >= needs to be treated as one token:\n * - After an `as` expression, like in the code `a as T >= 1`.\n * - In a type argument in an expression context, e.g. `f(a < b, c >= d)`, we\n *   need to see the token as >= so that we get an error and backtrack to\n *   normal expression parsing.\n *\n * Other situations require >= to be seen as two tokens, e.g.\n * `const x: Array<T>=[];`, so it's important to treat > as its own token in\n * typical type parsing situations.\n */\nexport function rescan_gt() {\n  if (state.type === tt.greaterThan) {\n    state.pos -= 1;\n    readToken_gt();\n  }\n}\n\nfunction readToken_eq_excl(code) {\n  // '=!'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  if (nextChar === charCodes.equalsTo) {\n    finishOp(tt.equality, input.charCodeAt(state.pos + 2) === charCodes.equalsTo ? 3 : 2);\n    return;\n  }\n  if (code === charCodes.equalsTo && nextChar === charCodes.greaterThan) {\n    // '=>'\n    state.pos += 2;\n    finishToken(tt.arrow);\n    return;\n  }\n  finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n}\n\nfunction readToken_question() {\n  // '?'\n  const nextChar = input.charCodeAt(state.pos + 1);\n  const nextChar2 = input.charCodeAt(state.pos + 2);\n  if (\n    nextChar === charCodes.questionMark &&\n    // In Flow (but not TypeScript), ??string is a valid type that should be\n    // tokenized as two individual ? tokens.\n    !(isFlowEnabled && state.isType)\n  ) {\n    if (nextChar2 === charCodes.equalsTo) {\n      // '??='\n      finishOp(tt.assign, 3);\n    } else {\n      // '??'\n      finishOp(tt.nullishCoalescing, 2);\n    }\n  } else if (\n    nextChar === charCodes.dot &&\n    !(nextChar2 >= charCodes.digit0 && nextChar2 <= charCodes.digit9)\n  ) {\n    // '.' not followed by a number\n    state.pos += 2;\n    finishToken(tt.questionDot);\n  } else {\n    ++state.pos;\n    finishToken(tt.question);\n  }\n}\n\nexport function getTokenFromCode(code) {\n  switch (code) {\n    case charCodes.numberSign:\n      ++state.pos;\n      finishToken(tt.hash);\n      return;\n\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n\n    case charCodes.dot:\n      readToken_dot();\n      return;\n\n    // Punctuation tokens.\n    case charCodes.leftParenthesis:\n      ++state.pos;\n      finishToken(tt.parenL);\n      return;\n    case charCodes.rightParenthesis:\n      ++state.pos;\n      finishToken(tt.parenR);\n      return;\n    case charCodes.semicolon:\n      ++state.pos;\n      finishToken(tt.semi);\n      return;\n    case charCodes.comma:\n      ++state.pos;\n      finishToken(tt.comma);\n      return;\n    case charCodes.leftSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketL);\n      return;\n    case charCodes.rightSquareBracket:\n      ++state.pos;\n      finishToken(tt.bracketR);\n      return;\n\n    case charCodes.leftCurlyBrace:\n      if (isFlowEnabled && input.charCodeAt(state.pos + 1) === charCodes.verticalBar) {\n        finishOp(tt.braceBarL, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.braceL);\n      }\n      return;\n\n    case charCodes.rightCurlyBrace:\n      ++state.pos;\n      finishToken(tt.braceR);\n      return;\n\n    case charCodes.colon:\n      if (input.charCodeAt(state.pos + 1) === charCodes.colon) {\n        finishOp(tt.doubleColon, 2);\n      } else {\n        ++state.pos;\n        finishToken(tt.colon);\n      }\n      return;\n\n    case charCodes.questionMark:\n      readToken_question();\n      return;\n    case charCodes.atSign:\n      ++state.pos;\n      finishToken(tt.at);\n      return;\n\n    case charCodes.graveAccent:\n      ++state.pos;\n      finishToken(tt.backQuote);\n      return;\n\n    case charCodes.digit0: {\n      const nextChar = input.charCodeAt(state.pos + 1);\n      // '0x', '0X', '0o', '0O', '0b', '0B'\n      if (\n        nextChar === charCodes.lowercaseX ||\n        nextChar === charCodes.uppercaseX ||\n        nextChar === charCodes.lowercaseO ||\n        nextChar === charCodes.uppercaseO ||\n        nextChar === charCodes.lowercaseB ||\n        nextChar === charCodes.uppercaseB\n      ) {\n        readRadixNumber();\n        return;\n      }\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case charCodes.digit1:\n    case charCodes.digit2:\n    case charCodes.digit3:\n    case charCodes.digit4:\n    case charCodes.digit5:\n    case charCodes.digit6:\n    case charCodes.digit7:\n    case charCodes.digit8:\n    case charCodes.digit9:\n      readNumber(false);\n      return;\n\n    // Quotes produce strings.\n    case charCodes.quotationMark:\n    case charCodes.apostrophe:\n      readString(code);\n      return;\n\n    // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case charCodes.slash:\n      readToken_slash();\n      return;\n\n    case charCodes.percentSign:\n    case charCodes.asterisk:\n      readToken_mult_modulo(code);\n      return;\n\n    case charCodes.verticalBar:\n    case charCodes.ampersand:\n      readToken_pipe_amp(code);\n      return;\n\n    case charCodes.caret:\n      readToken_caret();\n      return;\n\n    case charCodes.plusSign:\n    case charCodes.dash:\n      readToken_plus_min(code);\n      return;\n\n    case charCodes.lessThan:\n      readToken_lt();\n      return;\n\n    case charCodes.greaterThan:\n      readToken_gt();\n      return;\n\n    case charCodes.equalsTo:\n    case charCodes.exclamationMark:\n      readToken_eq_excl(code);\n      return;\n\n    case charCodes.tilde:\n      finishOp(tt.tilde, 1);\n      return;\n\n    default:\n      break;\n  }\n\n  unexpected(`Unexpected character '${String.fromCharCode(code)}'`, state.pos);\n}\n\nfunction finishOp(type, size) {\n  state.pos += size;\n  finishToken(type);\n}\n\nfunction readRegexp() {\n  const start = state.pos;\n  let escaped = false;\n  let inClass = false;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated regular expression\", start);\n      return;\n    }\n    const code = input.charCodeAt(state.pos);\n    if (escaped) {\n      escaped = false;\n    } else {\n      if (code === charCodes.leftSquareBracket) {\n        inClass = true;\n      } else if (code === charCodes.rightSquareBracket && inClass) {\n        inClass = false;\n      } else if (code === charCodes.slash && !inClass) {\n        break;\n      }\n      escaped = code === charCodes.backslash;\n    }\n    ++state.pos;\n  }\n  ++state.pos;\n  // Need to use `skipWord` because '\\uXXXX' sequences are allowed here (don't ask).\n  skipWord();\n\n  finishToken(tt.regexp);\n}\n\n/**\n * Read a decimal integer. Note that this can't be unified with the similar code\n * in readRadixNumber (which also handles hex digits) because \"e\" needs to be\n * the end of the integer so that we can properly handle scientific notation.\n */\nfunction readInt() {\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if ((code >= charCodes.digit0 && code <= charCodes.digit9) || code === charCodes.underscore) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction readRadixNumber() {\n  state.pos += 2; // 0x\n\n  // Walk to the end of the number, allowing hex digits.\n  while (true) {\n    const code = input.charCodeAt(state.pos);\n    if (\n      (code >= charCodes.digit0 && code <= charCodes.digit9) ||\n      (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||\n      (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF) ||\n      code === charCodes.underscore\n    ) {\n      state.pos++;\n    } else {\n      break;\n    }\n  }\n\n  const nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    finishToken(tt.bigint);\n  } else {\n    finishToken(tt.num);\n  }\n}\n\n// Read an integer, octal integer, or floating-point number.\nfunction readNumber(startsWithDot) {\n  let isBigInt = false;\n  let isDecimal = false;\n\n  if (!startsWithDot) {\n    readInt();\n  }\n\n  let nextChar = input.charCodeAt(state.pos);\n  if (nextChar === charCodes.dot) {\n    ++state.pos;\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.uppercaseE || nextChar === charCodes.lowercaseE) {\n    nextChar = input.charCodeAt(++state.pos);\n    if (nextChar === charCodes.plusSign || nextChar === charCodes.dash) {\n      ++state.pos;\n    }\n    readInt();\n    nextChar = input.charCodeAt(state.pos);\n  }\n\n  if (nextChar === charCodes.lowercaseN) {\n    ++state.pos;\n    isBigInt = true;\n  } else if (nextChar === charCodes.lowercaseM) {\n    ++state.pos;\n    isDecimal = true;\n  }\n\n  if (isBigInt) {\n    finishToken(tt.bigint);\n    return;\n  }\n\n  if (isDecimal) {\n    finishToken(tt.decimal);\n    return;\n  }\n\n  finishToken(tt.num);\n}\n\nfunction readString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    } else if (ch === quote) {\n      break;\n    }\n    state.pos++;\n  }\n  state.pos++;\n  finishToken(tt.string);\n}\n\n// Reads template string tokens.\nfunction readTmplToken() {\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated template\");\n      return;\n    }\n    const ch = input.charCodeAt(state.pos);\n    if (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign && input.charCodeAt(state.pos + 1) === charCodes.leftCurlyBrace)\n    ) {\n      if (state.pos === state.start && match(tt.template)) {\n        if (ch === charCodes.dollarSign) {\n          state.pos += 2;\n          finishToken(tt.dollarBraceL);\n          return;\n        } else {\n          ++state.pos;\n          finishToken(tt.backQuote);\n          return;\n        }\n      }\n      finishToken(tt.template);\n      return;\n    }\n    if (ch === charCodes.backslash) {\n      state.pos++;\n    }\n    state.pos++;\n  }\n}\n\n// Skip to the end of the current word. Note that this is the same as the snippet at the end of\n// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough\n// measurements.\nexport function skipWord() {\n  while (state.pos < input.length) {\n    const ch = input.charCodeAt(state.pos);\n    if (IS_IDENTIFIER_CHAR[ch]) {\n      state.pos++;\n    } else if (ch === charCodes.backslash) {\n      // \\u\n      state.pos += 2;\n      if (input.charCodeAt(state.pos) === charCodes.leftCurlyBrace) {\n        while (\n          state.pos < input.length &&\n          input.charCodeAt(state.pos) !== charCodes.rightCurlyBrace\n        ) {\n          state.pos++;\n        }\n        state.pos++;\n      }\n    } else {\n      break;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}