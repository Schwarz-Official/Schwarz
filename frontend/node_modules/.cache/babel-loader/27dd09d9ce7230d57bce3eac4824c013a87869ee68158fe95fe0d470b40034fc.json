{"ast":null,"code":"import { ContextualKeyword } from \"../parser/tokenizer/keywords\";\n\n/**\n * Determine whether this optional chain or nullish coalescing operation has any await statements in\n * it. If so, we'll need to transpile to an async operation.\n *\n * We compute this by walking the length of the operation and returning true if we see an await\n * keyword used as a real await (rather than an object key or property access). Nested optional\n * chain/nullish operations need to be tracked but don't silence await, but a nested async function\n * (or any other nested scope) will make the await not count.\n */\nexport default function isAsyncOperation(tokens) {\n  let index = tokens.currentIndex();\n  let depth = 0;\n  const startToken = tokens.currentToken();\n  do {\n    const token = tokens.tokens[index];\n    if (token.isOptionalChainStart) {\n      depth++;\n    }\n    if (token.isOptionalChainEnd) {\n      depth--;\n    }\n    depth += token.numNullishCoalesceStarts;\n    depth -= token.numNullishCoalesceEnds;\n    if (token.contextualKeyword === ContextualKeyword._await && token.identifierRole == null && token.scopeDepth === startToken.scopeDepth) {\n      return true;\n    }\n    index += 1;\n  } while (depth > 0 && index < tokens.tokens.length);\n  return false;\n}","map":{"version":3,"names":["ContextualKeyword","isAsyncOperation","tokens","index","currentIndex","depth","startToken","currentToken","token","isOptionalChainStart","isOptionalChainEnd","numNullishCoalesceStarts","numNullishCoalesceEnds","contextualKeyword","_await","identifierRole","scopeDepth","length"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/util/isAsyncOperation.js"],"sourcesContent":["import {ContextualKeyword} from \"../parser/tokenizer/keywords\";\n\n\n/**\n * Determine whether this optional chain or nullish coalescing operation has any await statements in\n * it. If so, we'll need to transpile to an async operation.\n *\n * We compute this by walking the length of the operation and returning true if we see an await\n * keyword used as a real await (rather than an object key or property access). Nested optional\n * chain/nullish operations need to be tracked but don't silence await, but a nested async function\n * (or any other nested scope) will make the await not count.\n */\nexport default function isAsyncOperation(tokens) {\n  let index = tokens.currentIndex();\n  let depth = 0;\n  const startToken = tokens.currentToken();\n  do {\n    const token = tokens.tokens[index];\n    if (token.isOptionalChainStart) {\n      depth++;\n    }\n    if (token.isOptionalChainEnd) {\n      depth--;\n    }\n    depth += token.numNullishCoalesceStarts;\n    depth -= token.numNullishCoalesceEnds;\n\n    if (\n      token.contextualKeyword === ContextualKeyword._await &&\n      token.identifierRole == null &&\n      token.scopeDepth === startToken.scopeDepth\n    ) {\n      return true;\n    }\n    index += 1;\n  } while (depth > 0 && index < tokens.tokens.length);\n  return false;\n}\n"],"mappings":"AAAA,SAAQA,iBAAiB,QAAO,8BAA8B;;AAG9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,gBAAgBA,CAACC,MAAM,EAAE;EAC/C,IAAIC,KAAK,GAAGD,MAAM,CAACE,YAAY,CAAC,CAAC;EACjC,IAAIC,KAAK,GAAG,CAAC;EACb,MAAMC,UAAU,GAAGJ,MAAM,CAACK,YAAY,CAAC,CAAC;EACxC,GAAG;IACD,MAAMC,KAAK,GAAGN,MAAM,CAACA,MAAM,CAACC,KAAK,CAAC;IAClC,IAAIK,KAAK,CAACC,oBAAoB,EAAE;MAC9BJ,KAAK,EAAE;IACT;IACA,IAAIG,KAAK,CAACE,kBAAkB,EAAE;MAC5BL,KAAK,EAAE;IACT;IACAA,KAAK,IAAIG,KAAK,CAACG,wBAAwB;IACvCN,KAAK,IAAIG,KAAK,CAACI,sBAAsB;IAErC,IACEJ,KAAK,CAACK,iBAAiB,KAAKb,iBAAiB,CAACc,MAAM,IACpDN,KAAK,CAACO,cAAc,IAAI,IAAI,IAC5BP,KAAK,CAACQ,UAAU,KAAKV,UAAU,CAACU,UAAU,EAC1C;MACA,OAAO,IAAI;IACb;IACAb,KAAK,IAAI,CAAC;EACZ,CAAC,QAAQE,KAAK,GAAG,CAAC,IAAIF,KAAK,GAAGD,MAAM,CAACA,MAAM,CAACe,MAAM;EAClD,OAAO,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}