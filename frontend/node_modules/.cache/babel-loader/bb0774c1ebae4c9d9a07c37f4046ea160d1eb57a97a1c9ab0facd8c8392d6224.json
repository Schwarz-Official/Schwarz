{"ast":null,"code":"import XHTMLEntities from \"../parser/plugins/jsx/xhtml\";\nimport { JSXRole } from \"../parser/tokenizer\";\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport { charCodes } from \"../parser/util/charcodes\";\nimport getJSXPragmaInfo from \"../util/getJSXPragmaInfo\";\nimport Transformer from \"./Transformer\";\nexport default class JSXTransformer extends Transformer {\n  // State for calculating the line number of each JSX tag in development.\n  __init() {\n    this.lastLineNumber = 1;\n  }\n  __init2() {\n    this.lastIndex = 0;\n  }\n\n  // In development, variable name holding the name of the current file.\n  __init3() {\n    this.filenameVarName = null;\n  }\n  // Mapping of claimed names for imports in the automatic transform, e,g.\n  // {jsx: \"_jsx\"}. This determines which imports to generate in the prefix.\n  __init4() {\n    this.esmAutomaticImportNameResolutions = {};\n  }\n  // When automatically adding imports in CJS mode, we store the variable name\n  // holding the imported CJS module so we can require it in the prefix.\n  __init5() {\n    this.cjsAutomaticModuleNameResolutions = {};\n  }\n  constructor(rootTransformer, tokens, importProcessor, nameManager, options) {\n    super();\n    this.rootTransformer = rootTransformer;\n    this.tokens = tokens;\n    this.importProcessor = importProcessor;\n    this.nameManager = nameManager;\n    this.options = options;\n    JSXTransformer.prototype.__init.call(this);\n    JSXTransformer.prototype.__init2.call(this);\n    JSXTransformer.prototype.__init3.call(this);\n    JSXTransformer.prototype.__init4.call(this);\n    JSXTransformer.prototype.__init5.call(this);\n    ;\n    this.jsxPragmaInfo = getJSXPragmaInfo(options);\n    this.isAutomaticRuntime = options.jsxRuntime === \"automatic\";\n    this.jsxImportSource = options.jsxImportSource || \"react\";\n  }\n  process() {\n    if (this.tokens.matches1(tt.jsxTagStart)) {\n      this.processJSXTag();\n      return true;\n    }\n    return false;\n  }\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.filenameVarName) {\n      prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || \"\")};`;\n    }\n    if (this.isAutomaticRuntime) {\n      if (this.importProcessor) {\n        // CJS mode: emit require statements for all modules that were referenced.\n        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {\n          prefix += `var ${resolvedName} = require(\"${path}\");`;\n        }\n      } else {\n        // ESM mode: consolidate and emit import statements for referenced names.\n        const {\n          createElement: createElementResolution,\n          ...otherResolutions\n        } = this.esmAutomaticImportNameResolutions;\n        if (createElementResolution) {\n          prefix += `import {createElement as ${createElementResolution}} from \"${this.jsxImportSource}\";`;\n        }\n        const importSpecifiers = Object.entries(otherResolutions).map(([name, resolvedName]) => `${name} as ${resolvedName}`).join(\", \");\n        if (importSpecifiers) {\n          const importPath = this.jsxImportSource + (this.options.production ? \"/jsx-runtime\" : \"/jsx-dev-runtime\");\n          prefix += `import {${importSpecifiers}} from \"${importPath}\";`;\n        }\n      }\n    }\n    return prefix;\n  }\n  processJSXTag() {\n    const {\n      jsxRole,\n      start\n    } = this.tokens.currentToken();\n    // Calculate line number information at the very start (if in development\n    // mode) so that the information is guaranteed to be queried in token order.\n    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);\n    if (this.isAutomaticRuntime && jsxRole !== JSXRole.KeyAfterPropSpread) {\n      this.transformTagToJSXFunc(elementLocationCode, jsxRole);\n    } else {\n      this.transformTagToCreateElement(elementLocationCode);\n    }\n  }\n  getElementLocationCode(firstTokenStart) {\n    const lineNumber = this.getLineNumberForIndex(firstTokenStart);\n    return `lineNumber: ${lineNumber}`;\n  }\n\n  /**\n   * Get the line number for this source position. This is calculated lazily and\n   * must be called in increasing order by index.\n   */\n  getLineNumberForIndex(index) {\n    const code = this.tokens.code;\n    while (this.lastIndex < index && this.lastIndex < code.length) {\n      if (code[this.lastIndex] === \"\\n\") {\n        this.lastLineNumber++;\n      }\n      this.lastIndex++;\n    }\n    return this.lastLineNumber;\n  }\n\n  /**\n   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is\n   * the primary transformation for the automatic transform.\n   *\n   * Example:\n   * <div a={1} key={2}>Hello{x}</div>\n   * becomes\n   * jsxs('div', {a: 1, children: [\"Hello\", x]}, 2)\n   */\n  transformTagToJSXFunc(elementLocationCode, jsxRole) {\n    const isStatic = jsxRole === JSXRole.StaticChildren;\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));\n    let keyCode = null;\n    if (this.tokens.matches1(tt.jsxTagEnd)) {\n      // Fragment syntax.\n      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);\n      this.processAutomaticChildrenAndEndProps(jsxRole);\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.tokens.appendCode(\", {\");\n      keyCode = this.processProps(true);\n      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {\n        // Self-closing tag, no children to add, so close the props.\n        this.tokens.appendCode(\"}\");\n      } else if (this.tokens.matches1(tt.jsxTagEnd)) {\n        // Tag with children.\n        this.tokens.removeToken();\n        this.processAutomaticChildrenAndEndProps(jsxRole);\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n      // If a key was present, move it to its own arg. Note that moving code\n      // like this will cause line numbers to get out of sync within the JSX\n      // element if the key expression has a newline in it. This is unfortunate,\n      // but hopefully should be rare.\n      if (keyCode) {\n        this.tokens.appendCode(`, ${keyCode}`);\n      }\n    }\n    if (!this.options.production) {\n      // If the key wasn't already added, add it now so we can correctly set\n      // positional args for jsxDEV.\n      if (keyCode === null) {\n        this.tokens.appendCode(\", void 0\");\n      }\n      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);\n    }\n    // We're at the close-tag or the end of a self-closing tag, so remove\n    // everything else and close the function call.\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.jsxTagEnd)) {\n      this.tokens.removeToken();\n    }\n    this.tokens.replaceToken(\")\");\n  }\n\n  /**\n   * Convert the current JSX element to a createElement call. In the classic\n   * runtime, this is the only case. In the automatic runtime, this is called\n   * as a fallback in some situations.\n   *\n   * Example:\n   * <div a={1} key={2}>Hello{x}</div>\n   * becomes\n   * React.createElement('div', {a: 1, key: 2}, \"Hello\", x)\n   */\n  transformTagToCreateElement(elementLocationCode) {\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(this.getCreateElementInvocationCode());\n    if (this.tokens.matches1(tt.jsxTagEnd)) {\n      // Fragment syntax.\n      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);\n      this.processChildren(true);\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.processPropsObjectWithDevInfo(elementLocationCode);\n      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {\n        // Self-closing tag; no children to process.\n      } else if (this.tokens.matches1(tt.jsxTagEnd)) {\n        // Tag with children and a close-tag; process the children as args.\n        this.tokens.removeToken();\n        this.processChildren(true);\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n    }\n    // We're at the close-tag or the end of a self-closing tag, so remove\n    // everything else and close the function call.\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.jsxTagEnd)) {\n      this.tokens.removeToken();\n    }\n    this.tokens.replaceToken(\")\");\n  }\n\n  /**\n   * Get the code for the relevant function for this context: jsx, jsxs,\n   * or jsxDEV. The following open-paren is included as well.\n   *\n   * These functions are only used for the automatic runtime, so they are always\n   * auto-imported, but the auto-import will be either CJS or ESM based on the\n   * target module format.\n   */\n  getJSXFuncInvocationCode(isStatic) {\n    if (this.options.production) {\n      if (isStatic) {\n        return this.claimAutoImportedFuncInvocation(\"jsxs\", \"/jsx-runtime\");\n      } else {\n        return this.claimAutoImportedFuncInvocation(\"jsx\", \"/jsx-runtime\");\n      }\n    } else {\n      return this.claimAutoImportedFuncInvocation(\"jsxDEV\", \"/jsx-dev-runtime\");\n    }\n  }\n\n  /**\n   * Return the code to use for the createElement function, e.g.\n   * `React.createElement`, including the following open-paren.\n   *\n   * This is the main function to use for the classic runtime. For the\n   * automatic runtime, this function is used as a fallback function to\n   * preserve behavior when there is a prop spread followed by an explicit\n   * key. In that automatic runtime case, the function should be automatically\n   * imported.\n   */\n  getCreateElementInvocationCode() {\n    if (this.isAutomaticRuntime) {\n      return this.claimAutoImportedFuncInvocation(\"createElement\", \"\");\n    } else {\n      const {\n        jsxPragmaInfo\n      } = this;\n      const resolvedPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base : jsxPragmaInfo.base;\n      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;\n    }\n  }\n\n  /**\n   * Return the code to use as the component when compiling a shorthand\n   * fragment, e.g. `React.Fragment`.\n   *\n   * This may be called from either the classic or automatic runtime, and\n   * the value should be auto-imported for the automatic runtime.\n   */\n  getFragmentCode() {\n    if (this.isAutomaticRuntime) {\n      return this.claimAutoImportedName(\"Fragment\", this.options.production ? \"/jsx-runtime\" : \"/jsx-dev-runtime\");\n    } else {\n      const {\n        jsxPragmaInfo\n      } = this;\n      const resolvedFragmentPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) || jsxPragmaInfo.fragmentBase : jsxPragmaInfo.fragmentBase;\n      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;\n    }\n  }\n\n  /**\n   * Return code that invokes the given function.\n   *\n   * When the imports transform is enabled, use the CJSImportTransformer\n   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a\n   * situation that would otherwise look like a method call.\n   */\n  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {\n    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);\n    if (this.importProcessor) {\n      return `${funcCode}.call(void 0, `;\n    } else {\n      return `${funcCode}(`;\n    }\n  }\n  claimAutoImportedName(funcName, importPathSuffix) {\n    if (this.importProcessor) {\n      // CJS mode: claim a name for the module and mark it for import.\n      const path = this.jsxImportSource + importPathSuffix;\n      if (!this.cjsAutomaticModuleNameResolutions[path]) {\n        this.cjsAutomaticModuleNameResolutions[path] = this.importProcessor.getFreeIdentifierForPath(path);\n      }\n      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;\n    } else {\n      // ESM mode: claim a name for this function and add it to the names that\n      // should be auto-imported when the prefix is generated.\n      if (!this.esmAutomaticImportNameResolutions[funcName]) {\n        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(`_${funcName}`);\n      }\n      return this.esmAutomaticImportNameResolutions[funcName];\n    }\n  }\n\n  /**\n   * Process the first part of a tag, before any props.\n   */\n  processTagIntro() {\n    // Walk forward until we see one of these patterns:\n    // jsxName to start the first prop, preceded by another jsxName to end the tag name.\n    // jsxName to start the first prop, preceded by greaterThan to end the type argument.\n    // [open brace] to start the first prop.\n    // [jsxTagEnd] to end the open-tag.\n    // [slash, jsxTagEnd] to end the self-closing tag.\n    let introEnd = this.tokens.currentIndex() + 1;\n    while (this.tokens.tokens[introEnd].isType || !this.tokens.matches2AtIndex(introEnd - 1, tt.jsxName, tt.jsxName) && !this.tokens.matches2AtIndex(introEnd - 1, tt.greaterThan, tt.jsxName) && !this.tokens.matches1AtIndex(introEnd, tt.braceL) && !this.tokens.matches1AtIndex(introEnd, tt.jsxTagEnd) && !this.tokens.matches2AtIndex(introEnd, tt.slash, tt.jsxTagEnd)) {\n      introEnd++;\n    }\n    if (introEnd === this.tokens.currentIndex() + 1) {\n      const tagName = this.tokens.identifierName();\n      if (startsWithLowerCase(tagName)) {\n        this.tokens.replaceToken(`'${tagName}'`);\n      }\n    }\n    while (this.tokens.currentIndex() < introEnd) {\n      this.rootTransformer.processToken();\n    }\n  }\n\n  /**\n   * Starting at the beginning of the props, add the props argument to\n   * React.createElement, including the comma before it.\n   */\n  processPropsObjectWithDevInfo(elementLocationCode) {\n    const devProps = this.options.production ? \"\" : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;\n    if (!this.tokens.matches1(tt.jsxName) && !this.tokens.matches1(tt.braceL)) {\n      if (devProps) {\n        this.tokens.appendCode(`, {${devProps}}`);\n      } else {\n        this.tokens.appendCode(`, null`);\n      }\n      return;\n    }\n    this.tokens.appendCode(`, {`);\n    this.processProps(false);\n    if (devProps) {\n      this.tokens.appendCode(` ${devProps}}`);\n    } else {\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  /**\n   * Transform the core part of the props, assuming that a { has already been\n   * inserted before us and that a } will be inserted after us.\n   *\n   * If extractKeyCode is true (i.e. when using any jsx... function), any prop\n   * named \"key\" has its code captured and returned rather than being emitted to\n   * the output code. This shifts line numbers, and emitting the code later will\n   * correct line numbers again. If no key is found or if extractKeyCode is\n   * false, this function returns null.\n   */\n  processProps(extractKeyCode) {\n    let keyCode = null;\n    while (true) {\n      if (this.tokens.matches2(tt.jsxName, tt.eq)) {\n        // This is a regular key={value} or key=\"value\" prop.\n        const propName = this.tokens.identifierName();\n        if (extractKeyCode && propName === \"key\") {\n          if (keyCode !== null) {\n            // The props list has multiple keys. Different implementations are\n            // inconsistent about what to do here: as of this writing, Babel and\n            // swc keep the *last* key and completely remove the rest, while\n            // TypeScript uses the *first* key and leaves the others as regular\n            // props. The React team collaborated with Babel on the\n            // implementation of this behavior, so presumably the Babel behavior\n            // is the one to use.\n            // Since we won't ever be emitting the previous key code, we need to\n            // at least emit its newlines here so that the line numbers match up\n            // in the long run.\n            this.tokens.appendCode(keyCode.replace(/[^\\n]/g, \"\"));\n          }\n          // key\n          this.tokens.removeToken();\n          // =\n          this.tokens.removeToken();\n          const snapshot = this.tokens.snapshot();\n          this.processPropValue();\n          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);\n          // Don't add a comma\n          continue;\n        } else {\n          this.processPropName(propName);\n          this.tokens.replaceToken(\": \");\n          this.processPropValue();\n        }\n      } else if (this.tokens.matches1(tt.jsxName)) {\n        // This is a shorthand prop like <input disabled />.\n        const propName = this.tokens.identifierName();\n        this.processPropName(propName);\n        this.tokens.appendCode(\": true\");\n      } else if (this.tokens.matches1(tt.braceL)) {\n        // This is prop spread, like <div {...getProps()}>, which we can pass\n        // through fairly directly as an object spread.\n        this.tokens.replaceToken(\"\");\n        this.rootTransformer.processBalancedCode();\n        this.tokens.replaceToken(\"\");\n      } else {\n        break;\n      }\n      this.tokens.appendCode(\",\");\n    }\n    return keyCode;\n  }\n  processPropName(propName) {\n    if (propName.includes(\"-\")) {\n      this.tokens.replaceToken(`'${propName}'`);\n    } else {\n      this.tokens.copyToken();\n    }\n  }\n  processPropValue() {\n    if (this.tokens.matches1(tt.braceL)) {\n      this.tokens.replaceToken(\"\");\n      this.rootTransformer.processBalancedCode();\n      this.tokens.replaceToken(\"\");\n    } else if (this.tokens.matches1(tt.jsxTagStart)) {\n      this.processJSXTag();\n    } else {\n      this.processStringPropValue();\n    }\n  }\n  processStringPropValue() {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXStringValueLiteral(valueCode);\n    this.tokens.replaceToken(literalCode + replacementCode);\n  }\n\n  /**\n   * Starting in the middle of the props object literal, produce an additional\n   * prop for the children and close the object literal.\n   */\n  processAutomaticChildrenAndEndProps(jsxRole) {\n    if (jsxRole === JSXRole.StaticChildren) {\n      this.tokens.appendCode(\" children: [\");\n      this.processChildren(false);\n      this.tokens.appendCode(\"]}\");\n    } else {\n      // The parser information tells us whether we will see a real child or if\n      // all remaining children (if any) will resolve to empty. If there are no\n      // non-empty children, don't emit a children prop at all, but still\n      // process children so that we properly transform the code into nothing.\n      if (jsxRole === JSXRole.OneChild) {\n        this.tokens.appendCode(\" children: \");\n      }\n      this.processChildren(false);\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  /**\n   * Transform children into a comma-separated list, which will be either\n   * arguments to createElement or array elements of a children prop.\n   */\n  processChildren(needsInitialComma) {\n    let needsComma = needsInitialComma;\n    while (true) {\n      if (this.tokens.matches2(tt.jsxTagStart, tt.slash)) {\n        // Closing tag, so no more children.\n        return;\n      }\n      let didEmitElement = false;\n      if (this.tokens.matches1(tt.braceL)) {\n        if (this.tokens.matches2(tt.braceL, tt.braceR)) {\n          // Empty interpolations and comment-only interpolations are allowed\n          // and don't create an extra child arg.\n          this.tokens.replaceToken(\"\");\n          this.tokens.replaceToken(\"\");\n        } else {\n          // Interpolated expression.\n          this.tokens.replaceToken(needsComma ? \", \" : \"\");\n          this.rootTransformer.processBalancedCode();\n          this.tokens.replaceToken(\"\");\n          didEmitElement = true;\n        }\n      } else if (this.tokens.matches1(tt.jsxTagStart)) {\n        // Child JSX element\n        this.tokens.appendCode(needsComma ? \", \" : \"\");\n        this.processJSXTag();\n        didEmitElement = true;\n      } else if (this.tokens.matches1(tt.jsxText) || this.tokens.matches1(tt.jsxEmptyText)) {\n        didEmitElement = this.processChildTextElement(needsComma);\n      } else {\n        throw new Error(\"Unexpected token when processing JSX children.\");\n      }\n      if (didEmitElement) {\n        needsComma = true;\n      }\n    }\n  }\n\n  /**\n   * Turn a JSX text element into a string literal, or nothing at all if the JSX\n   * text resolves to the empty string.\n   *\n   * Returns true if a string literal is emitted, false otherwise.\n   */\n  processChildTextElement(needsComma) {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start, token.end);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXTextLiteral(valueCode);\n    if (literalCode === '\"\"') {\n      this.tokens.replaceToken(replacementCode);\n      return false;\n    } else {\n      this.tokens.replaceToken(`${needsComma ? \", \" : \"\"}${literalCode}${replacementCode}`);\n      return true;\n    }\n  }\n  getDevSource(elementLocationCode) {\n    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;\n  }\n  getFilenameVarName() {\n    if (!this.filenameVarName) {\n      this.filenameVarName = this.nameManager.claimFreeName(\"_jsxFileName\");\n    }\n    return this.filenameVarName;\n  }\n}\n\n/**\n * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.\n *\n * Really only treat anything starting with a-z as tag names.  `_`, `$`, `é`\n * should be treated as component names\n */\nexport function startsWithLowerCase(s) {\n  const firstChar = s.charCodeAt(0);\n  return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;\n}\n\n/**\n * Turn the given jsxText string into a JS string literal. Leading and trailing\n * whitespace on lines is removed, except immediately after the open-tag and\n * before the close-tag. Empty lines are completely removed, and spaces are\n * added between lines after that.\n *\n * We use JSON.stringify to introduce escape characters as necessary, and trim\n * the start and end of each line and remove blank lines.\n */\nfunction formatJSXTextLiteral(text) {\n  let result = \"\";\n  let whitespace = \"\";\n  let isInInitialLineWhitespace = false;\n  let seenNonWhitespace = false;\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \" \" || c === \"\\t\" || c === \"\\r\") {\n      if (!isInInitialLineWhitespace) {\n        whitespace += c;\n      }\n    } else if (c === \"\\n\") {\n      whitespace = \"\";\n      isInInitialLineWhitespace = true;\n    } else {\n      if (seenNonWhitespace && isInInitialLineWhitespace) {\n        result += \" \";\n      }\n      result += whitespace;\n      whitespace = \"\";\n      if (c === \"&\") {\n        const {\n          entity,\n          newI\n        } = processEntity(text, i + 1);\n        i = newI - 1;\n        result += entity;\n      } else {\n        result += c;\n      }\n      seenNonWhitespace = true;\n      isInInitialLineWhitespace = false;\n    }\n  }\n  if (!isInInitialLineWhitespace) {\n    result += whitespace;\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Produce the code that should be printed after the JSX text string literal,\n * with most content removed, but all newlines preserved and all spacing at the\n * end preserved.\n */\nfunction formatJSXTextReplacement(text) {\n  let numNewlines = 0;\n  let numSpaces = 0;\n  for (const c of text) {\n    if (c === \"\\n\") {\n      numNewlines++;\n      numSpaces = 0;\n    } else if (c === \" \") {\n      numSpaces++;\n    }\n  }\n  return \"\\n\".repeat(numNewlines) + \" \".repeat(numSpaces);\n}\n\n/**\n * Format a string in the value position of a JSX prop.\n *\n * Use the same implementation as convertAttribute from\n * babel-helper-builder-react-jsx.\n */\nfunction formatJSXStringValueLiteral(text) {\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \"\\n\") {\n      if (/\\s/.test(text[i + 1])) {\n        result += \" \";\n        while (i < text.length && /\\s/.test(text[i + 1])) {\n          i++;\n        }\n      } else {\n        result += \"\\n\";\n      }\n    } else if (c === \"&\") {\n      const {\n        entity,\n        newI\n      } = processEntity(text, i + 1);\n      result += entity;\n      i = newI - 1;\n    } else {\n      result += c;\n    }\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Starting at a &, see if there's an HTML entity (specified by name, decimal\n * char code, or hex char code) and return it if so.\n *\n * Modified from jsxReadString in babel-parser.\n */\nfunction processEntity(text, indexAfterAmpersand) {\n  let str = \"\";\n  let count = 0;\n  let entity;\n  let i = indexAfterAmpersand;\n  if (text[i] === \"#\") {\n    let radix = 10;\n    i++;\n    let numStart;\n    if (text[i] === \"x\") {\n      radix = 16;\n      i++;\n      numStart = i;\n      while (i < text.length && isHexDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    } else {\n      numStart = i;\n      while (i < text.length && isDecimalDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text[i] === \";\") {\n      const numStr = text.slice(numStart, i);\n      if (numStr) {\n        i++;\n        entity = String.fromCodePoint(parseInt(numStr, radix));\n      }\n    }\n  } else {\n    while (i < text.length && count++ < 10) {\n      const ch = text[i];\n      i++;\n      if (ch === \";\") {\n        entity = XHTMLEntities.get(str);\n        break;\n      }\n      str += ch;\n    }\n  }\n  if (!entity) {\n    return {\n      entity: \"&\",\n      newI: indexAfterAmpersand\n    };\n  }\n  return {\n    entity,\n    newI: i\n  };\n}\nfunction isDecimalDigit(code) {\n  return code >= charCodes.digit0 && code <= charCodes.digit9;\n}\nfunction isHexDigit(code) {\n  return code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF;\n}","map":{"version":3,"names":["XHTMLEntities","JSXRole","TokenType","tt","charCodes","getJSXPragmaInfo","Transformer","JSXTransformer","__init","lastLineNumber","__init2","lastIndex","__init3","filenameVarName","__init4","esmAutomaticImportNameResolutions","__init5","cjsAutomaticModuleNameResolutions","constructor","rootTransformer","tokens","importProcessor","nameManager","options","prototype","call","jsxPragmaInfo","isAutomaticRuntime","jsxRuntime","jsxImportSource","process","matches1","jsxTagStart","processJSXTag","getPrefixCode","prefix","JSON","stringify","filePath","path","resolvedName","Object","entries","createElement","createElementResolution","otherResolutions","importSpecifiers","map","name","join","importPath","production","jsxRole","start","currentToken","elementLocationCode","getElementLocationCode","KeyAfterPropSpread","transformTagToJSXFunc","transformTagToCreateElement","firstTokenStart","lineNumber","getLineNumberForIndex","index","code","length","isStatic","StaticChildren","replaceToken","getJSXFuncInvocationCode","keyCode","jsxTagEnd","getFragmentCode","processAutomaticChildrenAndEndProps","processTagIntro","appendCode","processProps","matches2","slash","removeToken","Error","getDevSource","removeInitialToken","getCreateElementInvocationCode","processChildren","processPropsObjectWithDevInfo","claimAutoImportedFuncInvocation","resolvedPragmaBaseName","getIdentifierReplacement","base","suffix","claimAutoImportedName","resolvedFragmentPragmaBaseName","fragmentBase","fragmentSuffix","funcName","importPathSuffix","funcCode","getFreeIdentifierForPath","claimFreeName","introEnd","currentIndex","isType","matches2AtIndex","jsxName","greaterThan","matches1AtIndex","braceL","tagName","identifierName","startsWithLowerCase","processToken","devProps","extractKeyCode","eq","propName","replace","snapshot","processPropValue","dangerouslyGetAndRemoveCodeSinceSnapshot","processPropName","processBalancedCode","includes","copyToken","processStringPropValue","token","valueCode","slice","end","replacementCode","formatJSXTextReplacement","literalCode","formatJSXStringValueLiteral","OneChild","needsInitialComma","needsComma","didEmitElement","braceR","jsxText","jsxEmptyText","processChildTextElement","formatJSXTextLiteral","getFilenameVarName","s","firstChar","charCodeAt","lowercaseA","lowercaseZ","text","result","whitespace","isInInitialLineWhitespace","seenNonWhitespace","i","c","entity","newI","processEntity","numNewlines","numSpaces","repeat","test","indexAfterAmpersand","str","count","radix","numStart","isHexDigit","isDecimalDigit","numStr","String","fromCodePoint","parseInt","ch","get","digit0","digit9","lowercaseF","uppercaseA","uppercaseF"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/JSXTransformer.js"],"sourcesContent":["\n\n\nimport XHTMLEntities from \"../parser/plugins/jsx/xhtml\";\nimport {JSXRole} from \"../parser/tokenizer\";\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\nimport {charCodes} from \"../parser/util/charcodes\";\n\nimport getJSXPragmaInfo, {} from \"../util/getJSXPragmaInfo\";\n\nimport Transformer from \"./Transformer\";\n\nexport default class JSXTransformer extends Transformer {\n  \n  \n  \n\n  // State for calculating the line number of each JSX tag in development.\n  __init() {this.lastLineNumber = 1}\n  __init2() {this.lastIndex = 0}\n\n  // In development, variable name holding the name of the current file.\n  __init3() {this.filenameVarName = null}\n  // Mapping of claimed names for imports in the automatic transform, e,g.\n  // {jsx: \"_jsx\"}. This determines which imports to generate in the prefix.\n  __init4() {this.esmAutomaticImportNameResolutions = {}}\n  // When automatically adding imports in CJS mode, we store the variable name\n  // holding the imported CJS module so we can require it in the prefix.\n  __init5() {this.cjsAutomaticModuleNameResolutions = {}}\n\n  constructor(\n     rootTransformer,\n     tokens,\n     importProcessor,\n     nameManager,\n     options,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.options = options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);JSXTransformer.prototype.__init4.call(this);JSXTransformer.prototype.__init5.call(this);;\n    this.jsxPragmaInfo = getJSXPragmaInfo(options);\n    this.isAutomaticRuntime = options.jsxRuntime === \"automatic\";\n    this.jsxImportSource = options.jsxImportSource || \"react\";\n  }\n\n  process() {\n    if (this.tokens.matches1(tt.jsxTagStart)) {\n      this.processJSXTag();\n      return true;\n    }\n    return false;\n  }\n\n  getPrefixCode() {\n    let prefix = \"\";\n    if (this.filenameVarName) {\n      prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || \"\")};`;\n    }\n    if (this.isAutomaticRuntime) {\n      if (this.importProcessor) {\n        // CJS mode: emit require statements for all modules that were referenced.\n        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {\n          prefix += `var ${resolvedName} = require(\"${path}\");`;\n        }\n      } else {\n        // ESM mode: consolidate and emit import statements for referenced names.\n        const {createElement: createElementResolution, ...otherResolutions} =\n          this.esmAutomaticImportNameResolutions;\n        if (createElementResolution) {\n          prefix += `import {createElement as ${createElementResolution}} from \"${this.jsxImportSource}\";`;\n        }\n        const importSpecifiers = Object.entries(otherResolutions)\n          .map(([name, resolvedName]) => `${name} as ${resolvedName}`)\n          .join(\", \");\n        if (importSpecifiers) {\n          const importPath =\n            this.jsxImportSource + (this.options.production ? \"/jsx-runtime\" : \"/jsx-dev-runtime\");\n          prefix += `import {${importSpecifiers}} from \"${importPath}\";`;\n        }\n      }\n    }\n    return prefix;\n  }\n\n  processJSXTag() {\n    const {jsxRole, start} = this.tokens.currentToken();\n    // Calculate line number information at the very start (if in development\n    // mode) so that the information is guaranteed to be queried in token order.\n    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);\n    if (this.isAutomaticRuntime && jsxRole !== JSXRole.KeyAfterPropSpread) {\n      this.transformTagToJSXFunc(elementLocationCode, jsxRole);\n    } else {\n      this.transformTagToCreateElement(elementLocationCode);\n    }\n  }\n\n  getElementLocationCode(firstTokenStart) {\n    const lineNumber = this.getLineNumberForIndex(firstTokenStart);\n    return `lineNumber: ${lineNumber}`;\n  }\n\n  /**\n   * Get the line number for this source position. This is calculated lazily and\n   * must be called in increasing order by index.\n   */\n  getLineNumberForIndex(index) {\n    const code = this.tokens.code;\n    while (this.lastIndex < index && this.lastIndex < code.length) {\n      if (code[this.lastIndex] === \"\\n\") {\n        this.lastLineNumber++;\n      }\n      this.lastIndex++;\n    }\n    return this.lastLineNumber;\n  }\n\n  /**\n   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is\n   * the primary transformation for the automatic transform.\n   *\n   * Example:\n   * <div a={1} key={2}>Hello{x}</div>\n   * becomes\n   * jsxs('div', {a: 1, children: [\"Hello\", x]}, 2)\n   */\n  transformTagToJSXFunc(elementLocationCode, jsxRole) {\n    const isStatic = jsxRole === JSXRole.StaticChildren;\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));\n\n    let keyCode = null;\n    if (this.tokens.matches1(tt.jsxTagEnd)) {\n      // Fragment syntax.\n      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);\n      this.processAutomaticChildrenAndEndProps(jsxRole);\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.tokens.appendCode(\", {\");\n      keyCode = this.processProps(true);\n\n      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {\n        // Self-closing tag, no children to add, so close the props.\n        this.tokens.appendCode(\"}\");\n      } else if (this.tokens.matches1(tt.jsxTagEnd)) {\n        // Tag with children.\n        this.tokens.removeToken();\n        this.processAutomaticChildrenAndEndProps(jsxRole);\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n      // If a key was present, move it to its own arg. Note that moving code\n      // like this will cause line numbers to get out of sync within the JSX\n      // element if the key expression has a newline in it. This is unfortunate,\n      // but hopefully should be rare.\n      if (keyCode) {\n        this.tokens.appendCode(`, ${keyCode}`);\n      }\n    }\n    if (!this.options.production) {\n      // If the key wasn't already added, add it now so we can correctly set\n      // positional args for jsxDEV.\n      if (keyCode === null) {\n        this.tokens.appendCode(\", void 0\");\n      }\n      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);\n    }\n    // We're at the close-tag or the end of a self-closing tag, so remove\n    // everything else and close the function call.\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.jsxTagEnd)) {\n      this.tokens.removeToken();\n    }\n    this.tokens.replaceToken(\")\");\n  }\n\n  /**\n   * Convert the current JSX element to a createElement call. In the classic\n   * runtime, this is the only case. In the automatic runtime, this is called\n   * as a fallback in some situations.\n   *\n   * Example:\n   * <div a={1} key={2}>Hello{x}</div>\n   * becomes\n   * React.createElement('div', {a: 1, key: 2}, \"Hello\", x)\n   */\n  transformTagToCreateElement(elementLocationCode) {\n    // First tag is always jsxTagStart.\n    this.tokens.replaceToken(this.getCreateElementInvocationCode());\n\n    if (this.tokens.matches1(tt.jsxTagEnd)) {\n      // Fragment syntax.\n      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);\n      this.processChildren(true);\n    } else {\n      // Normal open tag or self-closing tag.\n      this.processTagIntro();\n      this.processPropsObjectWithDevInfo(elementLocationCode);\n\n      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {\n        // Self-closing tag; no children to process.\n      } else if (this.tokens.matches1(tt.jsxTagEnd)) {\n        // Tag with children and a close-tag; process the children as args.\n        this.tokens.removeToken();\n        this.processChildren(true);\n      } else {\n        throw new Error(\"Expected either /> or > at the end of the tag.\");\n      }\n    }\n    // We're at the close-tag or the end of a self-closing tag, so remove\n    // everything else and close the function call.\n    this.tokens.removeInitialToken();\n    while (!this.tokens.matches1(tt.jsxTagEnd)) {\n      this.tokens.removeToken();\n    }\n    this.tokens.replaceToken(\")\");\n  }\n\n  /**\n   * Get the code for the relevant function for this context: jsx, jsxs,\n   * or jsxDEV. The following open-paren is included as well.\n   *\n   * These functions are only used for the automatic runtime, so they are always\n   * auto-imported, but the auto-import will be either CJS or ESM based on the\n   * target module format.\n   */\n  getJSXFuncInvocationCode(isStatic) {\n    if (this.options.production) {\n      if (isStatic) {\n        return this.claimAutoImportedFuncInvocation(\"jsxs\", \"/jsx-runtime\");\n      } else {\n        return this.claimAutoImportedFuncInvocation(\"jsx\", \"/jsx-runtime\");\n      }\n    } else {\n      return this.claimAutoImportedFuncInvocation(\"jsxDEV\", \"/jsx-dev-runtime\");\n    }\n  }\n\n  /**\n   * Return the code to use for the createElement function, e.g.\n   * `React.createElement`, including the following open-paren.\n   *\n   * This is the main function to use for the classic runtime. For the\n   * automatic runtime, this function is used as a fallback function to\n   * preserve behavior when there is a prop spread followed by an explicit\n   * key. In that automatic runtime case, the function should be automatically\n   * imported.\n   */\n  getCreateElementInvocationCode() {\n    if (this.isAutomaticRuntime) {\n      return this.claimAutoImportedFuncInvocation(\"createElement\", \"\");\n    } else {\n      const {jsxPragmaInfo} = this;\n      const resolvedPragmaBaseName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base\n        : jsxPragmaInfo.base;\n      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;\n    }\n  }\n\n  /**\n   * Return the code to use as the component when compiling a shorthand\n   * fragment, e.g. `React.Fragment`.\n   *\n   * This may be called from either the classic or automatic runtime, and\n   * the value should be auto-imported for the automatic runtime.\n   */\n  getFragmentCode() {\n    if (this.isAutomaticRuntime) {\n      return this.claimAutoImportedName(\n        \"Fragment\",\n        this.options.production ? \"/jsx-runtime\" : \"/jsx-dev-runtime\",\n      );\n    } else {\n      const {jsxPragmaInfo} = this;\n      const resolvedFragmentPragmaBaseName = this.importProcessor\n        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||\n          jsxPragmaInfo.fragmentBase\n        : jsxPragmaInfo.fragmentBase;\n      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;\n    }\n  }\n\n  /**\n   * Return code that invokes the given function.\n   *\n   * When the imports transform is enabled, use the CJSImportTransformer\n   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a\n   * situation that would otherwise look like a method call.\n   */\n  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {\n    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);\n    if (this.importProcessor) {\n      return `${funcCode}.call(void 0, `;\n    } else {\n      return `${funcCode}(`;\n    }\n  }\n\n  claimAutoImportedName(funcName, importPathSuffix) {\n    if (this.importProcessor) {\n      // CJS mode: claim a name for the module and mark it for import.\n      const path = this.jsxImportSource + importPathSuffix;\n      if (!this.cjsAutomaticModuleNameResolutions[path]) {\n        this.cjsAutomaticModuleNameResolutions[path] =\n          this.importProcessor.getFreeIdentifierForPath(path);\n      }\n      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;\n    } else {\n      // ESM mode: claim a name for this function and add it to the names that\n      // should be auto-imported when the prefix is generated.\n      if (!this.esmAutomaticImportNameResolutions[funcName]) {\n        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(\n          `_${funcName}`,\n        );\n      }\n      return this.esmAutomaticImportNameResolutions[funcName];\n    }\n  }\n\n  /**\n   * Process the first part of a tag, before any props.\n   */\n  processTagIntro() {\n    // Walk forward until we see one of these patterns:\n    // jsxName to start the first prop, preceded by another jsxName to end the tag name.\n    // jsxName to start the first prop, preceded by greaterThan to end the type argument.\n    // [open brace] to start the first prop.\n    // [jsxTagEnd] to end the open-tag.\n    // [slash, jsxTagEnd] to end the self-closing tag.\n    let introEnd = this.tokens.currentIndex() + 1;\n    while (\n      this.tokens.tokens[introEnd].isType ||\n      (!this.tokens.matches2AtIndex(introEnd - 1, tt.jsxName, tt.jsxName) &&\n        !this.tokens.matches2AtIndex(introEnd - 1, tt.greaterThan, tt.jsxName) &&\n        !this.tokens.matches1AtIndex(introEnd, tt.braceL) &&\n        !this.tokens.matches1AtIndex(introEnd, tt.jsxTagEnd) &&\n        !this.tokens.matches2AtIndex(introEnd, tt.slash, tt.jsxTagEnd))\n    ) {\n      introEnd++;\n    }\n    if (introEnd === this.tokens.currentIndex() + 1) {\n      const tagName = this.tokens.identifierName();\n      if (startsWithLowerCase(tagName)) {\n        this.tokens.replaceToken(`'${tagName}'`);\n      }\n    }\n    while (this.tokens.currentIndex() < introEnd) {\n      this.rootTransformer.processToken();\n    }\n  }\n\n  /**\n   * Starting at the beginning of the props, add the props argument to\n   * React.createElement, including the comma before it.\n   */\n  processPropsObjectWithDevInfo(elementLocationCode) {\n    const devProps = this.options.production\n      ? \"\"\n      : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;\n    if (!this.tokens.matches1(tt.jsxName) && !this.tokens.matches1(tt.braceL)) {\n      if (devProps) {\n        this.tokens.appendCode(`, {${devProps}}`);\n      } else {\n        this.tokens.appendCode(`, null`);\n      }\n      return;\n    }\n    this.tokens.appendCode(`, {`);\n    this.processProps(false);\n    if (devProps) {\n      this.tokens.appendCode(` ${devProps}}`);\n    } else {\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  /**\n   * Transform the core part of the props, assuming that a { has already been\n   * inserted before us and that a } will be inserted after us.\n   *\n   * If extractKeyCode is true (i.e. when using any jsx... function), any prop\n   * named \"key\" has its code captured and returned rather than being emitted to\n   * the output code. This shifts line numbers, and emitting the code later will\n   * correct line numbers again. If no key is found or if extractKeyCode is\n   * false, this function returns null.\n   */\n  processProps(extractKeyCode) {\n    let keyCode = null;\n    while (true) {\n      if (this.tokens.matches2(tt.jsxName, tt.eq)) {\n        // This is a regular key={value} or key=\"value\" prop.\n        const propName = this.tokens.identifierName();\n        if (extractKeyCode && propName === \"key\") {\n          if (keyCode !== null) {\n            // The props list has multiple keys. Different implementations are\n            // inconsistent about what to do here: as of this writing, Babel and\n            // swc keep the *last* key and completely remove the rest, while\n            // TypeScript uses the *first* key and leaves the others as regular\n            // props. The React team collaborated with Babel on the\n            // implementation of this behavior, so presumably the Babel behavior\n            // is the one to use.\n            // Since we won't ever be emitting the previous key code, we need to\n            // at least emit its newlines here so that the line numbers match up\n            // in the long run.\n            this.tokens.appendCode(keyCode.replace(/[^\\n]/g, \"\"));\n          }\n          // key\n          this.tokens.removeToken();\n          // =\n          this.tokens.removeToken();\n          const snapshot = this.tokens.snapshot();\n          this.processPropValue();\n          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);\n          // Don't add a comma\n          continue;\n        } else {\n          this.processPropName(propName);\n          this.tokens.replaceToken(\": \");\n          this.processPropValue();\n        }\n      } else if (this.tokens.matches1(tt.jsxName)) {\n        // This is a shorthand prop like <input disabled />.\n        const propName = this.tokens.identifierName();\n        this.processPropName(propName);\n        this.tokens.appendCode(\": true\");\n      } else if (this.tokens.matches1(tt.braceL)) {\n        // This is prop spread, like <div {...getProps()}>, which we can pass\n        // through fairly directly as an object spread.\n        this.tokens.replaceToken(\"\");\n        this.rootTransformer.processBalancedCode();\n        this.tokens.replaceToken(\"\");\n      } else {\n        break;\n      }\n      this.tokens.appendCode(\",\");\n    }\n    return keyCode;\n  }\n\n  processPropName(propName) {\n    if (propName.includes(\"-\")) {\n      this.tokens.replaceToken(`'${propName}'`);\n    } else {\n      this.tokens.copyToken();\n    }\n  }\n\n  processPropValue() {\n    if (this.tokens.matches1(tt.braceL)) {\n      this.tokens.replaceToken(\"\");\n      this.rootTransformer.processBalancedCode();\n      this.tokens.replaceToken(\"\");\n    } else if (this.tokens.matches1(tt.jsxTagStart)) {\n      this.processJSXTag();\n    } else {\n      this.processStringPropValue();\n    }\n  }\n\n  processStringPropValue() {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXStringValueLiteral(valueCode);\n    this.tokens.replaceToken(literalCode + replacementCode);\n  }\n\n  /**\n   * Starting in the middle of the props object literal, produce an additional\n   * prop for the children and close the object literal.\n   */\n  processAutomaticChildrenAndEndProps(jsxRole) {\n    if (jsxRole === JSXRole.StaticChildren) {\n      this.tokens.appendCode(\" children: [\");\n      this.processChildren(false);\n      this.tokens.appendCode(\"]}\");\n    } else {\n      // The parser information tells us whether we will see a real child or if\n      // all remaining children (if any) will resolve to empty. If there are no\n      // non-empty children, don't emit a children prop at all, but still\n      // process children so that we properly transform the code into nothing.\n      if (jsxRole === JSXRole.OneChild) {\n        this.tokens.appendCode(\" children: \");\n      }\n      this.processChildren(false);\n      this.tokens.appendCode(\"}\");\n    }\n  }\n\n  /**\n   * Transform children into a comma-separated list, which will be either\n   * arguments to createElement or array elements of a children prop.\n   */\n  processChildren(needsInitialComma) {\n    let needsComma = needsInitialComma;\n    while (true) {\n      if (this.tokens.matches2(tt.jsxTagStart, tt.slash)) {\n        // Closing tag, so no more children.\n        return;\n      }\n      let didEmitElement = false;\n      if (this.tokens.matches1(tt.braceL)) {\n        if (this.tokens.matches2(tt.braceL, tt.braceR)) {\n          // Empty interpolations and comment-only interpolations are allowed\n          // and don't create an extra child arg.\n          this.tokens.replaceToken(\"\");\n          this.tokens.replaceToken(\"\");\n        } else {\n          // Interpolated expression.\n          this.tokens.replaceToken(needsComma ? \", \" : \"\");\n          this.rootTransformer.processBalancedCode();\n          this.tokens.replaceToken(\"\");\n          didEmitElement = true;\n        }\n      } else if (this.tokens.matches1(tt.jsxTagStart)) {\n        // Child JSX element\n        this.tokens.appendCode(needsComma ? \", \" : \"\");\n        this.processJSXTag();\n        didEmitElement = true;\n      } else if (this.tokens.matches1(tt.jsxText) || this.tokens.matches1(tt.jsxEmptyText)) {\n        didEmitElement = this.processChildTextElement(needsComma);\n      } else {\n        throw new Error(\"Unexpected token when processing JSX children.\");\n      }\n      if (didEmitElement) {\n        needsComma = true;\n      }\n    }\n  }\n\n  /**\n   * Turn a JSX text element into a string literal, or nothing at all if the JSX\n   * text resolves to the empty string.\n   *\n   * Returns true if a string literal is emitted, false otherwise.\n   */\n  processChildTextElement(needsComma) {\n    const token = this.tokens.currentToken();\n    const valueCode = this.tokens.code.slice(token.start, token.end);\n    const replacementCode = formatJSXTextReplacement(valueCode);\n    const literalCode = formatJSXTextLiteral(valueCode);\n    if (literalCode === '\"\"') {\n      this.tokens.replaceToken(replacementCode);\n      return false;\n    } else {\n      this.tokens.replaceToken(`${needsComma ? \", \" : \"\"}${literalCode}${replacementCode}`);\n      return true;\n    }\n  }\n\n  getDevSource(elementLocationCode) {\n    return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;\n  }\n\n  getFilenameVarName() {\n    if (!this.filenameVarName) {\n      this.filenameVarName = this.nameManager.claimFreeName(\"_jsxFileName\");\n    }\n    return this.filenameVarName;\n  }\n}\n\n/**\n * Spec for identifiers: https://tc39.github.io/ecma262/#prod-IdentifierStart.\n *\n * Really only treat anything starting with a-z as tag names.  `_`, `$`, `é`\n * should be treated as component names\n */\nexport function startsWithLowerCase(s) {\n  const firstChar = s.charCodeAt(0);\n  return firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ;\n}\n\n/**\n * Turn the given jsxText string into a JS string literal. Leading and trailing\n * whitespace on lines is removed, except immediately after the open-tag and\n * before the close-tag. Empty lines are completely removed, and spaces are\n * added between lines after that.\n *\n * We use JSON.stringify to introduce escape characters as necessary, and trim\n * the start and end of each line and remove blank lines.\n */\nfunction formatJSXTextLiteral(text) {\n  let result = \"\";\n  let whitespace = \"\";\n\n  let isInInitialLineWhitespace = false;\n  let seenNonWhitespace = false;\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \" \" || c === \"\\t\" || c === \"\\r\") {\n      if (!isInInitialLineWhitespace) {\n        whitespace += c;\n      }\n    } else if (c === \"\\n\") {\n      whitespace = \"\";\n      isInInitialLineWhitespace = true;\n    } else {\n      if (seenNonWhitespace && isInInitialLineWhitespace) {\n        result += \" \";\n      }\n      result += whitespace;\n      whitespace = \"\";\n      if (c === \"&\") {\n        const {entity, newI} = processEntity(text, i + 1);\n        i = newI - 1;\n        result += entity;\n      } else {\n        result += c;\n      }\n      seenNonWhitespace = true;\n      isInInitialLineWhitespace = false;\n    }\n  }\n  if (!isInInitialLineWhitespace) {\n    result += whitespace;\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Produce the code that should be printed after the JSX text string literal,\n * with most content removed, but all newlines preserved and all spacing at the\n * end preserved.\n */\nfunction formatJSXTextReplacement(text) {\n  let numNewlines = 0;\n  let numSpaces = 0;\n  for (const c of text) {\n    if (c === \"\\n\") {\n      numNewlines++;\n      numSpaces = 0;\n    } else if (c === \" \") {\n      numSpaces++;\n    }\n  }\n  return \"\\n\".repeat(numNewlines) + \" \".repeat(numSpaces);\n}\n\n/**\n * Format a string in the value position of a JSX prop.\n *\n * Use the same implementation as convertAttribute from\n * babel-helper-builder-react-jsx.\n */\nfunction formatJSXStringValueLiteral(text) {\n  let result = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const c = text[i];\n    if (c === \"\\n\") {\n      if (/\\s/.test(text[i + 1])) {\n        result += \" \";\n        while (i < text.length && /\\s/.test(text[i + 1])) {\n          i++;\n        }\n      } else {\n        result += \"\\n\";\n      }\n    } else if (c === \"&\") {\n      const {entity, newI} = processEntity(text, i + 1);\n      result += entity;\n      i = newI - 1;\n    } else {\n      result += c;\n    }\n  }\n  return JSON.stringify(result);\n}\n\n/**\n * Starting at a &, see if there's an HTML entity (specified by name, decimal\n * char code, or hex char code) and return it if so.\n *\n * Modified from jsxReadString in babel-parser.\n */\nfunction processEntity(text, indexAfterAmpersand) {\n  let str = \"\";\n  let count = 0;\n  let entity;\n  let i = indexAfterAmpersand;\n\n  if (text[i] === \"#\") {\n    let radix = 10;\n    i++;\n    let numStart;\n    if (text[i] === \"x\") {\n      radix = 16;\n      i++;\n      numStart = i;\n      while (i < text.length && isHexDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    } else {\n      numStart = i;\n      while (i < text.length && isDecimalDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text[i] === \";\") {\n      const numStr = text.slice(numStart, i);\n      if (numStr) {\n        i++;\n        entity = String.fromCodePoint(parseInt(numStr, radix));\n      }\n    }\n  } else {\n    while (i < text.length && count++ < 10) {\n      const ch = text[i];\n      i++;\n      if (ch === \";\") {\n        entity = XHTMLEntities.get(str);\n        break;\n      }\n      str += ch;\n    }\n  }\n\n  if (!entity) {\n    return {entity: \"&\", newI: indexAfterAmpersand};\n  }\n  return {entity, newI: i};\n}\n\nfunction isDecimalDigit(code) {\n  return code >= charCodes.digit0 && code <= charCodes.digit9;\n}\n\nfunction isHexDigit(code) {\n  return (\n    (code >= charCodes.digit0 && code <= charCodes.digit9) ||\n    (code >= charCodes.lowercaseA && code <= charCodes.lowercaseF) ||\n    (code >= charCodes.uppercaseA && code <= charCodes.uppercaseF)\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}