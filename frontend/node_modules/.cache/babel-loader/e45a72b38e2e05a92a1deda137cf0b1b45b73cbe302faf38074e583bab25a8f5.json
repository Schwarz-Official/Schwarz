{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\nvar _util = require(\"./util\");\nvar _WHITESPACE_TOKENS, _Object$assign;\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n  if (typeof value !== \"string\") {\n    return;\n  }\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n  return node;\n}\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n  return indexes;\n}\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n  var _proto = Parser.prototype;\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n          if (this.options.lossy) {\n            break;\n          }\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n          break;\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n            lastAdded = 'namespace';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n            break;\n          }\n        // Falls through\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&\n          // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n            node.attribute = (node.attribute || \"\") + content;\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !(spaceAfterMeaningfulToken || node.quoteMark)) {\n            var _unescaped = (0, _util.unesc)(content);\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n              lastAdded = 'insensitive';\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n            unescaped = _unescapeValue.unescaped,\n            quoteMark = _unescapeValue.quoteMark;\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n          break;\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n      pos++;\n    }\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */;\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   *\n   * @param {*} nodes\n   */;\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n    if (this.content() === '|') {\n      return this.namespace();\n    }\n    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n      if (nodes.length > 0) {\n        var last = this.current.last;\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n            space = _this$convertWhitespa.space,\n            rawSpace = _this$convertWhitespa.rawSpace;\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n      return;\n    }\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n    var node;\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n      // pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n          _space = _this$convertWhitespa2.space,\n          _rawSpace = _this$convertWhitespa2.rawSpace;\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n        _space2 = _this$convertWhitespa3.space,\n        _rawSpace2 = _this$convertWhitespa3.rawSpace;\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n    return this.newNode(node);\n  };\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n    this.current._inferEndPosition();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.unexpectedPipe = function unexpectedPipe() {\n    return this.error(\"Unexpected '|'.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n    this.unexpectedPipe();\n  };\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  _proto.space = function space() {\n    var content = this.content();\n    // Handle space before and after the selector\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n    var nextToken = this.nextToken;\n    var word = this.content();\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n      nextToken = this.nextToken;\n    }\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      // Allow escaped dot within class name\n      var escapedDot = word[i - 1] === '\\\\';\n      // Allow decimal numbers percent in @keyframes\n      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n      return !escapedDot && !isKeyframesPercent;\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    // Eliminate Sass interpolations from the list of id indexes\n    var interpolations = indexesOf(word, '#{');\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n      _this5.newNode(node, namespace);\n      // Ensure that the namespace is used only once\n      namespace = null;\n    });\n    this.position++;\n  };\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    return this.splitWord(namespace);\n  };\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n    this.current._inferEndPosition();\n    return this.root;\n  };\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n      case tokens.comment:\n        this.comment();\n        break;\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n        break;\n      case tokens.openSquare:\n        this.attribute();\n        break;\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n      case tokens.colon:\n        this.pseudo();\n        break;\n      case tokens.comma:\n        this.comma();\n        break;\n      case tokens.asterisk:\n        this.universal();\n        break;\n      case tokens.ampersand:\n        this.nesting();\n        break;\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n      case tokens.semicolon:\n        this.missingBackslash();\n      default:\n        this.unexpected();\n    }\n  }\n\n  /**\n   * Helpers\n   */;\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n        namespace = true;\n      }\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n    return this.current.append(node);\n  };\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n    var searchPosition = startPosition;\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n    return -1;\n  };\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n  return Parser;\n}();\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;","map":{"version":3,"names":["exports","__esModule","_root","_interopRequireDefault","require","_selector","_className","_comment","_id","_tag","_string","_pseudo","_attribute","_interopRequireWildcard","_universal","_combinator","_nesting","_sortAscending","_tokenize","tokens","types","_util","_WHITESPACE_TOKENS","_Object$assign","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","_createClass","Constructor","protoProps","staticProps","WHITESPACE_TOKENS","space","cr","feed","newline","tab","WHITESPACE_EQUIV_TOKENS","assign","comment","tokenStart","token","line","FIELDS","START_LINE","column","START_COL","tokenEnd","END_LINE","END_COL","getSource","startLine","startColumn","endLine","endColumn","start","end","getTokenSource","getTokenSourceSpan","startToken","endToken","undefined","unescapeProp","node","prop","value","indexOf","ensureObject","unesc","raws","indexesOf","array","item","indexes","push","uniqs","list","Array","concat","apply","arguments","filter","Parser","rule","options","lossy","safe","position","css","selector","error","_errorGenerator","rootSource","root","source","errorGenerator","append","current","loop","_proto","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","TYPE","closeSquare","expected","START_POS","len","sourceIndex","word","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","content","next","prevContent","spaces","after","existingComment","getProp","asterisk","equals","operator","namespace","before","rawValue","dollar","oldRawValue","caret","combinator","_rawValue","quoteMark","_unescaped","_oldRawValue","oldValue","insensitive","insensitiveFlag","str","index","_unescapeValue","unescapeValue","unescaped","lastComment","rawLastComment","lastValue","rawLastValue","newNode","parseWhitespaceEquivalentTokens","stopPosition","startPosition","nodes","firstToken","lastToken","convertWhitespaceNodesToSpace","requiredSpace","_this2","rawSpace","forEach","n","lossySpace","rawSpaceBefore","rawSpaceAfter","result","isNamedCombinator","slash","namedCombinator","nameRaw","name","toLowerCase","unexpected","_this3","nextSigTokenPos","locateNextMeaningfulToken","comma","last","_this$convertWhitespa","spaceOrDescendantSelectorNodes","_this$convertWhitespa2","_space","_rawSpace","_this$convertWhitespa3","_space2","_rawSpace2","endsWith","slice","startsWith","optionalSpace","trailingComma","_inferEndPosition","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","unexpectedPipe","prevToken","nextToken","universal","nesting","nextContent","parentheses","unbalanced","type","PSEUDO","openParenthesis","closeParenthesis","parse","parenStart","parenValue","parenEnd","parseParenthesisToken","appendToPropertyAndEscape","pseudo","_this4","pseudoStr","colon","splitWord","first","every","string","firstCallback","_this5","lastIndexOf","hasClass","escapedDot","isKeyframesPercent","test","hasId","interpolations","hashIndex","indices","ind","classNameOpts","idOpts","tagOpts","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","isArray","pop","join","an","required","END_POS","searchPosition","module","default"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/postcss-selector-parser/dist/parser.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\nvar _util = require(\"./util\");\nvar _WHITESPACE_TOKENS, _Object$assign;\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n  if (typeof value !== \"string\") {\n    return;\n  }\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n  return node;\n}\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n  return indexes;\n}\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n  var _proto = Parser.prototype;\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n          if (this.options.lossy) {\n            break;\n          }\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n          break;\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n            lastAdded = 'namespace';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n            break;\n          }\n        // Falls through\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&\n          // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n            node.attribute = (node.attribute || \"\") + content;\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !(spaceAfterMeaningfulToken || node.quoteMark)) {\n            var _unescaped = (0, _util.unesc)(content);\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n              lastAdded = 'insensitive';\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n            unescaped = _unescapeValue.unescaped,\n            quoteMark = _unescapeValue.quoteMark;\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n          break;\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n      pos++;\n    }\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */;\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n    return nodes;\n  }\n\n  /**\n   *\n   * @param {*} nodes\n   */;\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n    if (this.content() === '|') {\n      return this.namespace();\n    }\n    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n      if (nodes.length > 0) {\n        var last = this.current.last;\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n            space = _this$convertWhitespa.space,\n            rawSpace = _this$convertWhitespa.rawSpace;\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n      return;\n    }\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n    var node;\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n      // pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n          _space = _this$convertWhitespa2.space,\n          _rawSpace = _this$convertWhitespa2.rawSpace;\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n        _space2 = _this$convertWhitespa3.space,\n        _rawSpace2 = _this$convertWhitespa3.rawSpace;\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n    return this.newNode(node);\n  };\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n    this.current._inferEndPosition();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.unexpectedPipe = function unexpectedPipe() {\n    return this.error(\"Unexpected '|'.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n    this.unexpectedPipe();\n  };\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n  _proto.space = function space() {\n    var content = this.content();\n    // Handle space before and after the selector\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n    var nextToken = this.nextToken;\n    var word = this.content();\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n      nextToken = this.nextToken;\n    }\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      // Allow escaped dot within class name\n      var escapedDot = word[i - 1] === '\\\\';\n      // Allow decimal numbers percent in @keyframes\n      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n      return !escapedDot && !isKeyframesPercent;\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    // Eliminate Sass interpolations from the list of id indexes\n    var interpolations = indexesOf(word, '#{');\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n      _this5.newNode(node, namespace);\n      // Ensure that the namespace is used only once\n      namespace = null;\n    });\n    this.position++;\n  };\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n    return this.splitWord(namespace);\n  };\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n    this.current._inferEndPosition();\n    return this.root;\n  };\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n      case tokens.comment:\n        this.comment();\n        break;\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n        break;\n      case tokens.openSquare:\n        this.attribute();\n        break;\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n      case tokens.colon:\n        this.pseudo();\n        break;\n      case tokens.comma:\n        this.comma();\n        break;\n      case tokens.asterisk:\n        this.universal();\n        break;\n      case tokens.ampersand:\n        this.nesting();\n        break;\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n      case tokens.semicolon:\n        this.missingBackslash();\n      default:\n        this.unexpected();\n    }\n  }\n\n  /**\n   * Helpers\n   */;\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n        namespace = true;\n      }\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n    return this.current.append(node);\n  };\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n    var searchPosition = startPosition;\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n    return -1;\n  };\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n  return Parser;\n}();\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}