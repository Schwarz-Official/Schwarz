{"ast":null,"code":"import { TokenType as tt } from \"./parser/tokenizer/types\";\nimport isAsyncOperation from \"./util/isAsyncOperation\";\nexport default class TokenProcessor {\n  __init() {\n    this.resultCode = \"\";\n  }\n  // Array mapping input token index to optional string index position in the\n  // output code.\n  __init2() {\n    this.resultMappings = new Array(this.tokens.length);\n  }\n  __init3() {\n    this.tokenIndex = 0;\n  }\n  constructor(code, tokens, isFlowEnabled, disableESTransforms, helperManager) {\n    ;\n    this.code = code;\n    this.tokens = tokens;\n    this.isFlowEnabled = isFlowEnabled;\n    this.disableESTransforms = disableESTransforms;\n    this.helperManager = helperManager;\n    TokenProcessor.prototype.__init.call(this);\n    TokenProcessor.prototype.__init2.call(this);\n    TokenProcessor.prototype.__init3.call(this);\n  }\n\n  /**\n   * Snapshot the token state in a way that can be restored later, useful for\n   * things like lookahead.\n   *\n   * resultMappings do not need to be copied since in all use cases, they will\n   * be overwritten anyway after restore.\n   */\n  snapshot() {\n    return {\n      resultCode: this.resultCode,\n      tokenIndex: this.tokenIndex\n    };\n  }\n  restoreToSnapshot(snapshot) {\n    this.resultCode = snapshot.resultCode;\n    this.tokenIndex = snapshot.tokenIndex;\n  }\n\n  /**\n   * Remove and return the code generated since the snapshot, leaving the\n   * current token position in-place. Unlike most TokenProcessor operations,\n   * this operation can result in input/output line number mismatches because\n   * the removed code may contain newlines, so this operation should be used\n   * sparingly.\n   */\n  dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {\n    const result = this.resultCode.slice(snapshot.resultCode.length);\n    this.resultCode = snapshot.resultCode;\n    return result;\n  }\n  reset() {\n    this.resultCode = \"\";\n    this.resultMappings = new Array(this.tokens.length);\n    this.tokenIndex = 0;\n  }\n  matchesContextualAtIndex(index, contextualKeyword) {\n    return this.matches1AtIndex(index, tt.name) && this.tokens[index].contextualKeyword === contextualKeyword;\n  }\n  identifierNameAtIndex(index) {\n    // TODO: We need to process escapes since technically you can have unicode escapes in variable\n    // names.\n    return this.identifierNameForToken(this.tokens[index]);\n  }\n  identifierNameAtRelativeIndex(relativeIndex) {\n    return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));\n  }\n  identifierName() {\n    return this.identifierNameForToken(this.currentToken());\n  }\n  identifierNameForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n  rawCodeForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n  stringValueAtIndex(index) {\n    return this.stringValueForToken(this.tokens[index]);\n  }\n  stringValue() {\n    return this.stringValueForToken(this.currentToken());\n  }\n  stringValueForToken(token) {\n    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.\n    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw\n    // code.\n    return this.code.slice(token.start + 1, token.end - 1);\n  }\n  matches1AtIndex(index, t1) {\n    return this.tokens[index].type === t1;\n  }\n  matches2AtIndex(index, t1, t2) {\n    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;\n  }\n  matches3AtIndex(index, t1, t2, t3) {\n    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2 && this.tokens[index + 2].type === t3;\n  }\n  matches1(t1) {\n    return this.tokens[this.tokenIndex].type === t1;\n  }\n  matches2(t1, t2) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;\n  }\n  matches3(t1, t2, t3) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3;\n  }\n  matches4(t1, t2, t3, t4) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4;\n  }\n  matches5(t1, t2, t3, t4, t5) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4 && this.tokens[this.tokenIndex + 4].type === t5;\n  }\n  matchesContextual(contextualKeyword) {\n    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);\n  }\n  matchesContextIdAndLabel(type, contextId) {\n    return this.matches1(type) && this.currentToken().contextId === contextId;\n  }\n  previousWhitespaceAndComments() {\n    let whitespaceAndComments = this.code.slice(this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0, this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length);\n    if (this.isFlowEnabled) {\n      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, \"\");\n    }\n    return whitespaceAndComments;\n  }\n  replaceToken(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n  replaceTokenTrimmingLeftWhitespace(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\\r\\n]/g, \"\");\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n  removeInitialToken() {\n    this.replaceToken(\"\");\n  }\n  removeToken() {\n    this.replaceTokenTrimmingLeftWhitespace(\"\");\n  }\n\n  /**\n   * Remove all code until the next }, accounting for balanced braces.\n   */\n  removeBalancedCode() {\n    let braceDepth = 0;\n    while (!this.isAtEnd()) {\n      if (this.matches1(tt.braceL)) {\n        braceDepth++;\n      } else if (this.matches1(tt.braceR)) {\n        if (braceDepth === 0) {\n          return;\n        }\n        braceDepth--;\n      }\n      this.removeToken();\n    }\n  }\n  copyExpectedToken(tokenType) {\n    if (this.tokens[this.tokenIndex].type !== tokenType) {\n      throw new Error(`Expected token ${tokenType}`);\n    }\n    this.copyToken();\n  }\n  copyToken() {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n  copyTokenWithPrefix(prefix) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += prefix;\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n  appendTokenPrefix() {\n    const token = this.currentToken();\n    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {\n      token.isAsyncOperation = isAsyncOperation(this);\n    }\n    if (this.disableESTransforms) {\n      return;\n    }\n    if (token.numNullishCoalesceStarts) {\n      for (let i = 0; i < token.numNullishCoalesceStarts; i++) {\n        if (token.isAsyncOperation) {\n          this.resultCode += \"await \";\n          this.resultCode += this.helperManager.getHelperName(\"asyncNullishCoalesce\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"nullishCoalesce\");\n        }\n        this.resultCode += \"(\";\n      }\n    }\n    if (token.isOptionalChainStart) {\n      if (token.isAsyncOperation) {\n        this.resultCode += \"await \";\n      }\n      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === tt._delete) {\n        if (token.isAsyncOperation) {\n          this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChainDelete\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"optionalChainDelete\");\n        }\n      } else if (token.isAsyncOperation) {\n        this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChain\");\n      } else {\n        this.resultCode += this.helperManager.getHelperName(\"optionalChain\");\n      }\n      this.resultCode += \"([\";\n    }\n  }\n  appendTokenSuffix() {\n    const token = this.currentToken();\n    if (token.isOptionalChainEnd && !this.disableESTransforms) {\n      this.resultCode += \"])\";\n    }\n    if (token.numNullishCoalesceEnds && !this.disableESTransforms) {\n      for (let i = 0; i < token.numNullishCoalesceEnds; i++) {\n        this.resultCode += \"))\";\n      }\n    }\n  }\n  appendCode(code) {\n    this.resultCode += code;\n  }\n  currentToken() {\n    return this.tokens[this.tokenIndex];\n  }\n  currentTokenCode() {\n    const token = this.currentToken();\n    return this.code.slice(token.start, token.end);\n  }\n  tokenAtRelativeIndex(relativeIndex) {\n    return this.tokens[this.tokenIndex + relativeIndex];\n  }\n  currentIndex() {\n    return this.tokenIndex;\n  }\n\n  /**\n   * Move to the next token. Only suitable in preprocessing steps. When\n   * generating new code, you should use copyToken or removeToken.\n   */\n  nextToken() {\n    if (this.tokenIndex === this.tokens.length) {\n      throw new Error(\"Unexpectedly reached end of input.\");\n    }\n    this.tokenIndex++;\n  }\n  previousToken() {\n    this.tokenIndex--;\n  }\n  finish() {\n    if (this.tokenIndex !== this.tokens.length) {\n      throw new Error(\"Tried to finish processing tokens before reaching the end.\");\n    }\n    this.resultCode += this.previousWhitespaceAndComments();\n    return {\n      code: this.resultCode,\n      mappings: this.resultMappings\n    };\n  }\n  isAtEnd() {\n    return this.tokenIndex === this.tokens.length;\n  }\n}","map":{"version":3,"names":["TokenType","tt","isAsyncOperation","TokenProcessor","__init","resultCode","__init2","resultMappings","Array","tokens","length","__init3","tokenIndex","constructor","code","isFlowEnabled","disableESTransforms","helperManager","prototype","call","snapshot","restoreToSnapshot","dangerouslyGetAndRemoveCodeSinceSnapshot","result","slice","reset","matchesContextualAtIndex","index","contextualKeyword","matches1AtIndex","name","identifierNameAtIndex","identifierNameForToken","identifierNameAtRelativeIndex","relativeIndex","tokenAtRelativeIndex","identifierName","currentToken","token","start","end","rawCodeForToken","stringValueAtIndex","stringValueForToken","stringValue","t1","type","matches2AtIndex","t2","matches3AtIndex","t3","matches1","matches2","matches3","matches4","t4","matches5","t5","matchesContextual","matchesContextIdAndLabel","contextId","previousWhitespaceAndComments","whitespaceAndComments","replace","replaceToken","newCode","appendTokenPrefix","appendTokenSuffix","replaceTokenTrimmingLeftWhitespace","removeInitialToken","removeToken","removeBalancedCode","braceDepth","isAtEnd","braceL","braceR","copyExpectedToken","tokenType","Error","copyToken","copyTokenWithPrefix","prefix","numNullishCoalesceStarts","isOptionalChainStart","i","getHelperName","_delete","isOptionalChainEnd","numNullishCoalesceEnds","appendCode","currentTokenCode","currentIndex","nextToken","previousToken","finish","mappings"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/TokenProcessor.js"],"sourcesContent":["\n\n\nimport { TokenType as tt} from \"./parser/tokenizer/types\";\nimport isAsyncOperation from \"./util/isAsyncOperation\";\n\n\n\n\n\n\n\n\n\n\n\nexport default class TokenProcessor {\n   __init() {this.resultCode = \"\"}\n  // Array mapping input token index to optional string index position in the\n  // output code.\n   __init2() {this.resultMappings = new Array(this.tokens.length)}\n   __init3() {this.tokenIndex = 0}\n\n  constructor(\n     code,\n     tokens,\n     isFlowEnabled,\n     disableESTransforms,\n     helperManager,\n  ) {;this.code = code;this.tokens = tokens;this.isFlowEnabled = isFlowEnabled;this.disableESTransforms = disableESTransforms;this.helperManager = helperManager;TokenProcessor.prototype.__init.call(this);TokenProcessor.prototype.__init2.call(this);TokenProcessor.prototype.__init3.call(this);}\n\n  /**\n   * Snapshot the token state in a way that can be restored later, useful for\n   * things like lookahead.\n   *\n   * resultMappings do not need to be copied since in all use cases, they will\n   * be overwritten anyway after restore.\n   */\n  snapshot() {\n    return {\n      resultCode: this.resultCode,\n      tokenIndex: this.tokenIndex,\n    };\n  }\n\n  restoreToSnapshot(snapshot) {\n    this.resultCode = snapshot.resultCode;\n    this.tokenIndex = snapshot.tokenIndex;\n  }\n\n  /**\n   * Remove and return the code generated since the snapshot, leaving the\n   * current token position in-place. Unlike most TokenProcessor operations,\n   * this operation can result in input/output line number mismatches because\n   * the removed code may contain newlines, so this operation should be used\n   * sparingly.\n   */\n  dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {\n    const result = this.resultCode.slice(snapshot.resultCode.length);\n    this.resultCode = snapshot.resultCode;\n    return result;\n  }\n\n  reset() {\n    this.resultCode = \"\";\n    this.resultMappings = new Array(this.tokens.length);\n    this.tokenIndex = 0;\n  }\n\n  matchesContextualAtIndex(index, contextualKeyword) {\n    return (\n      this.matches1AtIndex(index, tt.name) &&\n      this.tokens[index].contextualKeyword === contextualKeyword\n    );\n  }\n\n  identifierNameAtIndex(index) {\n    // TODO: We need to process escapes since technically you can have unicode escapes in variable\n    // names.\n    return this.identifierNameForToken(this.tokens[index]);\n  }\n\n  identifierNameAtRelativeIndex(relativeIndex) {\n    return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));\n  }\n\n  identifierName() {\n    return this.identifierNameForToken(this.currentToken());\n  }\n\n  identifierNameForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  rawCodeForToken(token) {\n    return this.code.slice(token.start, token.end);\n  }\n\n  stringValueAtIndex(index) {\n    return this.stringValueForToken(this.tokens[index]);\n  }\n\n  stringValue() {\n    return this.stringValueForToken(this.currentToken());\n  }\n\n  stringValueForToken(token) {\n    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.\n    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw\n    // code.\n    return this.code.slice(token.start + 1, token.end - 1);\n  }\n\n  matches1AtIndex(index, t1) {\n    return this.tokens[index].type === t1;\n  }\n\n  matches2AtIndex(index, t1, t2) {\n    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;\n  }\n\n  matches3AtIndex(index, t1, t2, t3) {\n    return (\n      this.tokens[index].type === t1 &&\n      this.tokens[index + 1].type === t2 &&\n      this.tokens[index + 2].type === t3\n    );\n  }\n\n  matches1(t1) {\n    return this.tokens[this.tokenIndex].type === t1;\n  }\n\n  matches2(t1, t2) {\n    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;\n  }\n\n  matches3(t1, t2, t3) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3\n    );\n  }\n\n  matches4(t1, t2, t3, t4) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4\n    );\n  }\n\n  matches5(t1, t2, t3, t4, t5) {\n    return (\n      this.tokens[this.tokenIndex].type === t1 &&\n      this.tokens[this.tokenIndex + 1].type === t2 &&\n      this.tokens[this.tokenIndex + 2].type === t3 &&\n      this.tokens[this.tokenIndex + 3].type === t4 &&\n      this.tokens[this.tokenIndex + 4].type === t5\n    );\n  }\n\n  matchesContextual(contextualKeyword) {\n    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);\n  }\n\n  matchesContextIdAndLabel(type, contextId) {\n    return this.matches1(type) && this.currentToken().contextId === contextId;\n  }\n\n  previousWhitespaceAndComments() {\n    let whitespaceAndComments = this.code.slice(\n      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,\n      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length,\n    );\n    if (this.isFlowEnabled) {\n      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, \"\");\n    }\n    return whitespaceAndComments;\n  }\n\n  replaceToken(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  replaceTokenTrimmingLeftWhitespace(newCode) {\n    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\\r\\n]/g, \"\");\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += newCode;\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  removeInitialToken() {\n    this.replaceToken(\"\");\n  }\n\n  removeToken() {\n    this.replaceTokenTrimmingLeftWhitespace(\"\");\n  }\n\n  /**\n   * Remove all code until the next }, accounting for balanced braces.\n   */\n  removeBalancedCode() {\n    let braceDepth = 0;\n    while (!this.isAtEnd()) {\n      if (this.matches1(tt.braceL)) {\n        braceDepth++;\n      } else if (this.matches1(tt.braceR)) {\n        if (braceDepth === 0) {\n          return;\n        }\n        braceDepth--;\n      }\n      this.removeToken();\n    }\n  }\n\n  copyExpectedToken(tokenType) {\n    if (this.tokens[this.tokenIndex].type !== tokenType) {\n      throw new Error(`Expected token ${tokenType}`);\n    }\n    this.copyToken();\n  }\n\n  copyToken() {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n  copyTokenWithPrefix(prefix) {\n    this.resultCode += this.previousWhitespaceAndComments();\n    this.appendTokenPrefix();\n    this.resultCode += prefix;\n    this.resultMappings[this.tokenIndex] = this.resultCode.length;\n    this.resultCode += this.code.slice(\n      this.tokens[this.tokenIndex].start,\n      this.tokens[this.tokenIndex].end,\n    );\n    this.appendTokenSuffix();\n    this.tokenIndex++;\n  }\n\n   appendTokenPrefix() {\n    const token = this.currentToken();\n    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {\n      token.isAsyncOperation = isAsyncOperation(this);\n    }\n    if (this.disableESTransforms) {\n      return;\n    }\n    if (token.numNullishCoalesceStarts) {\n      for (let i = 0; i < token.numNullishCoalesceStarts; i++) {\n        if (token.isAsyncOperation) {\n          this.resultCode += \"await \";\n          this.resultCode += this.helperManager.getHelperName(\"asyncNullishCoalesce\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"nullishCoalesce\");\n        }\n        this.resultCode += \"(\";\n      }\n    }\n    if (token.isOptionalChainStart) {\n      if (token.isAsyncOperation) {\n        this.resultCode += \"await \";\n      }\n      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === tt._delete) {\n        if (token.isAsyncOperation) {\n          this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChainDelete\");\n        } else {\n          this.resultCode += this.helperManager.getHelperName(\"optionalChainDelete\");\n        }\n      } else if (token.isAsyncOperation) {\n        this.resultCode += this.helperManager.getHelperName(\"asyncOptionalChain\");\n      } else {\n        this.resultCode += this.helperManager.getHelperName(\"optionalChain\");\n      }\n      this.resultCode += \"([\";\n    }\n  }\n\n   appendTokenSuffix() {\n    const token = this.currentToken();\n    if (token.isOptionalChainEnd && !this.disableESTransforms) {\n      this.resultCode += \"])\";\n    }\n    if (token.numNullishCoalesceEnds && !this.disableESTransforms) {\n      for (let i = 0; i < token.numNullishCoalesceEnds; i++) {\n        this.resultCode += \"))\";\n      }\n    }\n  }\n\n  appendCode(code) {\n    this.resultCode += code;\n  }\n\n  currentToken() {\n    return this.tokens[this.tokenIndex];\n  }\n\n  currentTokenCode() {\n    const token = this.currentToken();\n    return this.code.slice(token.start, token.end);\n  }\n\n  tokenAtRelativeIndex(relativeIndex) {\n    return this.tokens[this.tokenIndex + relativeIndex];\n  }\n\n  currentIndex() {\n    return this.tokenIndex;\n  }\n\n  /**\n   * Move to the next token. Only suitable in preprocessing steps. When\n   * generating new code, you should use copyToken or removeToken.\n   */\n  nextToken() {\n    if (this.tokenIndex === this.tokens.length) {\n      throw new Error(\"Unexpectedly reached end of input.\");\n    }\n    this.tokenIndex++;\n  }\n\n  previousToken() {\n    this.tokenIndex--;\n  }\n\n  finish() {\n    if (this.tokenIndex !== this.tokens.length) {\n      throw new Error(\"Tried to finish processing tokens before reaching the end.\");\n    }\n    this.resultCode += this.previousWhitespaceAndComments();\n    return {code: this.resultCode, mappings: this.resultMappings};\n  }\n\n  isAtEnd() {\n    return this.tokenIndex === this.tokens.length;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}