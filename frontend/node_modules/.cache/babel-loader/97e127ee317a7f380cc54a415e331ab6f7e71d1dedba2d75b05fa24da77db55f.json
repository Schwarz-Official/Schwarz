{"ast":null,"code":"function _optionalChain(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i];\n    const fn = ops[i + 1];\n    i += 2;\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      return undefined;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => value.call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\nimport { TokenType as tt } from \"../parser/tokenizer/types\";\nimport Transformer from \"./Transformer\";\nconst JEST_GLOBAL_NAME = \"jest\";\nconst HOISTED_METHODS = [\"mock\", \"unmock\", \"enableAutomock\", \"disableAutomock\"];\n\n/**\n * Implementation of babel-plugin-jest-hoist, which hoists up some jest method\n * calls above the imports to allow them to override other imports.\n *\n * To preserve line numbers, rather than directly moving the jest.mock code, we\n * wrap each invocation in a function statement and then call the function from\n * the top of the file.\n */\nexport default class JestHoistTransformer extends Transformer {\n  __init() {\n    this.hoistedFunctionNames = [];\n  }\n  constructor(rootTransformer, tokens, nameManager, importProcessor) {\n    super();\n    this.rootTransformer = rootTransformer;\n    this.tokens = tokens;\n    this.nameManager = nameManager;\n    this.importProcessor = importProcessor;\n    JestHoistTransformer.prototype.__init.call(this);\n    ;\n  }\n  process() {\n    if (this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(tt.name, tt.dot, tt.name, tt.parenL) && this.tokens.identifierName() === JEST_GLOBAL_NAME) {\n      // TODO: This only works if imports transform is active, which it will be for jest.\n      //       But if jest adds module support and we no longer need the import transform, this needs fixing.\n      if (_optionalChain([this, 'access', _ => _.importProcessor, 'optionalAccess', _2 => _2.getGlobalNames, 'call', _3 => _3(), 'optionalAccess', _4 => _4.has, 'call', _5 => _5(JEST_GLOBAL_NAME)])) {\n        return false;\n      }\n      return this.extractHoistedCalls();\n    }\n    return false;\n  }\n  getHoistedCode() {\n    if (this.hoistedFunctionNames.length > 0) {\n      // This will be placed before module interop code, but that's fine since\n      // imports aren't allowed in module mock factories.\n      return this.hoistedFunctionNames.map(name => `${name}();`).join(\"\");\n    }\n    return \"\";\n  }\n\n  /**\n   * Extracts any methods calls on the jest-object that should be hoisted.\n   *\n   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,\n   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.\n   *\n   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.\n   */\n  extractHoistedCalls() {\n    // We're handling a chain of calls where `jest` may or may not need to be inserted for each call\n    // in the chain, so remove the initial `jest` to make the loop implementation cleaner.\n    this.tokens.removeToken();\n    // Track some state so that multiple non-hoisted chained calls in a row keep their chaining\n    // syntax.\n    let followsNonHoistedJestCall = false;\n\n    // Iterate through all chained calls on the jest object.\n    while (this.tokens.matches3(tt.dot, tt.name, tt.parenL)) {\n      const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n      const shouldHoist = HOISTED_METHODS.includes(methodName);\n      if (shouldHoist) {\n        // We've matched e.g. `.mock(...)` or similar call.\n        // Replace the initial `.` with `function __jestHoist(){jest.`\n        const hoistedFunctionName = this.nameManager.claimFreeName(\"__jestHoist\");\n        this.hoistedFunctionNames.push(hoistedFunctionName);\n        this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n        this.tokens.appendCode(\";}\");\n        followsNonHoistedJestCall = false;\n      } else {\n        // This is a non-hoisted method, so just transform the code as usual.\n        if (followsNonHoistedJestCall) {\n          // If we didn't hoist the previous call, we can leave the code as-is to chain off of the\n          // previous method call. It's important to preserve the code here because we don't know\n          // for sure that the method actually returned the jest object for chaining.\n          this.tokens.copyToken();\n        } else {\n          // If we hoisted the previous call, we know it returns the jest object back, so we insert\n          // the identifier `jest` to continue the chain.\n          this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);\n        }\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n        followsNonHoistedJestCall = true;\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["_optionalChain","ops","lastAccessLHS","undefined","value","i","length","op","fn","args","call","TokenType","tt","Transformer","JEST_GLOBAL_NAME","HOISTED_METHODS","JestHoistTransformer","__init","hoistedFunctionNames","constructor","rootTransformer","tokens","nameManager","importProcessor","prototype","process","currentToken","scopeDepth","matches4","name","dot","parenL","identifierName","_","_2","getGlobalNames","_3","_4","has","_5","extractHoistedCalls","getHoistedCode","map","join","removeToken","followsNonHoistedJestCall","matches3","methodName","identifierNameAtIndex","currentIndex","shouldHoist","includes","hoistedFunctionName","claimFreeName","push","replaceToken","copyToken","processBalancedCode","copyExpectedToken","parenR","appendCode"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/transformers/JestHoistTransformer.js"],"sourcesContent":[" function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nimport {TokenType as tt} from \"../parser/tokenizer/types\";\n\n\nimport Transformer from \"./Transformer\";\n\nconst JEST_GLOBAL_NAME = \"jest\";\nconst HOISTED_METHODS = [\"mock\", \"unmock\", \"enableAutomock\", \"disableAutomock\"];\n\n/**\n * Implementation of babel-plugin-jest-hoist, which hoists up some jest method\n * calls above the imports to allow them to override other imports.\n *\n * To preserve line numbers, rather than directly moving the jest.mock code, we\n * wrap each invocation in a function statement and then call the function from\n * the top of the file.\n */\nexport default class JestHoistTransformer extends Transformer {\n    __init() {this.hoistedFunctionNames = []}\n\n  constructor(\n     rootTransformer,\n     tokens,\n     nameManager,\n     importProcessor,\n  ) {\n    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.nameManager = nameManager;this.importProcessor = importProcessor;JestHoistTransformer.prototype.__init.call(this);;\n  }\n\n  process() {\n    if (\n      this.tokens.currentToken().scopeDepth === 0 &&\n      this.tokens.matches4(tt.name, tt.dot, tt.name, tt.parenL) &&\n      this.tokens.identifierName() === JEST_GLOBAL_NAME\n    ) {\n      // TODO: This only works if imports transform is active, which it will be for jest.\n      //       But if jest adds module support and we no longer need the import transform, this needs fixing.\n      if (_optionalChain([this, 'access', _ => _.importProcessor, 'optionalAccess', _2 => _2.getGlobalNames, 'call', _3 => _3(), 'optionalAccess', _4 => _4.has, 'call', _5 => _5(JEST_GLOBAL_NAME)])) {\n        return false;\n      }\n      return this.extractHoistedCalls();\n    }\n\n    return false;\n  }\n\n  getHoistedCode() {\n    if (this.hoistedFunctionNames.length > 0) {\n      // This will be placed before module interop code, but that's fine since\n      // imports aren't allowed in module mock factories.\n      return this.hoistedFunctionNames.map((name) => `${name}();`).join(\"\");\n    }\n    return \"\";\n  }\n\n  /**\n   * Extracts any methods calls on the jest-object that should be hoisted.\n   *\n   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,\n   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.\n   *\n   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.\n   */\n   extractHoistedCalls() {\n    // We're handling a chain of calls where `jest` may or may not need to be inserted for each call\n    // in the chain, so remove the initial `jest` to make the loop implementation cleaner.\n    this.tokens.removeToken();\n    // Track some state so that multiple non-hoisted chained calls in a row keep their chaining\n    // syntax.\n    let followsNonHoistedJestCall = false;\n\n    // Iterate through all chained calls on the jest object.\n    while (this.tokens.matches3(tt.dot, tt.name, tt.parenL)) {\n      const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);\n      const shouldHoist = HOISTED_METHODS.includes(methodName);\n      if (shouldHoist) {\n        // We've matched e.g. `.mock(...)` or similar call.\n        // Replace the initial `.` with `function __jestHoist(){jest.`\n        const hoistedFunctionName = this.nameManager.claimFreeName(\"__jestHoist\");\n        this.hoistedFunctionNames.push(hoistedFunctionName);\n        this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n        this.tokens.appendCode(\";}\");\n        followsNonHoistedJestCall = false;\n      } else {\n        // This is a non-hoisted method, so just transform the code as usual.\n        if (followsNonHoistedJestCall) {\n          // If we didn't hoist the previous call, we can leave the code as-is to chain off of the\n          // previous method call. It's important to preserve the code here because we don't know\n          // for sure that the method actually returned the jest object for chaining.\n          this.tokens.copyToken();\n        } else {\n          // If we hoisted the previous call, we know it returns the jest object back, so we insert\n          // the identifier `jest` to continue the chain.\n          this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);\n        }\n        this.tokens.copyToken();\n        this.tokens.copyToken();\n        this.rootTransformer.processBalancedCode();\n        this.tokens.copyExpectedToken(tt.parenR);\n        followsNonHoistedJestCall = true;\n      }\n    }\n\n    return true;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}