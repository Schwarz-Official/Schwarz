{"ast":null,"code":"import { eat, finishToken, IdentifierRole, lookaheadType, lookaheadTypeAndKeyword, match, next, nextTemplateToken, popTypeContext, pushTypeContext, rescan_gt } from \"../tokenizer/index\";\nimport { ContextualKeyword } from \"../tokenizer/keywords\";\nimport { TokenType, TokenType as tt } from \"../tokenizer/types\";\nimport { isJSXEnabled, state } from \"../traverser/base\";\nimport { atPossibleAsync, baseParseMaybeAssign, baseParseSubscript, parseCallExpressionArguments, parseExprAtom, parseExpression, parseFunctionBody, parseIdentifier, parseLiteral, parseMaybeAssign, parseMaybeUnary, parsePropertyName, parseTemplate } from \"../traverser/expression\";\nimport { parseBindingIdentifier, parseBindingList, parseImportedIdentifier } from \"../traverser/lval\";\nimport { baseParseMaybeDecoratorArguments, parseBlockBody, parseClass, parseFunction, parseFunctionParams, parseStatement, parseVarStatement } from \"../traverser/statement\";\nimport { canInsertSemicolon, eatContextual, expect, expectContextual, hasPrecedingLineBreak, isContextual, isLineTerminator, isLookaheadContextual, semicolon, unexpected } from \"../traverser/util\";\nimport { nextJSXTagToken } from \"./jsx\";\nfunction tsIsIdentifier() {\n  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n  // See https://github.com/Microsoft/TypeScript/issues/15008\n  return match(tt.name);\n}\nfunction isLiteralPropertyName() {\n  return match(tt.name) || Boolean(state.type & TokenType.IS_KEYWORD) || match(tt.string) || match(tt.num) || match(tt.bigint) || match(tt.decimal);\n}\nfunction tsNextTokenCanFollowModifier() {\n  // Note: TypeScript's implementation is much more complicated because\n  // more things are considered modifiers there.\n  // This implementation only handles modifiers not handled by babylon itself. And \"static\".\n  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n  const snapshot = state.snapshot();\n  next();\n  const canFollowModifier = (match(tt.bracketL) || match(tt.braceL) || match(tt.star) || match(tt.ellipsis) || match(tt.hash) || isLiteralPropertyName()) && !hasPrecedingLineBreak();\n  if (canFollowModifier) {\n    return true;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n}\nexport function tsParseModifiers(allowedModifiers) {\n  while (true) {\n    const modifier = tsParseModifier(allowedModifiers);\n    if (modifier === null) {\n      break;\n    }\n  }\n}\n\n/** Parses a modifier matching one the given modifier names. */\nexport function tsParseModifier(allowedModifiers) {\n  if (!match(tt.name)) {\n    return null;\n  }\n  const modifier = state.contextualKeyword;\n  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {\n    switch (modifier) {\n      case ContextualKeyword._readonly:\n        state.tokens[state.tokens.length - 1].type = tt._readonly;\n        break;\n      case ContextualKeyword._abstract:\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        break;\n      case ContextualKeyword._static:\n        state.tokens[state.tokens.length - 1].type = tt._static;\n        break;\n      case ContextualKeyword._public:\n        state.tokens[state.tokens.length - 1].type = tt._public;\n        break;\n      case ContextualKeyword._private:\n        state.tokens[state.tokens.length - 1].type = tt._private;\n        break;\n      case ContextualKeyword._protected:\n        state.tokens[state.tokens.length - 1].type = tt._protected;\n        break;\n      case ContextualKeyword._override:\n        state.tokens[state.tokens.length - 1].type = tt._override;\n        break;\n      case ContextualKeyword._declare:\n        state.tokens[state.tokens.length - 1].type = tt._declare;\n        break;\n      default:\n        break;\n    }\n    return modifier;\n  }\n  return null;\n}\nfunction tsParseEntityName() {\n  parseIdentifier();\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\nfunction tsParseTypeReference() {\n  tsParseEntityName();\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\nfunction tsParseThisTypePredicate() {\n  next();\n  tsParseTypeAnnotation();\n}\nfunction tsParseThisTypeNode() {\n  next();\n}\nfunction tsParseTypeQuery() {\n  expect(tt._typeof);\n  if (match(tt._import)) {\n    tsParseImportType();\n  } else {\n    tsParseEntityName();\n  }\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\nfunction tsParseImportType() {\n  expect(tt._import);\n  expect(tt.parenL);\n  expect(tt.string);\n  expect(tt.parenR);\n  if (eat(tt.dot)) {\n    tsParseEntityName();\n  }\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\nfunction tsParseTypeParameter() {\n  eat(tt._const);\n  const hadIn = eat(tt._in);\n  const hadOut = eatContextual(ContextualKeyword._out);\n  eat(tt._const);\n  if ((hadIn || hadOut) && !match(tt.name)) {\n    // The \"in\" or \"out\" keyword must have actually been the type parameter\n    // name, so set it as the name.\n    state.tokens[state.tokens.length - 1].type = tt.name;\n  } else {\n    parseIdentifier();\n  }\n  if (eat(tt._extends)) {\n    tsParseType();\n  }\n  if (eat(tt.eq)) {\n    tsParseType();\n  }\n}\nexport function tsTryParseTypeParameters() {\n  if (match(tt.lessThan)) {\n    tsParseTypeParameters();\n  }\n}\nfunction tsParseTypeParameters() {\n  const oldIsType = pushTypeContext(0);\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n  while (!eat(tt.greaterThan) && !state.error) {\n    tsParseTypeParameter();\n    eat(tt.comma);\n  }\n  popTypeContext(oldIsType);\n}\n\n// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n// but here it's always false, because this is only used for types.\nfunction tsFillSignature(returnToken) {\n  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n  const returnTokenRequired = returnToken === tt.arrow;\n  tsTryParseTypeParameters();\n  expect(tt.parenL);\n  // Create a scope even though we're doing type parsing so we don't accidentally\n  // treat params as top-level bindings.\n  state.scopeDepth++;\n  tsParseBindingListForSignature(false /* isBlockScope */);\n  state.scopeDepth--;\n  if (returnTokenRequired) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  } else if (match(returnToken)) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  }\n}\nfunction tsParseBindingListForSignature(isBlockScope) {\n  parseBindingList(tt.parenR, isBlockScope);\n}\nfunction tsParseTypeMemberSemicolon() {\n  if (!eat(tt.comma)) {\n    semicolon();\n  }\n}\nfunction tsParseSignatureMember() {\n  tsFillSignature(tt.colon);\n  tsParseTypeMemberSemicolon();\n}\nfunction tsIsUnambiguouslyIndexSignature() {\n  const snapshot = state.snapshot();\n  next(); // Skip '{'\n  const isIndexSignature = eat(tt.name) && match(tt.colon);\n  state.restoreFromSnapshot(snapshot);\n  return isIndexSignature;\n}\nfunction tsTryParseIndexSignature() {\n  if (!(match(tt.bracketL) && tsIsUnambiguouslyIndexSignature())) {\n    return false;\n  }\n  const oldIsType = pushTypeContext(0);\n  expect(tt.bracketL);\n  parseIdentifier();\n  tsParseTypeAnnotation();\n  expect(tt.bracketR);\n  tsTryParseTypeAnnotation();\n  tsParseTypeMemberSemicolon();\n  popTypeContext(oldIsType);\n  return true;\n}\nfunction tsParsePropertyOrMethodSignature(isReadonly) {\n  eat(tt.question);\n  if (!isReadonly && (match(tt.parenL) || match(tt.lessThan))) {\n    tsFillSignature(tt.colon);\n    tsParseTypeMemberSemicolon();\n  } else {\n    tsTryParseTypeAnnotation();\n    tsParseTypeMemberSemicolon();\n  }\n}\nfunction tsParseTypeMember() {\n  if (match(tt.parenL) || match(tt.lessThan)) {\n    // call signature\n    tsParseSignatureMember();\n    return;\n  }\n  if (match(tt._new)) {\n    next();\n    if (match(tt.parenL) || match(tt.lessThan)) {\n      // constructor signature\n      tsParseSignatureMember();\n    } else {\n      tsParsePropertyOrMethodSignature(false);\n    }\n    return;\n  }\n  const readonly = !!tsParseModifier([ContextualKeyword._readonly]);\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    return;\n  }\n  if ((isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) && tsNextTokenCanFollowModifier()) {\n    // This is a getter/setter on a type. The tsNextTokenCanFollowModifier\n    // function already called next() for us, so continue parsing the name.\n  }\n  parsePropertyName(-1 /* Types don't need context IDs. */);\n  tsParsePropertyOrMethodSignature(readonly);\n}\nfunction tsParseTypeLiteral() {\n  tsParseObjectTypeMembers();\n}\nfunction tsParseObjectTypeMembers() {\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseTypeMember();\n  }\n}\nfunction tsLookaheadIsStartOfMappedType() {\n  const snapshot = state.snapshot();\n  const isStartOfMappedType = tsIsStartOfMappedType();\n  state.restoreFromSnapshot(snapshot);\n  return isStartOfMappedType;\n}\nfunction tsIsStartOfMappedType() {\n  next();\n  if (eat(tt.plus) || eat(tt.minus)) {\n    return isContextual(ContextualKeyword._readonly);\n  }\n  if (isContextual(ContextualKeyword._readonly)) {\n    next();\n  }\n  if (!match(tt.bracketL)) {\n    return false;\n  }\n  next();\n  if (!tsIsIdentifier()) {\n    return false;\n  }\n  next();\n  return match(tt._in);\n}\nfunction tsParseMappedTypeParameter() {\n  parseIdentifier();\n  expect(tt._in);\n  tsParseType();\n}\nfunction tsParseMappedType() {\n  expect(tt.braceL);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expectContextual(ContextualKeyword._readonly);\n  } else {\n    eatContextual(ContextualKeyword._readonly);\n  }\n  expect(tt.bracketL);\n  tsParseMappedTypeParameter();\n  if (eatContextual(ContextualKeyword._as)) {\n    tsParseType();\n  }\n  expect(tt.bracketR);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expect(tt.question);\n  } else {\n    eat(tt.question);\n  }\n  tsTryParseType();\n  semicolon();\n  expect(tt.braceR);\n}\nfunction tsParseTupleType() {\n  expect(tt.bracketL);\n  while (!eat(tt.bracketR) && !state.error) {\n    // Do not validate presence of either none or only labeled elements\n    tsParseTupleElementType();\n    eat(tt.comma);\n  }\n}\nfunction tsParseTupleElementType() {\n  // parses `...TsType[]`\n  if (eat(tt.ellipsis)) {\n    tsParseType();\n  } else {\n    // parses `TsType?`\n    tsParseType();\n    eat(tt.question);\n  }\n\n  // The type we parsed above was actually a label\n  if (eat(tt.colon)) {\n    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here\n    tsParseType();\n  }\n}\nfunction tsParseParenthesizedType() {\n  expect(tt.parenL);\n  tsParseType();\n  expect(tt.parenR);\n}\nfunction tsParseTemplateLiteralType() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    tsParseType();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\nvar FunctionType;\n(function (FunctionType) {\n  const TSFunctionType = 0;\n  FunctionType[FunctionType[\"TSFunctionType\"] = TSFunctionType] = \"TSFunctionType\";\n  const TSConstructorType = TSFunctionType + 1;\n  FunctionType[FunctionType[\"TSConstructorType\"] = TSConstructorType] = \"TSConstructorType\";\n  const TSAbstractConstructorType = TSConstructorType + 1;\n  FunctionType[FunctionType[\"TSAbstractConstructorType\"] = TSAbstractConstructorType] = \"TSAbstractConstructorType\";\n})(FunctionType || (FunctionType = {}));\nfunction tsParseFunctionOrConstructorType(type) {\n  if (type === FunctionType.TSAbstractConstructorType) {\n    expectContextual(ContextualKeyword._abstract);\n  }\n  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {\n    expect(tt._new);\n  }\n  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n  state.inDisallowConditionalTypesContext = false;\n  tsFillSignature(tt.arrow);\n  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n}\nfunction tsParseNonArrayType() {\n  switch (state.type) {\n    case tt.name:\n      tsParseTypeReference();\n      return;\n    case tt._void:\n    case tt._null:\n      next();\n      return;\n    case tt.string:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt._true:\n    case tt._false:\n      parseLiteral();\n      return;\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n    case tt._this:\n      {\n        tsParseThisTypeNode();\n        if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n          tsParseThisTypePredicate();\n        }\n        return;\n      }\n    case tt._typeof:\n      tsParseTypeQuery();\n      return;\n    case tt._import:\n      tsParseImportType();\n      return;\n    case tt.braceL:\n      if (tsLookaheadIsStartOfMappedType()) {\n        tsParseMappedType();\n      } else {\n        tsParseTypeLiteral();\n      }\n      return;\n    case tt.bracketL:\n      tsParseTupleType();\n      return;\n    case tt.parenL:\n      tsParseParenthesizedType();\n      return;\n    case tt.backQuote:\n      tsParseTemplateLiteralType();\n      return;\n    default:\n      if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n      break;\n  }\n  unexpected();\n}\nfunction tsParseArrayTypeOrHigher() {\n  tsParseNonArrayType();\n  while (!hasPrecedingLineBreak() && eat(tt.bracketL)) {\n    if (!eat(tt.bracketR)) {\n      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.\n      tsParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\nfunction tsParseInferType() {\n  expectContextual(ContextualKeyword._infer);\n  parseIdentifier();\n  if (match(tt._extends)) {\n    // Infer type constraints introduce an ambiguity about whether the \"extends\"\n    // is a constraint for this infer type or is another conditional type.\n    const snapshot = state.snapshot();\n    expect(tt._extends);\n    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n    state.inDisallowConditionalTypesContext = true;\n    tsParseType();\n    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    if (state.error || !state.inDisallowConditionalTypesContext && match(tt.question)) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\nfunction tsParseTypeOperatorOrHigher() {\n  if (isContextual(ContextualKeyword._keyof) || isContextual(ContextualKeyword._unique) || isContextual(ContextualKeyword._readonly)) {\n    next();\n    tsParseTypeOperatorOrHigher();\n  } else if (isContextual(ContextualKeyword._infer)) {\n    tsParseInferType();\n  } else {\n    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n    state.inDisallowConditionalTypesContext = false;\n    tsParseArrayTypeOrHigher();\n    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n  }\n}\nfunction tsParseIntersectionTypeOrHigher() {\n  eat(tt.bitwiseAND);\n  tsParseTypeOperatorOrHigher();\n  if (match(tt.bitwiseAND)) {\n    while (eat(tt.bitwiseAND)) {\n      tsParseTypeOperatorOrHigher();\n    }\n  }\n}\nfunction tsParseUnionTypeOrHigher() {\n  eat(tt.bitwiseOR);\n  tsParseIntersectionTypeOrHigher();\n  if (match(tt.bitwiseOR)) {\n    while (eat(tt.bitwiseOR)) {\n      tsParseIntersectionTypeOrHigher();\n    }\n  }\n}\nfunction tsIsStartOfFunctionType() {\n  if (match(tt.lessThan)) {\n    return true;\n  }\n  return match(tt.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();\n}\nfunction tsSkipParameterStart() {\n  if (match(tt.name) || match(tt._this)) {\n    next();\n    return true;\n  }\n  // If this is a possible array/object destructure, walk to the matching bracket/brace.\n  // The next token after will tell us definitively whether this is a function param.\n  if (match(tt.braceL) || match(tt.bracketL)) {\n    let depth = 1;\n    next();\n    while (depth > 0 && !state.error) {\n      if (match(tt.braceL) || match(tt.bracketL)) {\n        depth++;\n      } else if (match(tt.braceR) || match(tt.bracketR)) {\n        depth--;\n      }\n      next();\n    }\n    return true;\n  }\n  return false;\n}\nfunction tsLookaheadIsUnambiguouslyStartOfFunctionType() {\n  const snapshot = state.snapshot();\n  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();\n  state.restoreFromSnapshot(snapshot);\n  return isUnambiguouslyStartOfFunctionType;\n}\nfunction tsIsUnambiguouslyStartOfFunctionType() {\n  next();\n  if (match(tt.parenR) || match(tt.ellipsis)) {\n    // ( )\n    // ( ...\n    return true;\n  }\n  if (tsSkipParameterStart()) {\n    if (match(tt.colon) || match(tt.comma) || match(tt.question) || match(tt.eq)) {\n      // ( xxx :\n      // ( xxx ,\n      // ( xxx ?\n      // ( xxx =\n      return true;\n    }\n    if (match(tt.parenR)) {\n      next();\n      if (match(tt.arrow)) {\n        // ( xxx ) =>\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction tsParseTypeOrTypePredicateAnnotation(returnToken) {\n  const oldIsType = pushTypeContext(0);\n  expect(returnToken);\n  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();\n  if (!finishedReturn) {\n    tsParseType();\n  }\n  popTypeContext(oldIsType);\n}\nfunction tsTryParseTypeOrTypePredicateAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n}\nexport function tsTryParseTypeAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\nfunction tsTryParseType() {\n  if (eat(tt.colon)) {\n    tsParseType();\n  }\n}\n\n/**\n * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,\n * `asserts this is T`.\n *\n * Returns true if we parsed the return type, false if there's still a type to be parsed.\n */\nfunction tsParseTypePredicateOrAssertsPrefix() {\n  const snapshot = state.snapshot();\n  if (isContextual(ContextualKeyword._asserts)) {\n    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-\n    // defined type guard on the `asserts` variable) or just a type called `asserts`.\n    next();\n    if (eatContextual(ContextualKeyword._is)) {\n      // If we see `asserts is`, then this must be of the form `asserts is T`, since\n      // `asserts is is T` isn't valid.\n      tsParseType();\n      return true;\n    } else if (tsIsIdentifier() || match(tt._this)) {\n      next();\n      if (eatContextual(ContextualKeyword._is)) {\n        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.\n        tsParseType();\n      }\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (tsIsIdentifier() || match(tt._this)) {\n    // This is a regular identifier, which may or may not have \"is\" after it.\n    next();\n    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n      next();\n      tsParseType();\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  }\n  return false;\n}\nexport function tsParseTypeAnnotation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  tsParseType();\n  popTypeContext(oldIsType);\n}\nexport function tsParseType() {\n  tsParseNonConditionalType();\n  if (state.inDisallowConditionalTypesContext || hasPrecedingLineBreak() || !eat(tt._extends)) {\n    return;\n  }\n  // extends type\n  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n  state.inDisallowConditionalTypesContext = true;\n  tsParseNonConditionalType();\n  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n  expect(tt.question);\n  // true type\n  tsParseType();\n  expect(tt.colon);\n  // false type\n  tsParseType();\n}\nfunction isAbstractConstructorSignature() {\n  return isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._new;\n}\nexport function tsParseNonConditionalType() {\n  if (tsIsStartOfFunctionType()) {\n    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);\n    return;\n  }\n  if (match(tt._new)) {\n    // As in `new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);\n    return;\n  } else if (isAbstractConstructorSignature()) {\n    // As in `abstract new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);\n    return;\n  }\n  tsParseUnionTypeOrHigher();\n}\nexport function tsParseTypeAssertion() {\n  const oldIsType = pushTypeContext(1);\n  tsParseType();\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n  parseMaybeUnary();\n}\nexport function tsTryParseJSXTypeArgument() {\n  if (eat(tt.jsxTagStart)) {\n    state.tokens[state.tokens.length - 1].type = tt.typeParameterStart;\n    const oldIsType = pushTypeContext(1);\n    while (!match(tt.greaterThan) && !state.error) {\n      tsParseType();\n      eat(tt.comma);\n    }\n    // Process >, but the one after needs to be parsed JSX-style.\n    nextJSXTagToken();\n    popTypeContext(oldIsType);\n  }\n}\nfunction tsParseHeritageClause() {\n  while (!match(tt.braceL) && !state.error) {\n    tsParseExpressionWithTypeArguments();\n    eat(tt.comma);\n  }\n}\nfunction tsParseExpressionWithTypeArguments() {\n  // Note: TS uses parseLeftHandSideExpressionOrHigher,\n  // then has grammar errors later if it's not an EntityName.\n  tsParseEntityName();\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\nfunction tsParseInterfaceDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  if (eat(tt._extends)) {\n    tsParseHeritageClause();\n  }\n  tsParseObjectTypeMembers();\n}\nfunction tsParseTypeAliasDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  expect(tt.eq);\n  tsParseType();\n  semicolon();\n}\nfunction tsParseEnumMember() {\n  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n  if (match(tt.string)) {\n    parseLiteral();\n  } else {\n    parseIdentifier();\n  }\n  if (eat(tt.eq)) {\n    const eqIndex = state.tokens.length - 1;\n    parseMaybeAssign();\n    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n  }\n}\nfunction tsParseEnumDeclaration() {\n  parseBindingIdentifier(false);\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseEnumMember();\n    eat(tt.comma);\n  }\n}\nfunction tsParseModuleBlock() {\n  expect(tt.braceL);\n  parseBlockBody( /* end */tt.braceR);\n}\nfunction tsParseModuleOrNamespaceDeclaration() {\n  parseBindingIdentifier(false);\n  if (eat(tt.dot)) {\n    tsParseModuleOrNamespaceDeclaration();\n  } else {\n    tsParseModuleBlock();\n  }\n}\nfunction tsParseAmbientExternalModuleDeclaration() {\n  if (isContextual(ContextualKeyword._global)) {\n    parseIdentifier();\n  } else if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    unexpected();\n  }\n  if (match(tt.braceL)) {\n    tsParseModuleBlock();\n  } else {\n    semicolon();\n  }\n}\nexport function tsParseImportEqualsDeclaration() {\n  parseImportedIdentifier();\n  expect(tt.eq);\n  tsParseModuleReference();\n  semicolon();\n}\nfunction tsIsExternalModuleReference() {\n  return isContextual(ContextualKeyword._require) && lookaheadType() === tt.parenL;\n}\nfunction tsParseModuleReference() {\n  if (tsIsExternalModuleReference()) {\n    tsParseExternalModuleReference();\n  } else {\n    tsParseEntityName();\n  }\n}\nfunction tsParseExternalModuleReference() {\n  expectContextual(ContextualKeyword._require);\n  expect(tt.parenL);\n  if (!match(tt.string)) {\n    unexpected();\n  }\n  parseLiteral();\n  expect(tt.parenR);\n}\n\n// Utilities\n\n// Returns true if a statement matched.\nfunction tsTryParseDeclare() {\n  if (isLineTerminator()) {\n    return false;\n  }\n  switch (state.type) {\n    case tt._function:\n      {\n        const oldIsType = pushTypeContext(1);\n        next();\n        // We don't need to precisely get the function start here, since it's only used to mark\n        // the function as a type if it's bodiless, and it's already a type here.\n        const functionStart = state.start;\n        parseFunction(functionStart, /* isStatement */true);\n        popTypeContext(oldIsType);\n        return true;\n      }\n    case tt._class:\n      {\n        const oldIsType = pushTypeContext(1);\n        parseClass( /* isStatement */true, /* optionalId */false);\n        popTypeContext(oldIsType);\n        return true;\n      }\n    case tt._const:\n      {\n        if (match(tt._const) && isLookaheadContextual(ContextualKeyword._enum)) {\n          const oldIsType = pushTypeContext(1);\n          // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n          expect(tt._const);\n          expectContextual(ContextualKeyword._enum);\n          state.tokens[state.tokens.length - 1].type = tt._enum;\n          tsParseEnumDeclaration();\n          popTypeContext(oldIsType);\n          return true;\n        }\n      }\n    // falls through\n    case tt._var:\n    case tt._let:\n      {\n        const oldIsType = pushTypeContext(1);\n        parseVarStatement(state.type !== tt._var);\n        popTypeContext(oldIsType);\n        return true;\n      }\n    case tt.name:\n      {\n        const oldIsType = pushTypeContext(1);\n        const contextualKeyword = state.contextualKeyword;\n        let matched = false;\n        if (contextualKeyword === ContextualKeyword._global) {\n          tsParseAmbientExternalModuleDeclaration();\n          matched = true;\n        } else {\n          matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */true);\n        }\n        popTypeContext(oldIsType);\n        return matched;\n      }\n    default:\n      return false;\n  }\n}\n\n// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n// Returns true if it matched a declaration.\nfunction tsTryParseExportDeclaration() {\n  return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */true);\n}\n\n// Returns true if it matched a statement.\nfunction tsParseExpressionStatement(contextualKeyword) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._declare:\n      {\n        const declareTokenIndex = state.tokens.length - 1;\n        const matched = tsTryParseDeclare();\n        if (matched) {\n          state.tokens[declareTokenIndex].type = tt._declare;\n          return true;\n        }\n        break;\n      }\n    case ContextualKeyword._global:\n      // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n      if (match(tt.braceL)) {\n        tsParseModuleBlock();\n        return true;\n      }\n      break;\n    default:\n      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */false);\n  }\n  return false;\n}\n\n/**\n * Common code for parsing a declaration.\n *\n * isBeforeToken indicates that the current parser state is at the contextual\n * keyword (and that it is not yet emitted) rather than reading the token after\n * it. When isBeforeToken is true, we may be preceded by an `export` token and\n * should include that token in a type context we create, e.g. to handle\n * `export interface` or `export type`. (This is a bit of a hack and should be\n * cleaned up at some point.)\n *\n * Returns true if it matched a declaration.\n */\nfunction tsParseDeclaration(contextualKeyword, isBeforeToken) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._abstract:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt._class)) {\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        parseClass( /* isStatement */true, /* optionalId */false);\n        return true;\n      }\n      break;\n    case ContextualKeyword._enum:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        return true;\n      }\n      break;\n    case ContextualKeyword._interface:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        // `next` is true in \"export\" and \"declare\" contexts, so we want to remove that token\n        // as well.\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseInterfaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n    case ContextualKeyword._module:\n      if (tsCheckLineTerminator(isBeforeToken)) {\n        if (match(tt.string)) {\n          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n          tsParseAmbientExternalModuleDeclaration();\n          popTypeContext(oldIsType);\n          return true;\n        } else if (match(tt.name)) {\n          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n          tsParseModuleOrNamespaceDeclaration();\n          popTypeContext(oldIsType);\n          return true;\n        }\n      }\n      break;\n    case ContextualKeyword._namespace:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseModuleOrNamespaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n    case ContextualKeyword._type:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseTypeAliasDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n    default:\n      break;\n  }\n  return false;\n}\nfunction tsCheckLineTerminator(isBeforeToken) {\n  if (isBeforeToken) {\n    // Babel checks hasFollowingLineBreak here and returns false, but this\n    // doesn't actually come up, e.g. `export interface` can never be on its own\n    // line in valid code.\n    next();\n    return true;\n  } else {\n    return !isLineTerminator();\n  }\n}\n\n// Returns true if there was a generic async arrow function.\nfunction tsTryParseGenericAsyncArrowFunction() {\n  const snapshot = state.snapshot();\n  tsParseTypeParameters();\n  parseFunctionParams();\n  tsTryParseTypeOrTypePredicateAnnotation();\n  expect(tt.arrow);\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n  parseFunctionBody(true);\n  return true;\n}\n\n/**\n * If necessary, hack the tokenizer state so that this bitshift was actually a\n * less-than token, then keep parsing. This should only be used in situations\n * where we restore from snapshot on error (which reverts this change) or\n * where bitshift would be illegal anyway (e.g. in a class \"extends\" clause).\n *\n * This hack is useful to handle situations like foo<<T>() => void>() where\n * there can legitimately be two open-angle-brackets in a row in TS.\n */\nfunction tsParseTypeArgumentsWithPossibleBitshift() {\n  if (state.type === tt.bitShiftL) {\n    state.pos -= 1;\n    finishToken(tt.lessThan);\n  }\n  tsParseTypeArguments();\n}\nfunction tsParseTypeArguments() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    tsParseType();\n    eat(tt.comma);\n  }\n  if (!oldIsType) {\n    // If the type arguments are present in an expression context, e.g.\n    // f<number>(), then the > sign should be tokenized as a non-type token.\n    // In particular, f(a < b, c >= d) should parse the >= as a single token,\n    // resulting in a syntax error and fallback to the non-type-args\n    // interpretation. In the success case, even though the > is tokenized as a\n    // non-type token, it still must be marked as a type token so that it is\n    // erased.\n    popTypeContext(oldIsType);\n    rescan_gt();\n    expect(tt.greaterThan);\n    state.tokens[state.tokens.length - 1].isType = true;\n  } else {\n    expect(tt.greaterThan);\n    popTypeContext(oldIsType);\n  }\n}\nexport function tsIsDeclarationStart() {\n  if (match(tt.name)) {\n    switch (state.contextualKeyword) {\n      case ContextualKeyword._abstract:\n      case ContextualKeyword._declare:\n      case ContextualKeyword._enum:\n      case ContextualKeyword._interface:\n      case ContextualKeyword._module:\n      case ContextualKeyword._namespace:\n      case ContextualKeyword._type:\n        return true;\n      default:\n        break;\n    }\n  }\n  return false;\n}\n\n// ======================================================\n// OVERRIDES\n// ======================================================\n\nexport function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n\n  // The original code checked the node type to make sure this function type allows a missing\n  // body, but we skip that to avoid sending around the node type. We instead just use the\n  // allowExpressionBody boolean to make sure it's not an arrow function.\n  if (!match(tt.braceL) && isLineTerminator()) {\n    // Retroactively mark the function declaration as a type.\n    let i = state.tokens.length - 1;\n    while (i >= 0 && (state.tokens[i].start >= functionStart || state.tokens[i].type === tt._default || state.tokens[i].type === tt._export)) {\n      state.tokens[i].isType = true;\n      i--;\n    }\n    return;\n  }\n  parseFunctionBody(false, funcContextId);\n}\nexport function tsParseSubscript(startTokenIndex, noCalls, stopState) {\n  if (!hasPrecedingLineBreak() && eat(tt.bang)) {\n    state.tokens[state.tokens.length - 1].type = tt.nonNullAssertion;\n    return;\n  }\n  if (match(tt.lessThan) || match(tt.bitShiftL)) {\n    // There are number of things we are going to \"maybe\" parse, like type arguments on\n    // tagged template expressions. If any of them fail, walk it back and continue.\n    const snapshot = state.snapshot();\n    if (!noCalls && atPossibleAsync()) {\n      // Almost certainly this is a generic async function `async <T>() => ...\n      // But it might be a call with a type argument `async<T>();`\n      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();\n      if (asyncArrowFn) {\n        return;\n      }\n    }\n    tsParseTypeArgumentsWithPossibleBitshift();\n    if (!noCalls && eat(tt.parenL)) {\n      // With f<T>(), the subscriptStartIndex marker is on the ( token.\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      parseCallExpressionArguments();\n    } else if (match(tt.backQuote)) {\n      // Tagged template with a type argument.\n      parseTemplate();\n    } else if (\n    // The remaining possible case is an instantiation expression, e.g.\n    // Array<number> . Check for a few cases that would disqualify it and\n    // cause us to bail out.\n    // a<b>>c is not (a<b>)>c, but a<(b>>c)\n    state.type === tt.greaterThan ||\n    // a<b>c is (a<b)>c\n    state.type !== tt.parenL && Boolean(state.type & TokenType.IS_EXPRESSION_START) && !hasPrecedingLineBreak()) {\n      // Bail out. We have something like a<b>c, which is not an expression with\n      // type arguments but an (a < b) > c comparison.\n      unexpected();\n    }\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  } else if (!noCalls && match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    // If we see f?.<, then this must be an optional call with a type argument.\n    next();\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    tsParseTypeArguments();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\nexport function tsTryParseExport() {\n  if (eat(tt._import)) {\n    // One of these cases:\n    // export import A = B;\n    // export import type A = require(\"A\");\n    if (isContextual(ContextualKeyword._type) && lookaheadType() !== tt.eq) {\n      // Eat a `type` token, unless it's actually an identifier name.\n      expectContextual(ContextualKeyword._type);\n    }\n    tsParseImportEqualsDeclaration();\n    return true;\n  } else if (eat(tt.eq)) {\n    // `export = x;`\n    parseExpression();\n    semicolon();\n    return true;\n  } else if (eatContextual(ContextualKeyword._as)) {\n    // `export as namespace A;`\n    // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n    expectContextual(ContextualKeyword._namespace);\n    parseIdentifier();\n    semicolon();\n    return true;\n  } else {\n    if (isContextual(ContextualKeyword._type)) {\n      const nextType = lookaheadType();\n      // export type {foo} from 'a';\n      // export type * from 'a';'\n      // export type * as ns from 'a';'\n      if (nextType === tt.braceL || nextType === tt.star) {\n        next();\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Parse a TS import specifier, which may be prefixed with \"type\" and may be of\n * the form `foo as bar`.\n *\n * The number of identifier-like tokens we see happens to be enough to uniquely\n * identify the form, so simply count the number of identifiers rather than\n * matching the words `type` or `as`. This is particularly important because\n * `type` and `as` could each actually be plain identifiers rather than\n * keywords.\n */\nexport function tsParseImportSpecifier() {\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {type foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    state.tokens[state.tokens.length - 2].isType = true;\n    state.tokens[state.tokens.length - 1].isType = true;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {foo as bar}\n    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    return;\n  }\n  parseIdentifier();\n  // import {type foo as bar}\n  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n  state.tokens[state.tokens.length - 4].isType = true;\n  state.tokens[state.tokens.length - 3].isType = true;\n  state.tokens[state.tokens.length - 2].isType = true;\n  state.tokens[state.tokens.length - 1].isType = true;\n}\n\n/**\n * Just like named import specifiers, export specifiers can have from 1 to 4\n * tokens, inclusive, and the number of tokens determines the role of each token.\n */\nexport function tsParseExportSpecifier() {\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {type foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    state.tokens[state.tokens.length - 2].isType = true;\n    state.tokens[state.tokens.length - 1].isType = true;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {foo as bar}\n    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;\n    return;\n  }\n  parseIdentifier();\n  // export {type foo as bar}\n  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;\n  state.tokens[state.tokens.length - 4].isType = true;\n  state.tokens[state.tokens.length - 3].isType = true;\n  state.tokens[state.tokens.length - 2].isType = true;\n  state.tokens[state.tokens.length - 1].isType = true;\n}\nexport function tsTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._class) {\n    state.type = tt._abstract;\n    next(); // Skip \"abstract\"\n    parseClass(true, true);\n    return true;\n  }\n  if (isContextual(ContextualKeyword._interface)) {\n    // Make sure \"export default\" are considered type tokens so the whole thing is removed.\n    const oldIsType = pushTypeContext(2);\n    tsParseDeclaration(ContextualKeyword._interface, true);\n    popTypeContext(oldIsType);\n    return true;\n  }\n  return false;\n}\nexport function tsTryParseStatementContent() {\n  if (state.type === tt._const) {\n    const ahead = lookaheadTypeAndKeyword();\n    if (ahead.type === tt.name && ahead.contextualKeyword === ContextualKeyword._enum) {\n      expect(tt._const);\n      expectContextual(ContextualKeyword._enum);\n      state.tokens[state.tokens.length - 1].type = tt._enum;\n      tsParseEnumDeclaration();\n      return true;\n    }\n  }\n  return false;\n}\nexport function tsTryParseClassMemberWithIsStatic(isStatic) {\n  const memberStartIndexAfterStatic = state.tokens.length;\n  tsParseModifiers([ContextualKeyword._abstract, ContextualKeyword._readonly, ContextualKeyword._declare, ContextualKeyword._static, ContextualKeyword._override]);\n  const modifiersEndIndex = state.tokens.length;\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    // Index signatures are type declarations, so set the modifier tokens as\n    // type tokens. Most tokens could be assumed to be type tokens, but `static`\n    // is ambiguous unless we set it explicitly here.\n    const memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;\n    for (let i = memberStartIndex; i < modifiersEndIndex; i++) {\n      state.tokens[i].isType = true;\n    }\n    return true;\n  }\n  return false;\n}\n\n// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`\n// is that e.g. `type()` is valid JS, so we must try parsing that first.\n// If it's really a type, we will parse `type` as the statement, and can correct it here\n// by parsing the rest.\nexport function tsParseIdentifierStatement(contextualKeyword) {\n  const matched = tsParseExpressionStatement(contextualKeyword);\n  if (!matched) {\n    semicolon();\n  }\n}\nexport function tsParseExportDeclaration() {\n  // \"export declare\" is equivalent to just \"export\".\n  const isDeclare = eatContextual(ContextualKeyword._declare);\n  if (isDeclare) {\n    state.tokens[state.tokens.length - 1].type = tt._declare;\n  }\n  let matchedDeclaration = false;\n  if (match(tt.name)) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      matchedDeclaration = tsTryParseExportDeclaration();\n      popTypeContext(oldIsType);\n    } else {\n      matchedDeclaration = tsTryParseExportDeclaration();\n    }\n  }\n  if (!matchedDeclaration) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      parseStatement(true);\n      popTypeContext(oldIsType);\n    } else {\n      parseStatement(true);\n    }\n  }\n}\nexport function tsAfterParseClassSuper(hasSuper) {\n  if (hasSuper && (match(tt.lessThan) || match(tt.bitShiftL))) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  if (eatContextual(ContextualKeyword._implements)) {\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    const oldIsType = pushTypeContext(1);\n    tsParseHeritageClause();\n    popTypeContext(oldIsType);\n  }\n}\nexport function tsStartParseObjPropValue() {\n  tsTryParseTypeParameters();\n}\nexport function tsStartParseFunctionParams() {\n  tsTryParseTypeParameters();\n}\n\n// `let x: number;`\nexport function tsAfterParseVarHead() {\n  const oldIsType = pushTypeContext(0);\n  if (!hasPrecedingLineBreak()) {\n    eat(tt.bang);\n  }\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function tsStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\n// Returns true if the expression was an arrow function.\nexport function tsParseMaybeAssign(noIn, isWithinParens) {\n  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n  if (isJSXEnabled) {\n    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);\n  } else {\n    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);\n  }\n}\nexport function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  // Prefer to parse JSX if possible. But may be an arrow fn.\n  const snapshot = state.snapshot();\n  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Otherwise, try as type-parameterized arrow function.\n  state.type = tt.typeParameterStart;\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n  return wasArrow;\n}\nexport function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n  const snapshot = state.snapshot();\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Try parsing a type cast instead of an arrow function.\n  // This will start with a type assertion (via parseMaybeUnary).\n  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\nexport function tsParseArrow() {\n  if (match(tt.colon)) {\n    // This is different from how the TS parser does it.\n    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.\n    const snapshot = state.snapshot();\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n  return eat(tt.arrow);\n}\n\n// Allow type annotations inside of a parameter list.\nexport function tsParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\nexport function tsParseMaybeDecoratorArguments() {\n  if (match(tt.lessThan) || match(tt.bitShiftL)) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  baseParseMaybeDecoratorArguments();\n}","map":{"version":3,"names":["eat","finishToken","IdentifierRole","lookaheadType","lookaheadTypeAndKeyword","match","next","nextTemplateToken","popTypeContext","pushTypeContext","rescan_gt","ContextualKeyword","TokenType","tt","isJSXEnabled","state","atPossibleAsync","baseParseMaybeAssign","baseParseSubscript","parseCallExpressionArguments","parseExprAtom","parseExpression","parseFunctionBody","parseIdentifier","parseLiteral","parseMaybeAssign","parseMaybeUnary","parsePropertyName","parseTemplate","parseBindingIdentifier","parseBindingList","parseImportedIdentifier","baseParseMaybeDecoratorArguments","parseBlockBody","parseClass","parseFunction","parseFunctionParams","parseStatement","parseVarStatement","canInsertSemicolon","eatContextual","expect","expectContextual","hasPrecedingLineBreak","isContextual","isLineTerminator","isLookaheadContextual","semicolon","unexpected","nextJSXTagToken","tsIsIdentifier","name","isLiteralPropertyName","Boolean","type","IS_KEYWORD","string","num","bigint","decimal","tsNextTokenCanFollowModifier","snapshot","canFollowModifier","bracketL","braceL","star","ellipsis","hash","restoreFromSnapshot","tsParseModifiers","allowedModifiers","modifier","tsParseModifier","contextualKeyword","indexOf","_readonly","tokens","length","_abstract","_static","_public","_private","_protected","_override","_declare","tsParseEntityName","dot","tsParseTypeReference","lessThan","tsParseTypeArguments","tsParseThisTypePredicate","tsParseTypeAnnotation","tsParseThisTypeNode","tsParseTypeQuery","_typeof","_import","tsParseImportType","parenL","parenR","tsParseTypeParameter","_const","hadIn","_in","hadOut","_out","_extends","tsParseType","eq","tsTryParseTypeParameters","tsParseTypeParameters","oldIsType","typeParameterStart","greaterThan","error","comma","tsFillSignature","returnToken","returnTokenRequired","arrow","scopeDepth","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","isBlockScope","tsParseTypeMemberSemicolon","tsParseSignatureMember","colon","tsIsUnambiguouslyIndexSignature","isIndexSignature","tsTryParseIndexSignature","bracketR","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","isReadonly","question","tsParseTypeMember","_new","readonly","found","_get","_set","tsParseTypeLiteral","tsParseObjectTypeMembers","braceR","tsLookaheadIsStartOfMappedType","isStartOfMappedType","tsIsStartOfMappedType","plus","minus","tsParseMappedTypeParameter","tsParseMappedType","_as","tsTryParseType","tsParseTupleType","tsParseTupleElementType","tsParseParenthesizedType","tsParseTemplateLiteralType","backQuote","dollarBraceL","FunctionType","TSFunctionType","TSConstructorType","TSAbstractConstructorType","tsParseFunctionOrConstructorType","oldInDisallowConditionalTypesContext","inDisallowConditionalTypesContext","tsParseNonArrayType","_void","_null","_true","_false","_this","_is","tsParseArrayTypeOrHigher","tsParseInferType","_infer","tsParseTypeOperatorOrHigher","_keyof","_unique","tsParseIntersectionTypeOrHigher","bitwiseAND","tsParseUnionTypeOrHigher","bitwiseOR","tsIsStartOfFunctionType","tsLookaheadIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","depth","isUnambiguouslyStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","finishedReturn","tsParseTypePredicateOrAssertsPrefix","tsTryParseTypeOrTypePredicateAnnotation","_asserts","tsParseNonConditionalType","isAbstractConstructorSignature","tsParseTypeAssertion","tsTryParseJSXTypeArgument","jsxTagStart","tsParseHeritageClause","tsParseExpressionWithTypeArguments","tsParseInterfaceDeclaration","tsParseTypeAliasDeclaration","tsParseEnumMember","eqIndex","rhsEndIndex","tsParseEnumDeclaration","tsParseModuleBlock","tsParseModuleOrNamespaceDeclaration","tsParseAmbientExternalModuleDeclaration","_global","tsParseImportEqualsDeclaration","tsParseModuleReference","tsIsExternalModuleReference","_require","tsParseExternalModuleReference","tsTryParseDeclare","_function","functionStart","start","_class","_enum","_var","_let","matched","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","declareTokenIndex","isBeforeToken","tsCheckLineTerminator","_interface","_module","_namespace","_type","tsTryParseGenericAsyncArrowFunction","tsParseTypeArgumentsWithPossibleBitshift","bitShiftL","pos","isType","tsIsDeclarationStart","tsParseFunctionBodyAndFinish","funcContextId","i","_default","_export","tsParseSubscript","startTokenIndex","noCalls","stopState","bang","nonNullAssertion","asyncArrowFn","subscriptStartIndex","IS_EXPRESSION_START","questionDot","isOptionalChainStart","tsTryParseExport","nextType","tsParseImportSpecifier","identifierRole","ImportDeclaration","ImportAccess","tsParseExportSpecifier","ExportAccess","tsTryParseExportDefaultExpression","tsTryParseStatementContent","ahead","tsTryParseClassMemberWithIsStatic","isStatic","memberStartIndexAfterStatic","modifiersEndIndex","memberStartIndex","tsParseIdentifierStatement","tsParseExportDeclaration","isDeclare","matchedDeclaration","tsAfterParseClassSuper","hasSuper","_implements","tsStartParseObjPropValue","tsStartParseFunctionParams","tsAfterParseVarHead","tsStartParseAsyncArrowFromCallExpression","tsParseMaybeAssign","noIn","isWithinParens","tsParseMaybeAssignWithJSX","tsParseMaybeAssignWithoutJSX","wasArrow","tsParseArrow","tsParseAssignableListItemTypes","tsParseMaybeDecoratorArguments"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/sucrase/dist/esm/parser/plugins/typescript.js"],"sourcesContent":["import {\n  eat,\n  finishToken,\n  IdentifierRole,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  nextTemplateToken,\n  popTypeContext,\n  pushTypeContext,\n  rescan_gt,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isJSXEnabled, state} from \"../traverser/base\";\nimport {\n  atPossibleAsync,\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n  parseMaybeAssign,\n  parseMaybeUnary,\n  parsePropertyName,\n  parseTemplate,\n\n} from \"../traverser/expression\";\nimport {parseBindingIdentifier, parseBindingList, parseImportedIdentifier} from \"../traverser/lval\";\nimport {\n  baseParseMaybeDecoratorArguments,\n  parseBlockBody,\n  parseClass,\n  parseFunction,\n  parseFunctionParams,\n  parseStatement,\n  parseVarStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasPrecedingLineBreak,\n  isContextual,\n  isLineTerminator,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\nimport {nextJSXTagToken} from \"./jsx\";\n\nfunction tsIsIdentifier() {\n  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n  // See https://github.com/Microsoft/TypeScript/issues/15008\n  return match(tt.name);\n}\n\nfunction isLiteralPropertyName() {\n  return (\n    match(tt.name) ||\n    Boolean(state.type & TokenType.IS_KEYWORD) ||\n    match(tt.string) ||\n    match(tt.num) ||\n    match(tt.bigint) ||\n    match(tt.decimal)\n  );\n}\n\nfunction tsNextTokenCanFollowModifier() {\n  // Note: TypeScript's implementation is much more complicated because\n  // more things are considered modifiers there.\n  // This implementation only handles modifiers not handled by babylon itself. And \"static\".\n  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n  const snapshot = state.snapshot();\n\n  next();\n  const canFollowModifier =\n    (match(tt.bracketL) ||\n      match(tt.braceL) ||\n      match(tt.star) ||\n      match(tt.ellipsis) ||\n      match(tt.hash) ||\n      isLiteralPropertyName()) &&\n    !hasPrecedingLineBreak();\n\n  if (canFollowModifier) {\n    return true;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n}\n\nexport function tsParseModifiers(allowedModifiers) {\n  while (true) {\n    const modifier = tsParseModifier(allowedModifiers);\n    if (modifier === null) {\n      break;\n    }\n  }\n}\n\n/** Parses a modifier matching one the given modifier names. */\nexport function tsParseModifier(\n  allowedModifiers,\n) {\n  if (!match(tt.name)) {\n    return null;\n  }\n\n  const modifier = state.contextualKeyword;\n  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {\n    switch (modifier) {\n      case ContextualKeyword._readonly:\n        state.tokens[state.tokens.length - 1].type = tt._readonly;\n        break;\n      case ContextualKeyword._abstract:\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        break;\n      case ContextualKeyword._static:\n        state.tokens[state.tokens.length - 1].type = tt._static;\n        break;\n      case ContextualKeyword._public:\n        state.tokens[state.tokens.length - 1].type = tt._public;\n        break;\n      case ContextualKeyword._private:\n        state.tokens[state.tokens.length - 1].type = tt._private;\n        break;\n      case ContextualKeyword._protected:\n        state.tokens[state.tokens.length - 1].type = tt._protected;\n        break;\n      case ContextualKeyword._override:\n        state.tokens[state.tokens.length - 1].type = tt._override;\n        break;\n      case ContextualKeyword._declare:\n        state.tokens[state.tokens.length - 1].type = tt._declare;\n        break;\n      default:\n        break;\n    }\n    return modifier;\n  }\n  return null;\n}\n\nfunction tsParseEntityName() {\n  parseIdentifier();\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction tsParseTypeReference() {\n  tsParseEntityName();\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseThisTypePredicate() {\n  next();\n  tsParseTypeAnnotation();\n}\n\nfunction tsParseThisTypeNode() {\n  next();\n}\n\nfunction tsParseTypeQuery() {\n  expect(tt._typeof);\n  if (match(tt._import)) {\n    tsParseImportType();\n  } else {\n    tsParseEntityName();\n  }\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseImportType() {\n  expect(tt._import);\n  expect(tt.parenL);\n  expect(tt.string);\n  expect(tt.parenR);\n  if (eat(tt.dot)) {\n    tsParseEntityName();\n  }\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseTypeParameter() {\n  eat(tt._const);\n  const hadIn = eat(tt._in);\n  const hadOut = eatContextual(ContextualKeyword._out);\n  eat(tt._const);\n  if ((hadIn || hadOut) && !match(tt.name)) {\n    // The \"in\" or \"out\" keyword must have actually been the type parameter\n    // name, so set it as the name.\n    state.tokens[state.tokens.length - 1].type = tt.name;\n  } else {\n    parseIdentifier();\n  }\n\n  if (eat(tt._extends)) {\n    tsParseType();\n  }\n  if (eat(tt.eq)) {\n    tsParseType();\n  }\n}\n\nexport function tsTryParseTypeParameters() {\n  if (match(tt.lessThan)) {\n    tsParseTypeParameters();\n  }\n}\n\nfunction tsParseTypeParameters() {\n  const oldIsType = pushTypeContext(0);\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  while (!eat(tt.greaterThan) && !state.error) {\n    tsParseTypeParameter();\n    eat(tt.comma);\n  }\n  popTypeContext(oldIsType);\n}\n\n// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n// but here it's always false, because this is only used for types.\nfunction tsFillSignature(returnToken) {\n  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n  const returnTokenRequired = returnToken === tt.arrow;\n  tsTryParseTypeParameters();\n  expect(tt.parenL);\n  // Create a scope even though we're doing type parsing so we don't accidentally\n  // treat params as top-level bindings.\n  state.scopeDepth++;\n  tsParseBindingListForSignature(false /* isBlockScope */);\n  state.scopeDepth--;\n  if (returnTokenRequired) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  } else if (match(returnToken)) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  }\n}\n\nfunction tsParseBindingListForSignature(isBlockScope) {\n  parseBindingList(tt.parenR, isBlockScope);\n}\n\nfunction tsParseTypeMemberSemicolon() {\n  if (!eat(tt.comma)) {\n    semicolon();\n  }\n}\n\nfunction tsParseSignatureMember() {\n  tsFillSignature(tt.colon);\n  tsParseTypeMemberSemicolon();\n}\n\nfunction tsIsUnambiguouslyIndexSignature() {\n  const snapshot = state.snapshot();\n  next(); // Skip '{'\n  const isIndexSignature = eat(tt.name) && match(tt.colon);\n  state.restoreFromSnapshot(snapshot);\n  return isIndexSignature;\n}\n\nfunction tsTryParseIndexSignature() {\n  if (!(match(tt.bracketL) && tsIsUnambiguouslyIndexSignature())) {\n    return false;\n  }\n\n  const oldIsType = pushTypeContext(0);\n\n  expect(tt.bracketL);\n  parseIdentifier();\n  tsParseTypeAnnotation();\n  expect(tt.bracketR);\n\n  tsTryParseTypeAnnotation();\n  tsParseTypeMemberSemicolon();\n\n  popTypeContext(oldIsType);\n  return true;\n}\n\nfunction tsParsePropertyOrMethodSignature(isReadonly) {\n  eat(tt.question);\n\n  if (!isReadonly && (match(tt.parenL) || match(tt.lessThan))) {\n    tsFillSignature(tt.colon);\n    tsParseTypeMemberSemicolon();\n  } else {\n    tsTryParseTypeAnnotation();\n    tsParseTypeMemberSemicolon();\n  }\n}\n\nfunction tsParseTypeMember() {\n  if (match(tt.parenL) || match(tt.lessThan)) {\n    // call signature\n    tsParseSignatureMember();\n    return;\n  }\n  if (match(tt._new)) {\n    next();\n    if (match(tt.parenL) || match(tt.lessThan)) {\n      // constructor signature\n      tsParseSignatureMember();\n    } else {\n      tsParsePropertyOrMethodSignature(false);\n    }\n    return;\n  }\n  const readonly = !!tsParseModifier([ContextualKeyword._readonly]);\n\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    return;\n  }\n  if (\n    (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) &&\n    tsNextTokenCanFollowModifier()\n  ) {\n    // This is a getter/setter on a type. The tsNextTokenCanFollowModifier\n    // function already called next() for us, so continue parsing the name.\n  }\n  parsePropertyName(-1 /* Types don't need context IDs. */);\n  tsParsePropertyOrMethodSignature(readonly);\n}\n\nfunction tsParseTypeLiteral() {\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseObjectTypeMembers() {\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseTypeMember();\n  }\n}\n\nfunction tsLookaheadIsStartOfMappedType() {\n  const snapshot = state.snapshot();\n  const isStartOfMappedType = tsIsStartOfMappedType();\n  state.restoreFromSnapshot(snapshot);\n  return isStartOfMappedType;\n}\n\nfunction tsIsStartOfMappedType() {\n  next();\n  if (eat(tt.plus) || eat(tt.minus)) {\n    return isContextual(ContextualKeyword._readonly);\n  }\n  if (isContextual(ContextualKeyword._readonly)) {\n    next();\n  }\n  if (!match(tt.bracketL)) {\n    return false;\n  }\n  next();\n  if (!tsIsIdentifier()) {\n    return false;\n  }\n  next();\n  return match(tt._in);\n}\n\nfunction tsParseMappedTypeParameter() {\n  parseIdentifier();\n  expect(tt._in);\n  tsParseType();\n}\n\nfunction tsParseMappedType() {\n  expect(tt.braceL);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expectContextual(ContextualKeyword._readonly);\n  } else {\n    eatContextual(ContextualKeyword._readonly);\n  }\n  expect(tt.bracketL);\n  tsParseMappedTypeParameter();\n  if (eatContextual(ContextualKeyword._as)) {\n    tsParseType();\n  }\n  expect(tt.bracketR);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expect(tt.question);\n  } else {\n    eat(tt.question);\n  }\n  tsTryParseType();\n  semicolon();\n  expect(tt.braceR);\n}\n\nfunction tsParseTupleType() {\n  expect(tt.bracketL);\n  while (!eat(tt.bracketR) && !state.error) {\n    // Do not validate presence of either none or only labeled elements\n    tsParseTupleElementType();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseTupleElementType() {\n  // parses `...TsType[]`\n  if (eat(tt.ellipsis)) {\n    tsParseType();\n  } else {\n    // parses `TsType?`\n    tsParseType();\n    eat(tt.question);\n  }\n\n  // The type we parsed above was actually a label\n  if (eat(tt.colon)) {\n    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here\n    tsParseType();\n  }\n}\n\nfunction tsParseParenthesizedType() {\n  expect(tt.parenL);\n  tsParseType();\n  expect(tt.parenR);\n}\n\nfunction tsParseTemplateLiteralType() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    tsParseType();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\nvar FunctionType; (function (FunctionType) {\n  const TSFunctionType = 0; FunctionType[FunctionType[\"TSFunctionType\"] = TSFunctionType] = \"TSFunctionType\";\n  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType[\"TSConstructorType\"] = TSConstructorType] = \"TSConstructorType\";\n  const TSAbstractConstructorType = TSConstructorType + 1; FunctionType[FunctionType[\"TSAbstractConstructorType\"] = TSAbstractConstructorType] = \"TSAbstractConstructorType\";\n})(FunctionType || (FunctionType = {}));\n\nfunction tsParseFunctionOrConstructorType(type) {\n  if (type === FunctionType.TSAbstractConstructorType) {\n    expectContextual(ContextualKeyword._abstract);\n  }\n  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {\n    expect(tt._new);\n  }\n  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n  state.inDisallowConditionalTypesContext = false;\n  tsFillSignature(tt.arrow);\n  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n}\n\nfunction tsParseNonArrayType() {\n  switch (state.type) {\n    case tt.name:\n      tsParseTypeReference();\n      return;\n    case tt._void:\n    case tt._null:\n      next();\n      return;\n    case tt.string:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt._true:\n    case tt._false:\n      parseLiteral();\n      return;\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n    case tt._this: {\n      tsParseThisTypeNode();\n      if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n        tsParseThisTypePredicate();\n      }\n      return;\n    }\n    case tt._typeof:\n      tsParseTypeQuery();\n      return;\n    case tt._import:\n      tsParseImportType();\n      return;\n    case tt.braceL:\n      if (tsLookaheadIsStartOfMappedType()) {\n        tsParseMappedType();\n      } else {\n        tsParseTypeLiteral();\n      }\n      return;\n    case tt.bracketL:\n      tsParseTupleType();\n      return;\n    case tt.parenL:\n      tsParseParenthesizedType();\n      return;\n    case tt.backQuote:\n      tsParseTemplateLiteralType();\n      return;\n    default:\n      if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n      break;\n  }\n\n  unexpected();\n}\n\nfunction tsParseArrayTypeOrHigher() {\n  tsParseNonArrayType();\n  while (!hasPrecedingLineBreak() && eat(tt.bracketL)) {\n    if (!eat(tt.bracketR)) {\n      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.\n      tsParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\n\nfunction tsParseInferType() {\n  expectContextual(ContextualKeyword._infer);\n  parseIdentifier();\n  if (match(tt._extends)) {\n    // Infer type constraints introduce an ambiguity about whether the \"extends\"\n    // is a constraint for this infer type or is another conditional type.\n    const snapshot = state.snapshot();\n    expect(tt._extends);\n    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n    state.inDisallowConditionalTypesContext = true;\n    tsParseType();\n    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    if (state.error || (!state.inDisallowConditionalTypesContext && match(tt.question))) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\nfunction tsParseTypeOperatorOrHigher() {\n  if (\n    isContextual(ContextualKeyword._keyof) ||\n    isContextual(ContextualKeyword._unique) ||\n    isContextual(ContextualKeyword._readonly)\n  ) {\n    next();\n    tsParseTypeOperatorOrHigher();\n  } else if (isContextual(ContextualKeyword._infer)) {\n    tsParseInferType();\n  } else {\n    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n    state.inDisallowConditionalTypesContext = false;\n    tsParseArrayTypeOrHigher();\n    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n  }\n}\n\nfunction tsParseIntersectionTypeOrHigher() {\n  eat(tt.bitwiseAND);\n  tsParseTypeOperatorOrHigher();\n  if (match(tt.bitwiseAND)) {\n    while (eat(tt.bitwiseAND)) {\n      tsParseTypeOperatorOrHigher();\n    }\n  }\n}\n\nfunction tsParseUnionTypeOrHigher() {\n  eat(tt.bitwiseOR);\n  tsParseIntersectionTypeOrHigher();\n  if (match(tt.bitwiseOR)) {\n    while (eat(tt.bitwiseOR)) {\n      tsParseIntersectionTypeOrHigher();\n    }\n  }\n}\n\nfunction tsIsStartOfFunctionType() {\n  if (match(tt.lessThan)) {\n    return true;\n  }\n  return match(tt.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();\n}\n\nfunction tsSkipParameterStart() {\n  if (match(tt.name) || match(tt._this)) {\n    next();\n    return true;\n  }\n  // If this is a possible array/object destructure, walk to the matching bracket/brace.\n  // The next token after will tell us definitively whether this is a function param.\n  if (match(tt.braceL) || match(tt.bracketL)) {\n    let depth = 1;\n    next();\n    while (depth > 0 && !state.error) {\n      if (match(tt.braceL) || match(tt.bracketL)) {\n        depth++;\n      } else if (match(tt.braceR) || match(tt.bracketR)) {\n        depth--;\n      }\n      next();\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction tsLookaheadIsUnambiguouslyStartOfFunctionType() {\n  const snapshot = state.snapshot();\n  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();\n  state.restoreFromSnapshot(snapshot);\n  return isUnambiguouslyStartOfFunctionType;\n}\n\nfunction tsIsUnambiguouslyStartOfFunctionType() {\n  next();\n  if (match(tt.parenR) || match(tt.ellipsis)) {\n    // ( )\n    // ( ...\n    return true;\n  }\n  if (tsSkipParameterStart()) {\n    if (match(tt.colon) || match(tt.comma) || match(tt.question) || match(tt.eq)) {\n      // ( xxx :\n      // ( xxx ,\n      // ( xxx ?\n      // ( xxx =\n      return true;\n    }\n    if (match(tt.parenR)) {\n      next();\n      if (match(tt.arrow)) {\n        // ( xxx ) =>\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction tsParseTypeOrTypePredicateAnnotation(returnToken) {\n  const oldIsType = pushTypeContext(0);\n  expect(returnToken);\n  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();\n  if (!finishedReturn) {\n    tsParseType();\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction tsTryParseTypeOrTypePredicateAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n}\n\nexport function tsTryParseTypeAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\nfunction tsTryParseType() {\n  if (eat(tt.colon)) {\n    tsParseType();\n  }\n}\n\n/**\n * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,\n * `asserts this is T`.\n *\n * Returns true if we parsed the return type, false if there's still a type to be parsed.\n */\nfunction tsParseTypePredicateOrAssertsPrefix() {\n  const snapshot = state.snapshot();\n  if (isContextual(ContextualKeyword._asserts)) {\n    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-\n    // defined type guard on the `asserts` variable) or just a type called `asserts`.\n    next();\n    if (eatContextual(ContextualKeyword._is)) {\n      // If we see `asserts is`, then this must be of the form `asserts is T`, since\n      // `asserts is is T` isn't valid.\n      tsParseType();\n      return true;\n    } else if (tsIsIdentifier() || match(tt._this)) {\n      next();\n      if (eatContextual(ContextualKeyword._is)) {\n        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.\n        tsParseType();\n      }\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (tsIsIdentifier() || match(tt._this)) {\n    // This is a regular identifier, which may or may not have \"is\" after it.\n    next();\n    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n      next();\n      tsParseType();\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function tsParseTypeAnnotation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  tsParseType();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseType() {\n  tsParseNonConditionalType();\n  if (state.inDisallowConditionalTypesContext || hasPrecedingLineBreak() || !eat(tt._extends)) {\n    return;\n  }\n  // extends type\n  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n  state.inDisallowConditionalTypesContext = true;\n  tsParseNonConditionalType();\n  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n\n  expect(tt.question);\n  // true type\n  tsParseType();\n  expect(tt.colon);\n  // false type\n  tsParseType();\n}\n\nfunction isAbstractConstructorSignature() {\n  return isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._new;\n}\n\nexport function tsParseNonConditionalType() {\n  if (tsIsStartOfFunctionType()) {\n    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);\n    return;\n  }\n  if (match(tt._new)) {\n    // As in `new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);\n    return;\n  } else if (isAbstractConstructorSignature()) {\n    // As in `abstract new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);\n    return;\n  }\n  tsParseUnionTypeOrHigher();\n}\n\nexport function tsParseTypeAssertion() {\n  const oldIsType = pushTypeContext(1);\n  tsParseType();\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n  parseMaybeUnary();\n}\n\nexport function tsTryParseJSXTypeArgument() {\n  if (eat(tt.jsxTagStart)) {\n    state.tokens[state.tokens.length - 1].type = tt.typeParameterStart;\n    const oldIsType = pushTypeContext(1);\n    while (!match(tt.greaterThan) && !state.error) {\n      tsParseType();\n      eat(tt.comma);\n    }\n    // Process >, but the one after needs to be parsed JSX-style.\n    nextJSXTagToken();\n    popTypeContext(oldIsType);\n  }\n}\n\nfunction tsParseHeritageClause() {\n  while (!match(tt.braceL) && !state.error) {\n    tsParseExpressionWithTypeArguments();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseExpressionWithTypeArguments() {\n  // Note: TS uses parseLeftHandSideExpressionOrHigher,\n  // then has grammar errors later if it's not an EntityName.\n  tsParseEntityName();\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseInterfaceDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  if (eat(tt._extends)) {\n    tsParseHeritageClause();\n  }\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseTypeAliasDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  expect(tt.eq);\n  tsParseType();\n  semicolon();\n}\n\nfunction tsParseEnumMember() {\n  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n  if (match(tt.string)) {\n    parseLiteral();\n  } else {\n    parseIdentifier();\n  }\n  if (eat(tt.eq)) {\n    const eqIndex = state.tokens.length - 1;\n    parseMaybeAssign();\n    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n  }\n}\n\nfunction tsParseEnumDeclaration() {\n  parseBindingIdentifier(false);\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseEnumMember();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseModuleBlock() {\n  expect(tt.braceL);\n  parseBlockBody(/* end */ tt.braceR);\n}\n\nfunction tsParseModuleOrNamespaceDeclaration() {\n  parseBindingIdentifier(false);\n  if (eat(tt.dot)) {\n    tsParseModuleOrNamespaceDeclaration();\n  } else {\n    tsParseModuleBlock();\n  }\n}\n\nfunction tsParseAmbientExternalModuleDeclaration() {\n  if (isContextual(ContextualKeyword._global)) {\n    parseIdentifier();\n  } else if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    unexpected();\n  }\n\n  if (match(tt.braceL)) {\n    tsParseModuleBlock();\n  } else {\n    semicolon();\n  }\n}\n\nexport function tsParseImportEqualsDeclaration() {\n  parseImportedIdentifier();\n  expect(tt.eq);\n  tsParseModuleReference();\n  semicolon();\n}\n\nfunction tsIsExternalModuleReference() {\n  return isContextual(ContextualKeyword._require) && lookaheadType() === tt.parenL;\n}\n\nfunction tsParseModuleReference() {\n  if (tsIsExternalModuleReference()) {\n    tsParseExternalModuleReference();\n  } else {\n    tsParseEntityName();\n  }\n}\n\nfunction tsParseExternalModuleReference() {\n  expectContextual(ContextualKeyword._require);\n  expect(tt.parenL);\n  if (!match(tt.string)) {\n    unexpected();\n  }\n  parseLiteral();\n  expect(tt.parenR);\n}\n\n// Utilities\n\n// Returns true if a statement matched.\nfunction tsTryParseDeclare() {\n  if (isLineTerminator()) {\n    return false;\n  }\n  switch (state.type) {\n    case tt._function: {\n      const oldIsType = pushTypeContext(1);\n      next();\n      // We don't need to precisely get the function start here, since it's only used to mark\n      // the function as a type if it's bodiless, and it's already a type here.\n      const functionStart = state.start;\n      parseFunction(functionStart, /* isStatement */ true);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._class: {\n      const oldIsType = pushTypeContext(1);\n      parseClass(/* isStatement */ true, /* optionalId */ false);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._const: {\n      if (match(tt._const) && isLookaheadContextual(ContextualKeyword._enum)) {\n        const oldIsType = pushTypeContext(1);\n        // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n        expect(tt._const);\n        expectContextual(ContextualKeyword._enum);\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n    }\n    // falls through\n    case tt._var:\n    case tt._let: {\n      const oldIsType = pushTypeContext(1);\n      parseVarStatement(state.type !== tt._var);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt.name: {\n      const oldIsType = pushTypeContext(1);\n      const contextualKeyword = state.contextualKeyword;\n      let matched = false;\n      if (contextualKeyword === ContextualKeyword._global) {\n        tsParseAmbientExternalModuleDeclaration();\n        matched = true;\n      } else {\n        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);\n      }\n      popTypeContext(oldIsType);\n      return matched;\n    }\n    default:\n      return false;\n  }\n}\n\n// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n// Returns true if it matched a declaration.\nfunction tsTryParseExportDeclaration() {\n  return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */ true);\n}\n\n// Returns true if it matched a statement.\nfunction tsParseExpressionStatement(contextualKeyword) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._declare: {\n      const declareTokenIndex = state.tokens.length - 1;\n      const matched = tsTryParseDeclare();\n      if (matched) {\n        state.tokens[declareTokenIndex].type = tt._declare;\n        return true;\n      }\n      break;\n    }\n    case ContextualKeyword._global:\n      // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n      if (match(tt.braceL)) {\n        tsParseModuleBlock();\n        return true;\n      }\n      break;\n\n    default:\n      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);\n  }\n  return false;\n}\n\n/**\n * Common code for parsing a declaration.\n *\n * isBeforeToken indicates that the current parser state is at the contextual\n * keyword (and that it is not yet emitted) rather than reading the token after\n * it. When isBeforeToken is true, we may be preceded by an `export` token and\n * should include that token in a type context we create, e.g. to handle\n * `export interface` or `export type`. (This is a bit of a hack and should be\n * cleaned up at some point.)\n *\n * Returns true if it matched a declaration.\n */\nfunction tsParseDeclaration(contextualKeyword, isBeforeToken) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._abstract:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt._class)) {\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        parseClass(/* isStatement */ true, /* optionalId */ false);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._enum:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._interface:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        // `next` is true in \"export\" and \"declare\" contexts, so we want to remove that token\n        // as well.\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseInterfaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._module:\n      if (tsCheckLineTerminator(isBeforeToken)) {\n        if (match(tt.string)) {\n          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n          tsParseAmbientExternalModuleDeclaration();\n          popTypeContext(oldIsType);\n          return true;\n        } else if (match(tt.name)) {\n          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n          tsParseModuleOrNamespaceDeclaration();\n          popTypeContext(oldIsType);\n          return true;\n        }\n      }\n      break;\n\n    case ContextualKeyword._namespace:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseModuleOrNamespaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._type:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseTypeAliasDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n  return false;\n}\n\nfunction tsCheckLineTerminator(isBeforeToken) {\n  if (isBeforeToken) {\n    // Babel checks hasFollowingLineBreak here and returns false, but this\n    // doesn't actually come up, e.g. `export interface` can never be on its own\n    // line in valid code.\n    next();\n    return true;\n  } else {\n    return !isLineTerminator();\n  }\n}\n\n// Returns true if there was a generic async arrow function.\nfunction tsTryParseGenericAsyncArrowFunction() {\n  const snapshot = state.snapshot();\n\n  tsParseTypeParameters();\n  parseFunctionParams();\n  tsTryParseTypeOrTypePredicateAnnotation();\n  expect(tt.arrow);\n\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n\n  parseFunctionBody(true);\n  return true;\n}\n\n/**\n * If necessary, hack the tokenizer state so that this bitshift was actually a\n * less-than token, then keep parsing. This should only be used in situations\n * where we restore from snapshot on error (which reverts this change) or\n * where bitshift would be illegal anyway (e.g. in a class \"extends\" clause).\n *\n * This hack is useful to handle situations like foo<<T>() => void>() where\n * there can legitimately be two open-angle-brackets in a row in TS.\n */\nfunction tsParseTypeArgumentsWithPossibleBitshift() {\n  if (state.type === tt.bitShiftL) {\n    state.pos -= 1;\n    finishToken(tt.lessThan);\n  }\n  tsParseTypeArguments();\n}\n\nfunction tsParseTypeArguments() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    tsParseType();\n    eat(tt.comma);\n  }\n  if (!oldIsType) {\n    // If the type arguments are present in an expression context, e.g.\n    // f<number>(), then the > sign should be tokenized as a non-type token.\n    // In particular, f(a < b, c >= d) should parse the >= as a single token,\n    // resulting in a syntax error and fallback to the non-type-args\n    // interpretation. In the success case, even though the > is tokenized as a\n    // non-type token, it still must be marked as a type token so that it is\n    // erased.\n    popTypeContext(oldIsType);\n    rescan_gt();\n    expect(tt.greaterThan);\n    state.tokens[state.tokens.length - 1].isType = true;\n  } else {\n    expect(tt.greaterThan);\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function tsIsDeclarationStart() {\n  if (match(tt.name)) {\n    switch (state.contextualKeyword) {\n      case ContextualKeyword._abstract:\n      case ContextualKeyword._declare:\n      case ContextualKeyword._enum:\n      case ContextualKeyword._interface:\n      case ContextualKeyword._module:\n      case ContextualKeyword._namespace:\n      case ContextualKeyword._type:\n        return true;\n      default:\n        break;\n    }\n  }\n\n  return false;\n}\n\n// ======================================================\n// OVERRIDES\n// ======================================================\n\nexport function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n\n  // The original code checked the node type to make sure this function type allows a missing\n  // body, but we skip that to avoid sending around the node type. We instead just use the\n  // allowExpressionBody boolean to make sure it's not an arrow function.\n  if (!match(tt.braceL) && isLineTerminator()) {\n    // Retroactively mark the function declaration as a type.\n    let i = state.tokens.length - 1;\n    while (\n      i >= 0 &&\n      (state.tokens[i].start >= functionStart ||\n        state.tokens[i].type === tt._default ||\n        state.tokens[i].type === tt._export)\n    ) {\n      state.tokens[i].isType = true;\n      i--;\n    }\n    return;\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function tsParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!hasPrecedingLineBreak() && eat(tt.bang)) {\n    state.tokens[state.tokens.length - 1].type = tt.nonNullAssertion;\n    return;\n  }\n\n  if (match(tt.lessThan) || match(tt.bitShiftL)) {\n    // There are number of things we are going to \"maybe\" parse, like type arguments on\n    // tagged template expressions. If any of them fail, walk it back and continue.\n    const snapshot = state.snapshot();\n\n    if (!noCalls && atPossibleAsync()) {\n      // Almost certainly this is a generic async function `async <T>() => ...\n      // But it might be a call with a type argument `async<T>();`\n      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();\n      if (asyncArrowFn) {\n        return;\n      }\n    }\n    tsParseTypeArgumentsWithPossibleBitshift();\n    if (!noCalls && eat(tt.parenL)) {\n      // With f<T>(), the subscriptStartIndex marker is on the ( token.\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      parseCallExpressionArguments();\n    } else if (match(tt.backQuote)) {\n      // Tagged template with a type argument.\n      parseTemplate();\n    } else if (\n      // The remaining possible case is an instantiation expression, e.g.\n      // Array<number> . Check for a few cases that would disqualify it and\n      // cause us to bail out.\n      // a<b>>c is not (a<b>)>c, but a<(b>>c)\n      state.type === tt.greaterThan ||\n      // a<b>c is (a<b)>c\n      (state.type !== tt.parenL &&\n        Boolean(state.type & TokenType.IS_EXPRESSION_START) &&\n        !hasPrecedingLineBreak())\n    ) {\n      // Bail out. We have something like a<b>c, which is not an expression with\n      // type arguments but an (a < b) > c comparison.\n      unexpected();\n    }\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  } else if (!noCalls && match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    // If we see f?.<, then this must be an optional call with a type argument.\n    next();\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    tsParseTypeArguments();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function tsTryParseExport() {\n  if (eat(tt._import)) {\n    // One of these cases:\n    // export import A = B;\n    // export import type A = require(\"A\");\n    if (isContextual(ContextualKeyword._type) && lookaheadType() !== tt.eq) {\n      // Eat a `type` token, unless it's actually an identifier name.\n      expectContextual(ContextualKeyword._type);\n    }\n    tsParseImportEqualsDeclaration();\n    return true;\n  } else if (eat(tt.eq)) {\n    // `export = x;`\n    parseExpression();\n    semicolon();\n    return true;\n  } else if (eatContextual(ContextualKeyword._as)) {\n    // `export as namespace A;`\n    // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n    expectContextual(ContextualKeyword._namespace);\n    parseIdentifier();\n    semicolon();\n    return true;\n  } else {\n    if (isContextual(ContextualKeyword._type)) {\n      const nextType = lookaheadType();\n      // export type {foo} from 'a';\n      // export type * from 'a';'\n      // export type * as ns from 'a';'\n      if (nextType === tt.braceL || nextType === tt.star) {\n        next();\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Parse a TS import specifier, which may be prefixed with \"type\" and may be of\n * the form `foo as bar`.\n *\n * The number of identifier-like tokens we see happens to be enough to uniquely\n * identify the form, so simply count the number of identifiers rather than\n * matching the words `type` or `as`. This is particularly important because\n * `type` and `as` could each actually be plain identifiers rather than\n * keywords.\n */\nexport function tsParseImportSpecifier() {\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {type foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    state.tokens[state.tokens.length - 2].isType = true;\n    state.tokens[state.tokens.length - 1].isType = true;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {foo as bar}\n    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    return;\n  }\n  parseIdentifier();\n  // import {type foo as bar}\n  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n  state.tokens[state.tokens.length - 4].isType = true;\n  state.tokens[state.tokens.length - 3].isType = true;\n  state.tokens[state.tokens.length - 2].isType = true;\n  state.tokens[state.tokens.length - 1].isType = true;\n}\n\n/**\n * Just like named import specifiers, export specifiers can have from 1 to 4\n * tokens, inclusive, and the number of tokens determines the role of each token.\n */\nexport function tsParseExportSpecifier() {\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {type foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    state.tokens[state.tokens.length - 2].isType = true;\n    state.tokens[state.tokens.length - 1].isType = true;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {foo as bar}\n    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;\n    return;\n  }\n  parseIdentifier();\n  // export {type foo as bar}\n  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;\n  state.tokens[state.tokens.length - 4].isType = true;\n  state.tokens[state.tokens.length - 3].isType = true;\n  state.tokens[state.tokens.length - 2].isType = true;\n  state.tokens[state.tokens.length - 1].isType = true;\n}\n\nexport function tsTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._class) {\n    state.type = tt._abstract;\n    next(); // Skip \"abstract\"\n    parseClass(true, true);\n    return true;\n  }\n  if (isContextual(ContextualKeyword._interface)) {\n    // Make sure \"export default\" are considered type tokens so the whole thing is removed.\n    const oldIsType = pushTypeContext(2);\n    tsParseDeclaration(ContextualKeyword._interface, true);\n    popTypeContext(oldIsType);\n    return true;\n  }\n  return false;\n}\n\nexport function tsTryParseStatementContent() {\n  if (state.type === tt._const) {\n    const ahead = lookaheadTypeAndKeyword();\n    if (ahead.type === tt.name && ahead.contextualKeyword === ContextualKeyword._enum) {\n      expect(tt._const);\n      expectContextual(ContextualKeyword._enum);\n      state.tokens[state.tokens.length - 1].type = tt._enum;\n      tsParseEnumDeclaration();\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function tsTryParseClassMemberWithIsStatic(isStatic) {\n  const memberStartIndexAfterStatic = state.tokens.length;\n  tsParseModifiers([\n    ContextualKeyword._abstract,\n    ContextualKeyword._readonly,\n    ContextualKeyword._declare,\n    ContextualKeyword._static,\n    ContextualKeyword._override,\n  ]);\n\n  const modifiersEndIndex = state.tokens.length;\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    // Index signatures are type declarations, so set the modifier tokens as\n    // type tokens. Most tokens could be assumed to be type tokens, but `static`\n    // is ambiguous unless we set it explicitly here.\n    const memberStartIndex = isStatic\n      ? memberStartIndexAfterStatic - 1\n      : memberStartIndexAfterStatic;\n    for (let i = memberStartIndex; i < modifiersEndIndex; i++) {\n      state.tokens[i].isType = true;\n    }\n    return true;\n  }\n  return false;\n}\n\n// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`\n// is that e.g. `type()` is valid JS, so we must try parsing that first.\n// If it's really a type, we will parse `type` as the statement, and can correct it here\n// by parsing the rest.\nexport function tsParseIdentifierStatement(contextualKeyword) {\n  const matched = tsParseExpressionStatement(contextualKeyword);\n  if (!matched) {\n    semicolon();\n  }\n}\n\nexport function tsParseExportDeclaration() {\n  // \"export declare\" is equivalent to just \"export\".\n  const isDeclare = eatContextual(ContextualKeyword._declare);\n  if (isDeclare) {\n    state.tokens[state.tokens.length - 1].type = tt._declare;\n  }\n\n  let matchedDeclaration = false;\n  if (match(tt.name)) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      matchedDeclaration = tsTryParseExportDeclaration();\n      popTypeContext(oldIsType);\n    } else {\n      matchedDeclaration = tsTryParseExportDeclaration();\n    }\n  }\n  if (!matchedDeclaration) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      parseStatement(true);\n      popTypeContext(oldIsType);\n    } else {\n      parseStatement(true);\n    }\n  }\n}\n\nexport function tsAfterParseClassSuper(hasSuper) {\n  if (hasSuper && (match(tt.lessThan) || match(tt.bitShiftL))) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  if (eatContextual(ContextualKeyword._implements)) {\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    const oldIsType = pushTypeContext(1);\n    tsParseHeritageClause();\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function tsStartParseObjPropValue() {\n  tsTryParseTypeParameters();\n}\n\nexport function tsStartParseFunctionParams() {\n  tsTryParseTypeParameters();\n}\n\n// `let x: number;`\nexport function tsAfterParseVarHead() {\n  const oldIsType = pushTypeContext(0);\n  if (!hasPrecedingLineBreak()) {\n    eat(tt.bang);\n  }\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function tsStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\n// Returns true if the expression was an arrow function.\nexport function tsParseMaybeAssign(noIn, isWithinParens) {\n  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n  if (isJSXEnabled) {\n    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);\n  } else {\n    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);\n  }\n}\n\nexport function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  // Prefer to parse JSX if possible. But may be an arrow fn.\n  const snapshot = state.snapshot();\n  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Otherwise, try as type-parameterized arrow function.\n  state.type = tt.typeParameterStart;\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n\n  return wasArrow;\n}\n\nexport function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  const snapshot = state.snapshot();\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Try parsing a type cast instead of an arrow function.\n  // This will start with a type assertion (via parseMaybeUnary).\n  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\nexport function tsParseArrow() {\n  if (match(tt.colon)) {\n    // This is different from how the TS parser does it.\n    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.\n    const snapshot = state.snapshot();\n\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n  return eat(tt.arrow);\n}\n\n// Allow type annotations inside of a parameter list.\nexport function tsParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseMaybeDecoratorArguments() {\n  if (match(tt.lessThan) || match(tt.bitShiftL)) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  baseParseMaybeDecoratorArguments();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}