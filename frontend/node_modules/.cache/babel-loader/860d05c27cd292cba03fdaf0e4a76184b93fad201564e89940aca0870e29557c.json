{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports,\n// Arbitrary values must contain balanced brackets (), [] and {}. Escaped\n// values don't count, and brackets inside quotes also don't count.\n//\n// E.g.: w-[this-is]w-[weird-and-invalid]\n// E.g.: w-[this-is\\\\]w-\\\\[weird-but-valid]\n// E.g.: content-['this-is-also-valid]-weirdly-enough']\n\"default\", {\n  enumerable: true,\n  get: function () {\n    return isSyntacticallyValidPropertyValue;\n  }\n});\nlet matchingBrackets = new Map([[\"{\", \"}\"], [\"[\", \"]\"], [\"(\", \")\"]]);\nlet inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(([k, v]) => [v, k]));\nlet quotes = new Set(['\"', \"'\", \"`\"]);\nfunction isSyntacticallyValidPropertyValue(value) {\n  let stack = [];\n  let inQuotes = false;\n  for (let i = 0; i < value.length; i++) {\n    let char = value[i];\n    if (char === \":\" && !inQuotes && stack.length === 0) {\n      return false;\n    }\n    // Non-escaped quotes allow us to \"allow\" anything in between\n    if (quotes.has(char) && value[i - 1] !== \"\\\\\") {\n      inQuotes = !inQuotes;\n    }\n    if (inQuotes) continue;\n    if (value[i - 1] === \"\\\\\") continue; // Escaped\n    if (matchingBrackets.has(char)) {\n      stack.push(char);\n    } else if (inverseMatchingBrackets.has(char)) {\n      let inverse = inverseMatchingBrackets.get(char);\n      // Nothing to pop from, therefore it is unbalanced\n      if (stack.length <= 0) {\n        return false;\n      }\n      // Popped value must match the inverse value, otherwise it is unbalanced\n      if (stack.pop() !== inverse) {\n        return false;\n      }\n    }\n  }\n  // If there is still something on the stack, it is also unbalanced\n  if (stack.length > 0) {\n    return false;\n  }\n  // All good, totally balanced!\n  return true;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","isSyntacticallyValidPropertyValue","matchingBrackets","Map","inverseMatchingBrackets","Array","from","entries","map","k","v","quotes","Set","stack","inQuotes","i","length","char","has","push","inverse","pop"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/tailwindcss/lib/util/isSyntacticallyValidPropertyValue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // Arbitrary values must contain balanced brackets (), [] and {}. Escaped\n// values don't count, and brackets inside quotes also don't count.\n//\n// E.g.: w-[this-is]w-[weird-and-invalid]\n// E.g.: w-[this-is\\\\]w-\\\\[weird-but-valid]\n// E.g.: content-['this-is-also-valid]-weirdly-enough']\n\"default\", {\n    enumerable: true,\n    get: function() {\n        return isSyntacticallyValidPropertyValue;\n    }\n});\nlet matchingBrackets = new Map([\n    [\n        \"{\",\n        \"}\"\n    ],\n    [\n        \"[\",\n        \"]\"\n    ],\n    [\n        \"(\",\n        \")\"\n    ]\n]);\nlet inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(([k, v])=>[\n        v,\n        k\n    ]));\nlet quotes = new Set([\n    '\"',\n    \"'\",\n    \"`\"\n]);\nfunction isSyntacticallyValidPropertyValue(value) {\n    let stack = [];\n    let inQuotes = false;\n    for(let i = 0; i < value.length; i++){\n        let char = value[i];\n        if (char === \":\" && !inQuotes && stack.length === 0) {\n            return false;\n        }\n        // Non-escaped quotes allow us to \"allow\" anything in between\n        if (quotes.has(char) && value[i - 1] !== \"\\\\\") {\n            inQuotes = !inQuotes;\n        }\n        if (inQuotes) continue;\n        if (value[i - 1] === \"\\\\\") continue; // Escaped\n        if (matchingBrackets.has(char)) {\n            stack.push(char);\n        } else if (inverseMatchingBrackets.has(char)) {\n            let inverse = inverseMatchingBrackets.get(char);\n            // Nothing to pop from, therefore it is unbalanced\n            if (stack.length <= 0) {\n                return false;\n            }\n            // Popped value must match the inverse value, otherwise it is unbalanced\n            if (stack.pop() !== inverse) {\n                return false;\n            }\n        }\n    }\n    // If there is still something on the stack, it is also unbalanced\n    if (stack.length > 0) {\n        return false;\n    }\n    // All good, totally balanced!\n    return true;\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO;AAAE;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE;EACPE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,OAAOC,iCAAiC;EAC5C;AACJ,CAAC,CAAC;AACF,IAAIC,gBAAgB,GAAG,IAAIC,GAAG,CAAC,CAC3B,CACI,GAAG,EACH,GAAG,CACN,EACD,CACI,GAAG,EACH,GAAG,CACN,EACD,CACI,GAAG,EACH,GAAG,CACN,CACJ,CAAC;AACF,IAAIC,uBAAuB,GAAG,IAAID,GAAG,CAACE,KAAK,CAACC,IAAI,CAACJ,gBAAgB,CAACK,OAAO,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,CAAC,KAAG,CACnFA,CAAC,EACDD,CAAC,CACJ,CAAC,CAAC;AACP,IAAIE,MAAM,GAAG,IAAIC,GAAG,CAAC,CACjB,GAAG,EACH,GAAG,EACH,GAAG,CACN,CAAC;AACF,SAASX,iCAAiCA,CAACH,KAAK,EAAE;EAC9C,IAAIe,KAAK,GAAG,EAAE;EACd,IAAIC,QAAQ,GAAG,KAAK;EACpB,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,KAAK,CAACkB,MAAM,EAAED,CAAC,EAAE,EAAC;IACjC,IAAIE,IAAI,GAAGnB,KAAK,CAACiB,CAAC,CAAC;IACnB,IAAIE,IAAI,KAAK,GAAG,IAAI,CAACH,QAAQ,IAAID,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACjD,OAAO,KAAK;IAChB;IACA;IACA,IAAIL,MAAM,CAACO,GAAG,CAACD,IAAI,CAAC,IAAInB,KAAK,CAACiB,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;MAC3CD,QAAQ,GAAG,CAACA,QAAQ;IACxB;IACA,IAAIA,QAAQ,EAAE;IACd,IAAIhB,KAAK,CAACiB,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE,SAAS,CAAC;IACrC,IAAIb,gBAAgB,CAACgB,GAAG,CAACD,IAAI,CAAC,EAAE;MAC5BJ,KAAK,CAACM,IAAI,CAACF,IAAI,CAAC;IACpB,CAAC,MAAM,IAAIb,uBAAuB,CAACc,GAAG,CAACD,IAAI,CAAC,EAAE;MAC1C,IAAIG,OAAO,GAAGhB,uBAAuB,CAACJ,GAAG,CAACiB,IAAI,CAAC;MAC/C;MACA,IAAIJ,KAAK,CAACG,MAAM,IAAI,CAAC,EAAE;QACnB,OAAO,KAAK;MAChB;MACA;MACA,IAAIH,KAAK,CAACQ,GAAG,CAAC,CAAC,KAAKD,OAAO,EAAE;QACzB,OAAO,KAAK;MAChB;IACJ;EACJ;EACA;EACA,IAAIP,KAAK,CAACG,MAAM,GAAG,CAAC,EAAE;IAClB,OAAO,KAAK;EAChB;EACA;EACA,OAAO,IAAI;AACf"},"metadata":{},"sourceType":"script","externalDependencies":[]}