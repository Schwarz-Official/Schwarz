{"ast":null,"code":"/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n  if (!options) {\n    return defaults;\n  }\n  var result = {};\n  for (var key in defaults) {\n    // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n    // only recognized option names are used.\n    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n  }\n  return result;\n};\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n  options = merge(options, cssesc.options);\n  if (options.quotes != 'single' && options.quotes != 'double') {\n    options.quotes = 'single';\n  }\n  var quote = options.quotes == 'double' ? '\"' : '\\'';\n  var isIdentifier = options.isIdentifier;\n  var firstChar = string.charAt(0);\n  var output = '';\n  var counter = 0;\n  var length = string.length;\n  while (counter < length) {\n    var character = string.charAt(counter++);\n    var codePoint = character.charCodeAt();\n    var value = void 0;\n    // If it’s not a printable ASCII character…\n    if (codePoint < 0x20 || codePoint > 0x7E) {\n      if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n        // It’s a high surrogate, and there is a next character.\n        var extra = string.charCodeAt(counter++);\n        if ((extra & 0xFC00) == 0xDC00) {\n          // next character is low surrogate\n          codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n        } else {\n          // It’s an unmatched surrogate; only append this code unit, in case\n          // the next code unit is the high surrogate of a surrogate pair.\n          counter--;\n        }\n      }\n      value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n    } else {\n      if (options.escapeEverything) {\n        if (regexAnySingleEscape.test(character)) {\n          value = '\\\\' + character;\n        } else {\n          value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n        }\n      } else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n        value = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n      } else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n        value = '\\\\' + character;\n      } else {\n        value = character;\n      }\n    }\n    output += value;\n  }\n  if (isIdentifier) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    } else if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  }\n\n  // Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n  // since they’re redundant. Note that this is only possible if the escape\n  // sequence isn’t preceded by an odd number of backslashes.\n  output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n    if ($1 && $1.length % 2) {\n      // It’s not safe to remove the space, so don’t.\n      return $0;\n    }\n    // Strip the space.\n    return ($1 || '') + $2;\n  });\n  if (!isIdentifier && options.wrap) {\n    return quote + output + quote;\n  }\n  return output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n  'escapeEverything': false,\n  'isIdentifier': false,\n  'quotes': 'single',\n  'wrap': false\n};\ncssesc.version = '3.0.0';\nmodule.exports = cssesc;","map":{"version":3,"names":["object","hasOwnProperty","merge","options","defaults","result","key","call","regexAnySingleEscape","regexSingleEscape","regexAlwaysEscape","regexExcessiveSpaces","cssesc","string","quotes","quote","isIdentifier","firstChar","charAt","output","counter","length","character","codePoint","charCodeAt","value","extra","toString","toUpperCase","escapeEverything","test","slice","replace","$0","$1","$2","wrap","version","module","exports"],"sources":["D:/WEB-PROJECT/Schwarz/frontend/node_modules/cssesc/cssesc.js"],"sourcesContent":["/*! https://mths.be/cssesc v3.0.0 by @mathias */\n'use strict';\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If it’s not a printable ASCII character…\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It’s a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It’s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they’re redundant. Note that this is only possible if the escape\n\t// sequence isn’t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It’s not safe to remove the space, so don’t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n"],"mappings":"AAAA;AACA,YAAY;;AAEZ,IAAIA,MAAM,GAAG,CAAC,CAAC;AACf,IAAIC,cAAc,GAAGD,MAAM,CAACC,cAAc;AAC1C,IAAIC,KAAK,GAAG,SAASA,KAAKA,CAACC,OAAO,EAAEC,QAAQ,EAAE;EAC7C,IAAI,CAACD,OAAO,EAAE;IACb,OAAOC,QAAQ;EAChB;EACA,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,KAAK,IAAIC,GAAG,IAAIF,QAAQ,EAAE;IACzB;IACA;IACAC,MAAM,CAACC,GAAG,CAAC,GAAGL,cAAc,CAACM,IAAI,CAACJ,OAAO,EAAEG,GAAG,CAAC,GAAGH,OAAO,CAACG,GAAG,CAAC,GAAGF,QAAQ,CAACE,GAAG,CAAC;EAC/E;EACA,OAAOD,MAAM;AACd,CAAC;AAED,IAAIG,oBAAoB,GAAG,wBAAwB;AACnD,IAAIC,iBAAiB,GAAG,yBAAyB;AACjD,IAAIC,iBAAiB,GAAG,QAAQ;AAChC,IAAIC,oBAAoB,GAAG,mDAAmD;;AAE9E;AACA,IAAIC,MAAM,GAAG,SAASA,MAAMA,CAACC,MAAM,EAAEV,OAAO,EAAE;EAC7CA,OAAO,GAAGD,KAAK,CAACC,OAAO,EAAES,MAAM,CAACT,OAAO,CAAC;EACxC,IAAIA,OAAO,CAACW,MAAM,IAAI,QAAQ,IAAIX,OAAO,CAACW,MAAM,IAAI,QAAQ,EAAE;IAC7DX,OAAO,CAACW,MAAM,GAAG,QAAQ;EAC1B;EACA,IAAIC,KAAK,GAAGZ,OAAO,CAACW,MAAM,IAAI,QAAQ,GAAG,GAAG,GAAG,IAAI;EACnD,IAAIE,YAAY,GAAGb,OAAO,CAACa,YAAY;EAEvC,IAAIC,SAAS,GAAGJ,MAAM,CAACK,MAAM,CAAC,CAAC,CAAC;EAChC,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,MAAM,GAAGR,MAAM,CAACQ,MAAM;EAC1B,OAAOD,OAAO,GAAGC,MAAM,EAAE;IACxB,IAAIC,SAAS,GAAGT,MAAM,CAACK,MAAM,CAACE,OAAO,EAAE,CAAC;IACxC,IAAIG,SAAS,GAAGD,SAAS,CAACE,UAAU,CAAC,CAAC;IACtC,IAAIC,KAAK,GAAG,KAAK,CAAC;IAClB;IACA,IAAIF,SAAS,GAAG,IAAI,IAAIA,SAAS,GAAG,IAAI,EAAE;MACzC,IAAIA,SAAS,IAAI,MAAM,IAAIA,SAAS,IAAI,MAAM,IAAIH,OAAO,GAAGC,MAAM,EAAE;QACnE;QACA,IAAIK,KAAK,GAAGb,MAAM,CAACW,UAAU,CAACJ,OAAO,EAAE,CAAC;QACxC,IAAI,CAACM,KAAK,GAAG,MAAM,KAAK,MAAM,EAAE;UAC/B;UACAH,SAAS,GAAG,CAAC,CAACA,SAAS,GAAG,KAAK,KAAK,EAAE,KAAKG,KAAK,GAAG,KAAK,CAAC,GAAG,OAAO;QACpE,CAAC,MAAM;UACN;UACA;UACAN,OAAO,EAAE;QACV;MACD;MACAK,KAAK,GAAG,IAAI,GAAGF,SAAS,CAACI,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC,GAAG,GAAG;IAC1D,CAAC,MAAM;MACN,IAAIzB,OAAO,CAAC0B,gBAAgB,EAAE;QAC7B,IAAIrB,oBAAoB,CAACsB,IAAI,CAACR,SAAS,CAAC,EAAE;UACzCG,KAAK,GAAG,IAAI,GAAGH,SAAS;QACzB,CAAC,MAAM;UACNG,KAAK,GAAG,IAAI,GAAGF,SAAS,CAACI,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC,GAAG,GAAG;QAC1D;MACD,CAAC,MAAM,IAAI,gBAAgB,CAACE,IAAI,CAACR,SAAS,CAAC,EAAE;QAC5CG,KAAK,GAAG,IAAI,GAAGF,SAAS,CAACI,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC,GAAG,GAAG;MAC1D,CAAC,MAAM,IAAIN,SAAS,IAAI,IAAI,IAAI,CAACN,YAAY,KAAKM,SAAS,IAAI,GAAG,IAAIP,KAAK,IAAIO,SAAS,IAAIA,SAAS,IAAI,IAAI,IAAIP,KAAK,IAAIO,SAAS,CAAC,IAAIN,YAAY,IAAIP,iBAAiB,CAACqB,IAAI,CAACR,SAAS,CAAC,EAAE;QAC1LG,KAAK,GAAG,IAAI,GAAGH,SAAS;MACzB,CAAC,MAAM;QACNG,KAAK,GAAGH,SAAS;MAClB;IACD;IACAH,MAAM,IAAIM,KAAK;EAChB;EAEA,IAAIT,YAAY,EAAE;IACjB,IAAI,SAAS,CAACc,IAAI,CAACX,MAAM,CAAC,EAAE;MAC3BA,MAAM,GAAG,KAAK,GAAGA,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC;IACjC,CAAC,MAAM,IAAI,IAAI,CAACD,IAAI,CAACb,SAAS,CAAC,EAAE;MAChCE,MAAM,GAAG,KAAK,GAAGF,SAAS,GAAG,GAAG,GAAGE,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC;IACnD;EACD;;EAEA;EACA;EACA;EACAZ,MAAM,GAAGA,MAAM,CAACa,OAAO,CAACrB,oBAAoB,EAAE,UAAUsB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;IACnE,IAAID,EAAE,IAAIA,EAAE,CAACb,MAAM,GAAG,CAAC,EAAE;MACxB;MACA,OAAOY,EAAE;IACV;IACA;IACA,OAAO,CAACC,EAAE,IAAI,EAAE,IAAIC,EAAE;EACvB,CAAC,CAAC;EAEF,IAAI,CAACnB,YAAY,IAAIb,OAAO,CAACiC,IAAI,EAAE;IAClC,OAAOrB,KAAK,GAAGI,MAAM,GAAGJ,KAAK;EAC9B;EACA,OAAOI,MAAM;AACd,CAAC;;AAED;AACAP,MAAM,CAACT,OAAO,GAAG;EAChB,kBAAkB,EAAE,KAAK;EACzB,cAAc,EAAE,KAAK;EACrB,QAAQ,EAAE,QAAQ;EAClB,MAAM,EAAE;AACT,CAAC;AAEDS,MAAM,CAACyB,OAAO,GAAG,OAAO;AAExBC,MAAM,CAACC,OAAO,GAAG3B,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}