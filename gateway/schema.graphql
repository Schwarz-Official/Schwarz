"""
The purpose of the `cost` directive is to define a `weight` for GraphQL types,
fields, and arguments. Static analysis can use these weights when calculating
the overall cost of a query or response.
"""
directive @cost(
  """
  The `weight` argument defines what value to add to the overall cost for every
  appearance, or possible appearance, of a type, field, argument, etc.
  """
  weight: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"""
The `@specifiedBy` directive is used within the type system definition language
to provide a URL for specifying the behavior of custom scalar definitions.
"""
directive @specifiedBy(
  """
  The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types.
  """
  url: String!
) on SCALAR

input CreateUserInput {
  address: String!
  clientMutationId: String
  company: String!
  dateOfBirth: Date!
  email: String!
  experience: Int!
  firstName: String!
  gender: String!
  industry: String!
  jobTitle: String!
  lastName: String!
  password: String!
  preferredLang: String!
}

type CreateUserPayload {
  clientMutationId: String
  user: UserNode
}

"""The `Date` scalar represents an ISO-8601 compliant date type."""
scalar Date

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

"""A generic scalar type that can handle various object types"""
scalar GenericScalar

type Mutation {
  createUser(input: CreateUserInput!): CreateUserPayload
  refreshToken(input: RefreshInput!): RefreshPayload
  requestPasswordReset(input: RequestPasswordResetInput!): RequestPasswordResetPayload
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload
  tokenAuth(input: ObtainJSONWebTokenInput!): ObtainJSONWebTokenPayload
  updatePreferences(input: UpdatePreferencesInput!): UpdatePreferencesPayload
  validateResetToken(input: ValidatePasswordResetTokenInput!): ValidatePasswordResetTokenPayload
  verifyToken(input: VerifyInput!): VerifyPayload
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

input ObtainJSONWebTokenInput {
  clientMutationId: String
  email: String!
  password: String!
}

type ObtainJSONWebTokenPayload {
  clientMutationId: String
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  user: UserNode
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Query {
  allUsers(after: String, before: String, email: String, first: Int, firstName: String, last: Int, lastName: String, offset: Int): UserNodeConnection
  isAuthenticated: Boolean
  me: UserNode
  user(
    """The ID of the object"""
    id: ID!
  ): UserNode
}

input RefreshInput {
  clientMutationId: String
  token: String
}

type RefreshPayload {
  clientMutationId: String
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
}

input RequestPasswordResetInput {
  clientMutationId: String
  email: String!
}

type RequestPasswordResetPayload {
  clientMutationId: String
  errors: [String]
  success: Boolean
}

input ResetPasswordInput {
  clientMutationId: String
  confirmPassword: String!
  newPassword: String!
  token: String!
  uidb64: String!
}

type ResetPasswordPayload {
  clientMutationId: String
  errors: [String]
  success: Boolean
}

input UpdatePreferencesInput {
  clientMutationId: String
  darkMode: Boolean!
}

type UpdatePreferencesPayload {
  clientMutationId: String
  preferences: UserPreferencesNode
}

type UserNode implements Node {
  address: String!
  company: String!
  createdAt: DateTime!
  dateOfBirth: Date!
  email: String!
  experience: Int!
  firstName: String!
  gender: String!

  """The ID of the object"""
  id: ID!
  industry: String!
  isActive: Boolean!
  isAdmin: Boolean!
  jobTitle: String!
  lastLogin: DateTime
  lastName: String!
  password: String!
  preferredLang: String!
  updatedAt: DateTime!
  userpreferences: UserPreferencesNode
}

type UserNodeConnection {
  """Contains the nodes in this connection."""
  edges: [UserNodeEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
}

"""A Relay edge containing a `UserNode` and its cursor."""
type UserNodeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: UserNode
}

type UserPreferencesNode implements Node {
  darkMode: Boolean!

  """The ID of the object"""
  id: ID!
  user: UserNode!
}

input ValidatePasswordResetTokenInput {
  clientMutationId: String
  token: String!
  uidb64: String!
}

type ValidatePasswordResetTokenPayload {
  clientMutationId: String
  errors: [String]
  success: Boolean
}

input VerifyInput {
  clientMutationId: String
  token: String
}

type VerifyPayload {
  clientMutationId: String
  payload: GenericScalar!
}

